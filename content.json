{"meta":{"title":"寇强的个人空间","subtitle":"个人博客","description":"自建博客页面","author":"寇强","url":"http://kouqiang.space","root":"/"},"pages":[{"title":"more","date":"2023-01-09T08:55:01.000Z","updated":"2023-01-09T08:55:01.761Z","comments":true,"path":"more/index.html","permalink":"http://kouqiang.space/more/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2023-01-09T08:58:56.844Z","updated":"2023-01-09T08:58:56.844Z","comments":true,"path":"categories/index.html","permalink":"http://kouqiang.space/categories/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2023-01-09T09:00:48.705Z","updated":"2023-01-09T09:00:48.705Z","comments":true,"path":"friends/index.html","permalink":"http://kouqiang.space/friends/index.html","excerpt":"这里写友链上方的内容。","text":"这里写友链上方的内容。 这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。"},{"title":"所有标签","date":"2023-01-09T08:59:23.362Z","updated":"2023-01-09T08:59:23.362Z","comments":true,"path":"tags/index.html","permalink":"http://kouqiang.space/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JavaScript——技术篇","slug":"JavaScript——技术篇","date":"2024-05-14T10:50:00.000Z","updated":"2024-05-15T13:00:02.749Z","comments":true,"path":"2024/05/14/JavaScript——技术篇/","link":"","permalink":"http://kouqiang.space/2024/05/14/JavaScript%E2%80%94%E2%80%94%E6%8A%80%E6%9C%AF%E7%AF%87/","excerpt":"","text":"JavaScript——技术篇一、js事件事件处理的过程分三步： 发生事件 启动事件处理程序 事件处理程序作出反应 事件处理程序可以是任意的js语句，我们一般用的特定的自定义函数来对事件进行处理。 （一）js的常用事件1、鼠标键盘事件 事件 说明 onclick 鼠标单击时触发此事件 ondblclick 鼠标双击时触发此事件 onmousedown 按下鼠标时触发此事件 onmouseup 按下的鼠标松开时触发此事件 onmouseover 鼠标移动到对象上方时触发此事件 onmouseout 鼠标离开对象时触发此事件 onmousemove 鼠标移动时触发此事件 onkeypress 键盘上某按钮按下并释放时触发此事件 onkeydown 键盘上某按钮按下时触发此事件 onkeyup 键盘上某按下的按钮释放时触发此事件 2、表单相关事件 事件 说明 onfocus 某元素获得焦点时触发此事件 onblur 某元素失去焦点时触发此事件 onchange 某元素失去焦点，并且元素的内容发生改变时触发此事件 onsubmit 一个表单被提交时触发此事件 onreset 当表单中的RESET属性被激活时触发此事件 3、页面相关事件 事件 说明 onload 页面内容加载完成时触发此事件 onunload 当前页面被改变时触发此事件 onresize 浏览器窗口大小被改变时触发此事件 （二）事件的调用1、在HTML中调用直接在目标标签属性中添加相应事件为属性，属性值就是函数名或者代码片段： 1&lt;input type=&quot;button&quot; value=&quot;测试按钮&quot; onclick=&quot;alert(&#x27;绑定事件测试成功！&#x27;)&quot; /&gt; 2、在js中调用在js代码中，先get到目标对象的引用，再给它绑定事件： 123456789&lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;测试按钮2&quot; id=&quot;button01&quot; /&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot;&gt; var bt01 = document.getElementById(&quot;button01&quot;); bt01.onclick = function()&#123; alert(&quot;测试事件2绑定成功！&quot;); &#125;&lt;/script&gt; 必须将js代码置于标签代码之后！ （三）Event对象不知所云，但很重要！ 回头再了解。 二、BOM对象Window对象代表的是打开的浏览器窗口，通过 Window对象可以打开窗口或关闭窗口、控制窗口的大小和位置，由窗口弹出的对话框，还可以控制窗口上是否显示地址栏、工具栏和状态栏等栏目。对于窗口中的内容，Window 对象可以控制是否重载网页、返回上一个文档或前进到下一个文档。 在框架方面，Window对象可以处理框架与框架之间的关系，并通过这种关系在一个框架处理另一个框架中的文档。Window对象还是所有其他对象的顶级对象，通过对 Window 对象的子对象进行操作，可以实现更多的动态效果。Window对象作为对象的一种，也有着其自己的方法和属性。 （一）Window对象顶层Window对象是所有其他子对象的父对象，它出现在每一个页面上，并且可以在单个js应用程序中被多次使用。 1、常用属性 属性 说明 document 对话框中显示的当前文档 frames 当前对话框中所有frame对象的集合 location 当前文档的URL name 对话框的名字 status 状态栏中的当前信息 defaultStatus 状态栏中的当前信息 top 最顶层的浏览器对话框 parent 包含当前对话框的父对话框 opener 打开当前对话框的父对话框 closed 当前对话框是否关闭的逻辑值 self 表示当前对话框 screen 表示用户屏幕，提供屏幕尺寸、颜色深度等信息 navigator 飙车浏览器对象，用于获得与浏览器相关的信息 2、常用方法 方法 说明 alter(&quot;警告内容&quot;) 弹出一个警告对话框，参数为非必须项，窗口关闭前后续代码不会执行！ confirm(&quot;提示信息&quot;) 弹出一个确认对话框，参数为非必须项，点击确认返回true，点击取消返回false prompt(&quot;窗口提示信息&quot;, &quot;初始输入内容&quot;) 弹出一个提示对话框，参数都是非必须项，点击确认返回输入的文本，点击取消返回null open() 打开一个新的浏览器窗口或查找一个已命名的窗口 close() 关闭被引用的窗口 focus() 将被引用的对话框放在所有打开窗口的前面 blur() 将被引用的对话框放在所有打开窗口的后面 scrollTo(x, y) 把窗口滚动到指定的坐标 scrollBy(offsetX, offsetY) 按照指定的位移量滚动窗口 setTimeout(timer) 在指定的毫秒数过后，对传递的表达式求值 setInterval(interval) 指定周期性执行代码 moveTo(x, y) 将窗口移动到指定坐标处 resizeTo(x, y) 按照指定的尺寸更改窗口大小，窗口左上角位置不变 resizeBy(offsetX, offsetY) 按照指定的增量更改窗口大小，增量为正则变大，为负则变小，窗口左上角位置不变 print() 相当于浏览器工具中的“打印”按钮 navigate(URL) 使用对话框显示URL指定的页面 几个方法的详细使用方式： open(URL,name,specs,replace) 用于打开一个新的浏览器窗口或查找一个已命名的窗口，参数都是可选项，每项参数都要用引号引起来！ URL：目标窗口的url，为空则打开空白窗口。 windowname：指定target属性或窗口的名称。支持以下值： _blank：加载到一个新的窗口。这是默认。 _parent：加载到父框架。 _self：替换当前页面。 _top：替换任何可加载的框架集。 自定义的窗口名称。 specs：新窗口的参数，多个项目之间用逗号分隔，有以下项目可选： 参数 说明 top=pixels 窗口距离屏幕顶端的像素数 left=pixels 窗口距离屏幕左侧的像素数 width=pixels 窗口的宽 height=pixels 窗口的高，最小值为100 scrollbars=yes/no/1/0 是否显示滚动条，默认yes resizable=yes/no/1/0 是否可调节窗口大小，默认yes toolbar=yes/no/1/0 是否显示浏览器工具栏，默认yes menubar=yes/no/1/0 是否显示菜单栏，默认yes location=yes/no/1/0 是否显示地址栏，默认yes status=yes/no/1/0 是否显示状态栏，默认yes replace：规定新建窗口的这条浏览记录是在浏览器历史记录里替换当前条目还是新建条目： true：替换浏览历史中的当前条目。 false：在浏览历史中新建条目。 close() 关闭当前窗口： 123close();window.close();this.close(); 要关闭指定窗口，需获取目标窗口的引用： 1windObj.close(); scrollTo(x, y) 滚动到文档的绝对位置，参数x，y分别指文档本身的坐标点，将该点置于窗口左上角。 注：该方法是js1.2中规定的，js1.1版本中规定的方法是scroll()，二者完全相同。 scrollBy(offsetX, offsetY) 按照位移量滚动窗口，正数则向右&#x2F;下滚动，负数则向左&#x2F;上滚动，滚动量是相对文档自身的像素值，而与屏幕缩放与否无关。 setTimeout(timer) 设置超时，即为窗口设置一段时间后进行某个操作： 1timerId = setTimeOut(); 参数可以是一段js代码片段，也可以是要等待的毫秒数。 在代码执行前，还可以使用clearTimeOut()来取消该设定： 1clearTimeOut(timeId); setInterval(interval) 3、Window对象的使用Window对象不用创建，可以直接调用其方法或属性： 12345window.属性名;window.方法名;window.alert(&quot;警告内容&quot;);window.document.write(&quot;字符串&quot;); js中self表示当前窗口，parent表示父级窗口，因此某些情况可以使用这些关键字来代替window： 12self.属性名;parent.方法名; （二）history对象该对象用来访问窗口的历史记录： 1[window.]history.属性名|方法名[(方法参数)]; 1、常用属性 属性 说明 length 历史纪录列表的长度，返回数字 current 当前文档的URL next 历史列表的下一个URL previous 历史列表的上一个URL 2、常用方法 方法 说明 back() 后退 forward() 前进 go() 前进或后退的数目，当前为0，2为前进2项，-1为后退1项 （三）一些通用的窗口事件 事件 描述 windowId.onfocus() 窗口获得焦点时激活 windowId.onblur() 窗口失去焦点时激活 windowId.onload() 文档完全载入窗口时激活 windowId.onunload() 文档未载入时激活 windowId.onresize() 用户改变窗口大小时激活 windowId.onerror() 出现js错误时激活 三、DOM对象DOM，即Document Object Model，文档对象模型。 在 HTML DOM (Document Object Model) 中 , 每一个元素都是 节点: 文档是一个文档节点。 所有的HTML元素都是元素节点。 所有 HTML 属性都是属性节点。 文本插入到 HTML 元素是文本节点。 注释是注释节点。 Document 对象： 当浏览器载入 HTML 文档, 它就会成为 Document 对象。 Document 对象是 HTML 文档的根节点。 Document 对象使我们可以从脚本中对 HTML 页面中的所有元素进行访问。 提示：Document 对象是 Window 对象的一部分，可通过 window.document 属性对其进行访问。 （一）DOM对象节点属性 属性 说明 nodeName 节点的名称 nodeValue 结点的值，通常只应用于文本节点 nodeType 结点的类型 parentNode 父结点 childNodes 子结点列表 firstChild 第一个子节点 lastChild 最后一个子结点 previousSibling 前一个兄弟节点 nextSibling 后一个兄弟节点 attributes 元素的属性列表 （二）结点的操作1、获取节点获取节点通过方法： document.getElementById(); 返回对拥有指定 id 的第一个对象的引用： 1234567&lt;body&gt; &lt;button id=&quot;bt01&quot;&gt;按钮文本&lt;/button&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot; &gt; var a = document.getElementById(&quot;bt01&quot;);&lt;/script&gt; document.getElementsByName(); 返回带有name属性的对象的集合，作为NodeList对象，以下三种get方法的返回值都是如此。 NodeList对象代表一个有顺序的节点列表。我们可通过节点列表中的节点索引号来访问列表中的节点(索引号由0开始)。 12345678910111213&lt;body&gt; &lt;h3 name=&quot;p1&quot;&gt; ... &lt;/h3&gt; &lt;p name=&quot;p1&quot;&gt; ... &lt;/p&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot; &gt; var b = document.getElementsByName(&quot;p1&quot;); alert(b.length);&lt;/script&gt; document.getElementsByTagName(); 返回带有指定标签名的对象的集合： 12345678910111213141516&lt;body&gt; &lt;h3 name=&quot;p1&quot;&gt; ... &lt;/h3&gt; &lt;p name=&quot;p1&quot;&gt; ... &lt;/p&gt; &lt;p&gt; ... &lt;/p&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot; &gt; var c = document.getElementsByTagName(&quot;p&quot;); alert(c[1].nodeName);&lt;/script&gt; 提示： 参数值 &quot;*&quot; 返回文档的所有元素。 docyment.getElementsByClassName(); 返回文档中所有指定类名的元素集合。 2、增（1）创建节点 document.createElement(tagName) 通过指定名称创建一个元素，并返回该元素对象。 参数为必选项，String类型，内容为标签名称。 document.createTextNode() 创建一个文本节点，参数为文本内容。 （2）插入节点用上述两种方法只是创建了节点，还需将其插入到指定位置： document.appendChild() 向节点的子节点列表的末尾添加新的子节点。 fatherNode.insertBefore(newNode, ref) 在fatherNode结点的所有子结点中，将newNode节点插入到其子节点ref的前面。 实例演示： 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;test05&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; window.onload = function()&#123; a = document.getElementById(&#x27;ecy&#x27;); a.nodeValue = &quot;二齿缘&quot;; //alert(a.nodeValue); var b = document.getElementsByName(&quot;p1&quot;); //alert(b[1].nodeName); var newP = document.createElement(&quot;p&quot;); //创建新标签节点p var newText = document.createTextNode(&quot;新添加的节点&quot;); //创建新文本节点 newP.appendChild(newText); //文本节点插入到p中 var fatherNode = document.getElementsByTagName(&quot;body&quot;); var temp02 = document.getElementsByTagName(&quot;input&quot;); fatherNode[0].insertBefore(newP, temp02[0]); //插入 &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;hijfsbnjf&quot; id=&quot;bt01&quot; /&gt; &lt;h3 id=&quot;ecy&quot;&gt;二次元蒸鹅心&lt;/h3&gt; &lt;h3 name=&quot;p1&quot;&gt; ... &lt;/h3&gt; &lt;p name=&quot;p1&quot;&gt; ... &lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 插入前后： （3）复制节点要复制的节点.cloneNode(); 参数是布尔值，为true时表示深度复制——同时复制所有子节点，默认为false——仅复制单个节点，返回值为复制节点的引用。 克隆的节点不会包含任何事件监听器或用户自定义的数据属性，除非这些属性是直接在节点上设置的。 注：复制节点后网页并不会发生任何变化，要在网页上看到变化还需将其插入！ 3、删fatherNode.removeChild(oldChild) oldChild：要删除的节点。 删除后网页会立即产生变化！ 4、改（1）DOM模型中替换节点： fatherNode.replaceChild(new, old); 用new节点替换old节点。 （2）DHTML模型中 innerHTML: 用途：获取或设置一个元素内部的 HTML 内容，包括它的子元素和文本。 读取：返回元素的起始标签和结束标签之间的所有内容（不包含起始标签），以字符串形式。 设置：当你给 innerHTML 赋值时，它会替换掉元素内部的所有内容（包括子元素），并解析赋值的字符串作为HTML，创建新的 DOM 树。 12345// 读取var content = document.getElementById(&#x27;myElement&#x27;).innerHTML;// 修改document.getElementById(&#x27;myElement&#x27;).innerHTML = &#x27;&lt;p&gt;New content&lt;/p&gt;&#x27;; innerText: 用途：获取或设置一个元素内部的文本内容，不包括 HTML 标签。 读取：返回元素和它的子元素的文本内容。 设置：当你给 innerText 赋值时，它会替换掉元素内部的所有内容，并将赋值的字符串作为纯文本插入。 12345复制// 读取var text = document.getElementById(&#x27;myElement&#x27;).innerText;// 设置document.getElementById(&#x27;myElement&#x27;).innerText = &#x27;New text content&#x27;; outerHTML: 用途：获取或设置一个元素的整体 HTML 内容，包括元素自身的标签。 读取：返回整个元素的 HTML 表示，包括起始标签、结束标签以及它们之间的所有内容。 设置：在大多数浏览器中，outerHTML 不能被设置，因为它没有标准的定义，并且可能会引起安全问题。 12// 读取var html = document.getElementById(&#x27;myElement&#x27;).outerHTML; outerText: 用途：outerText 是一个非标准的属性，它在某些浏览器（如 IE）中可用，但在现代浏览器中并不推荐使用。 读取：与 outerHTML 类似，返回整个元素的 HTML 表示。 设置：与 innerText 类似，替换掉整个元素，并将其内部的字符串作为纯文本插入。 由于 outerText 是非标准的，所以在跨浏览器兼容性方面可能会有问题。在现代的网页开发实践中，推荐使用 outerHTML 来获取元素的 HTML 表示，而使用 innerText 来设置或获取元素的文本内容。 注意：在设置 innerHTML 或 innerText 时，需要小心，因为它们可以执行 HTML 或 JavaScript，这可能导致安全问题，如 XSS（跨站脚本攻击）。 四、Style对象 属性 说明 background 设置或检索对象最多5个独立的背景属性 backgroundColor 背景颜色 backgroundImage 背景图像 backgroundPosition 背景位置 backgroundPositionX backgroundPosition属性X的坐标 backgroundPositionY backgroundPosition属性Y的坐标 behavior DHTML行为的位置 border 边框 borderColor 边框颜色 borderStyle 上、下、左、右边框的样式 borderWidth 边框宽度 borderBottom, borderLeft, borderRight, borderTop 四边框属性 borderBottomColor, borderLeftColor, borderRightColor, borderTopColor 四边框颜色 borderBottomStyle, borderLeftStyle, borderRightStyle, borderTopStyle 四边框样式 borderBottomWidth, borderLeftWidth, borderRightWidth, borderTopWidth 四边框宽度 color 文本颜色 cursor 当鼠标指向对象时使用的形状 direction 文本方向 display 是否渲染在屏幕上，不会占据位置 font 设置或检索对象最多6个独立的字体属性 fontFamily 字体样式名称 fontSize 字体大小 fontStyle 字体样式，如斜体、常规或倾斜体 fontVariant 字体是否以小型大写字母显示 fontWeight 字体宽度 height 对象高度 width 对象宽度 left 对象相对于文档层次中下一个定位对象左边界的位置 right 对象相对于文档层次中下一个定位对象右边界的位置 top 对象相对于文档层次中下一个定位对象顶部的位置 bottom 对象相对于文档层次中下一个定位对象底部的位置 letterSpacing 字符间距（总和） lineHeight 两行间的距离 listStyle 列表属性（最多三个） listStyleImage 列表项目符号的图像 listStylePosition 列表项目符号的位置 listStyleType 列表项目符号的预定义类型 margin, marginLeft, marginRight, marginBottom, marginTop 外边距 padding, paddingLeft, paddingRight, paddingBottom, paddingTop 内边距 scrollbar3dLightColor 滚动条中滚动滑块和滚动按钮的左上颜色 scrollbarArrowColor 滚动条中滚动箭头标识的颜色 scrollbarBaseColor 滚动条中滚动按钮和滚动滑块的主要颜色 scrollbarDarkShadowColor 滑槽的颜色 scrollbarFaceColor 滚动条和滚动箭头的颜色 scrollbarHighlightColor 滚动框和滚动条滚动箭头的左上边缘颜色 scrollbarShadowColor 滚动框和滚动条滚动箭头的右下边缘颜色 scrollbarTrackColor 滚动条上轨迹元素的颜色 styleFloat 元素float布局 tableLayout 控制表格的行为和布局方式 textAlign 文字对齐方式（左中右、两端对齐） textDecoration 文本是否有闪烁、上中下划线 verticalAlign 对象的垂直排列 visibility 元素是否可见，仍然占据空间 whiteSpace 是否自动换行 wordBreak 是否拆分单词换行 wordSpacing 字符间距总量 wordWrap 内容超过容器边界时是否换行 zIndex 堆叠次序 zoom 放大比例","categories":[{"name":"前端","slug":"前端","permalink":"http://kouqiang.space/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://kouqiang.space/tags/%E7%BC%96%E7%A8%8B/"},{"name":"前端","slug":"前端","permalink":"http://kouqiang.space/tags/%E5%89%8D%E7%AB%AF/"},{"name":"js","slug":"js","permalink":"http://kouqiang.space/tags/js/"}],"author":"寇强"},{"title":"🎮饥荒MOD路径","slug":"🎮饥荒MOD路径","date":"2024-04-24T14:00:00.000Z","updated":"2024-05-13T09:30:12.603Z","comments":true,"path":"2024/04/24/🎮饥荒MOD路径/","link":"","permalink":"http://kouqiang.space/2024/04/24/%F0%9F%8E%AE%E9%A5%A5%E8%8D%92MOD%E8%B7%AF%E5%BE%84/","excerpt":"","text":"🎮饥荒MOD路径一、模组路径相关以steam安装的版本为例： 游戏MOD文件的存放路径：steam安装路径/steamapps/common/Don&#39;t Starve Together/mods/ 这里存储的就是玩家所有已下载到本地的原始模组文件。 steam安装路径/steamapps/common/Don&#39;t Starve Together/data/databundles/scripts.zip该文件是游戏在启动时加载的模组&#x2F;脚本文件的压缩包，我们可以将其解压到：Don&#39;t Starve Together/data/scrips，再将原始压缩包改名或删除，这样游戏加载时会加载解压文件夹内的内容，我们对其中脚本内容修改也会直接影响到游戏的实际运行，方便我们实时更改查看效果。 如果我们订阅的任意模组有更新，本地更新完成时仍然会生成Don&#39;t Starve Together/data/databundles/scripts.zip文件，此时我们需手动更新（重复以上步骤）否则我们的后续编辑不会生效！ **、组件等data/scrips/components/中存放着所有游戏组件代码！如pickable.lua就是采集组件。","categories":[{"name":"编程","slug":"编程","permalink":"http://kouqiang.space/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://kouqiang.space/tags/%E7%BC%96%E7%A8%8B/"},{"name":"游戏","slug":"游戏","permalink":"http://kouqiang.space/tags/%E6%B8%B8%E6%88%8F/"}],"author":"寇强"},{"title":"EasyX库相关","slug":"EasyX库相关","date":"2024-03-12T05:30:00.000Z","updated":"2024-03-12T07:35:14.899Z","comments":true,"path":"2024/03/12/EasyX库相关/","link":"","permalink":"http://kouqiang.space/2024/03/12/EasyX%E5%BA%93%E7%9B%B8%E5%85%B3/","excerpt":"","text":"EasyX库相关官网：EasyX Graphics Library for C++ 官方在线文档：EasyX 文档 - 基本说明 1.loadimage()和putimage()函数LoadImag()是EasyX库的一个函数，功能是装载图标、光标、或位图，支持bmp，jpg，gif，emf，wmf，ico格式。 123456789101112131415161718// 从图片文件获取图像void loadimage( IMAGE* pDstImg, // 保存图像的 IMAGE 对象指针 LPCTSTR pImgFile, // 图片文件名 int nWidth = 0, // 图片的拉伸宽度 int nHeight = 0, // 图片的拉伸高度 bool bResize = false // 是否调整 IMAGE 的大小以适应图片);// 从资源文件获取图像void loadimage( IMAGE* pDstImg, // 保存图像的 IMAGE 对象指针 LPCTSTR pResType, // 资源类型 LPCTSTR pResName, // 资源名称 int nWidth = 0, // 图片的拉伸宽度 int nHeight = 0, // 图片的拉伸高度 bool bResize = false // 是否调整 IMAGE 的大小以适应图片); putimage(int dstX, int dstY, const IMAGE, int ops)的作用是将一个先前保存在内存中的图像输出到屏幕上，前两个参数控制图像的x、y轴位置，第三个为图像的指针，第四个参数控制图像的输出方式但一般不设置： 1putimage(0, 0, &amp;imgBg); 2.initgraph()和closegraph()函数为了摆脱在C语言中控制台窗口那个难看的黑框框去写出五颜六色，赏心悦目的窗口，easyx图形库中是使用自己开辟的新窗口的，独立于控制台窗口。 初始化图形窗口： 1initgraph(int width, int height, int flag=0) width和height单位默认为像素； flag参数：绘图窗口的样式，默认为NULL可不填写，也可为以下值： 值 含义 EW_DBLCLKS 在绘图窗口中支持鼠标双击事件 EW_NOCLOSE 禁用绘图窗口的关闭按钮 EW_NOMINIMIZE 禁用绘图窗口的最小化按钮 EW_SHOWCONSOLE或1 同时显示控制台窗口 关闭窗口： 1closegraph()","categories":[{"name":"编程","slug":"编程","permalink":"http://kouqiang.space/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://kouqiang.space/tags/%E7%BC%96%E7%A8%8B/"},{"name":"C/C++","slug":"C-C","permalink":"http://kouqiang.space/tags/C-C/"},{"name":"UI","slug":"UI","permalink":"http://kouqiang.space/tags/UI/"}],"author":"寇强"},{"title":"C语言其他补充_pvz","slug":"C语言补充_pvz","date":"2024-03-06T10:30:00.000Z","updated":"2024-03-12T10:05:01.704Z","comments":true,"path":"2024/03/06/C语言补充_pvz/","link":"","permalink":"http://kouqiang.space/2024/03/06/C%E8%AF%AD%E8%A8%80%E8%A1%A5%E5%85%85_pvz/","excerpt":"","text":"C语言其他补充_pvz1.system(&quot;pause&quot;)函数在编写的c++程序中，如果是窗口，有时会一闪就消失了，如果不想让其消失，在程序中添加：system(&quot;pause&quot;); 分析：system()就是调用DOS系统命令（和shell命令）。 pause，即DOS命令集合中的暂停命令； 在一个程序中写有system(&quot;pause&quot;)语句时，就是说从该程序里调用了“pause”命令，即让操作系统来暂停该程序进程的执行，同时程序运行到此语句处，会在程序的窗口上显示Press any key to continue . . . 也就是 “按任意键继续…”，即等待用户按下任意一个按键使该程序从暂停状态返回到执行状态，继续从刚才暂停的地方开始执行。 2.c语言枚举类型enum的用法枚举enum就是英文enumerate的缩写，也就是列举、排列说明的意思。 枚举类型是C语言中的一种特殊类型，可以让我们的程序使用一些固定长度和固定数值的变量值范围。 定义枚举类型：enum 枚举类型名 &#123;枚举值列表&#125;; 详细介绍参考：C enum(枚举) | 菜鸟教程 (runoob.com) 3.sprintf()函数C标准库函数，作用：向指定字符串发送&#x2F;写入自定义内容： 1int sprintf(目标字符串引用, &quot;写入内容&quot;); 4.fopen()和fclose()（1）fopen()C 库函数FILE* fopen(const char *filename, const char *mode)使用给定的模式mode打开filename所指向的文件。 参数 filename：字符串，表示要打开的文件路径及名称。 mode：字符串，表示文件的访问模式，可以是以下表格中的值： 参数 描述 r 打开一个用于读取的文件。该文件必须存在。 w 创建一个用于写入的空文件。如果文件名称与已存在的文件相同，则会删除已有文件的内容，文件被视为一个新的空文件。 a 追加到一个文件。写操作向文件末尾追加数据。如果文件不存在，则创建文件。 r+ 打开一个用于更新的文件，可读取也可写入。该文件必须存在。 w+ 创建一个用于读写的空文件。 a+ 打开一个用于读取和追加的文件。 该函数返回一个FILE指针。打开文件失败则返回NULL，且设置全局变量errno来标识错误。 （2）fclose()C 库函数int fclose(FILE *stream)关闭流 stream。刷新所有的缓冲区。 如果流成功关闭，则该方法返回零。如果失败，则返回 EOF。 下面的实例演示了这俩函数的用法： 1234567891011121314#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; int main()&#123; FILE * fp; fp = fopen (&quot;./file.txt&quot;, &quot;w+&quot;); fprintf(fp, &quot;%s %s %s %d&quot;, &quot;We&quot;, &quot;are&quot;, &quot;in&quot;, 2014); fclose(fp); return(0);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://kouqiang.space/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://kouqiang.space/tags/%E7%BC%96%E7%A8%8B/"},{"name":"C语言","slug":"C语言","permalink":"http://kouqiang.space/tags/C%E8%AF%AD%E8%A8%80/"}],"author":"寇强"},{"title":"Lua语言入门01","slug":"Lua语言入门01","date":"2023-12-30T03:30:00.000Z","updated":"2024-04-23T13:05:21.366Z","comments":true,"path":"2023/12/30/Lua语言入门01/","link":"","permalink":"http://kouqiang.space/2023/12/30/Lua%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A801/","excerpt":"","text":"Lua语言入门01参考文档：博客园：Lua &#x3D;&#x3D;&#x3D;&gt; Lua 十分钟基础入门上手 一、Lua简介Lua维基百科 Lua的目标是成为一个很容易嵌入到其他语言中使用的语言； 很多程序员使用Lua作为自己的嵌入式脚本语言，实现可配置性，可扩展性； 轻量级语言，体积小速度启动快，只包含一个精简的核心和基本的库； Lua很容易的被扩展，由宿主语言提供网络通讯，图形界面等功能； Lua是一个动态弱类型语言，支持增量式垃圾收集策略。有内建的，与操作系统无关的协作式多线程（coroutine）支持； 我们可以用其特有的表结构（Lua唯一提供的复杂数据结构）轻易模拟继承、命名空间、类等概念的实现； Lua原生支援的数据类型非常之少，它只提供了数字（缺省是双精度浮点数，可配置）、布尔量、字符串、表、子程序、协程（coroutine）以及用户自定义数据这几种。但是其处理表和字符串的效率非常之高，加上元表的支援，我们可以高效的模拟出需要的复杂数据类型（比如集合、数组等）。 二、语法基础在Lua中，一切都是变量，除了关键字！ 注释 123456--单行注释用两个减号标记--[[多行注释：用减号和两个方括号]] 语句分隔 语句之间可以用半角分号;表示结束，也可以用空白分隔！如： 1print(&quot;Hallo world!&quot;) 语句块 语句块在多数语言中是用&#123;和&#125;括起来的，在Lua中，它是用do和end括起来的。比如： 1do print(&quot;Hello&quot;) end 你可以在 函数中和语句块中定义局部变量。 条件控制语句 可以用break终止循环； 循环条件不用括号括起来； if else循环 1234567891011if (条件) then ...endif 条件 then ...else if 条件 then ...else ... ...end while循环 123while 条件 do ...end repeat循环 123repeat ...until 条件 for循环 1234567for 变量=初值,终点值,步进值 do ...endfor 变量1, 变量2, ..., 变量n, in表或枚举函数 do ...end 循环体内的变量也是局部变量； 步进值若省略则自动使用默认值1； 赋值语句 定义一个变量的方法就是赋值，＝操作符就是用来赋值的，在Lua中赋值语句更方便： 123a,b,c = 1,2,3 --相当于a=1 b=2 c=3a,b = b,a --交换ab的值 当变量个数和值的个数不一致时，Lua会一直以变量个数为基础采取以下策略： a. 变量个数 &gt; 值的个数 –按变量个数补足nil b. 变量个数 &lt; 值的个数 –多余的值会被忽略 如： 1234567a, b, c = 1, 2print(a, b, c)&gt;1 2 nila, b = 4, 5, 6, 7print(a,b)&gt;4 5 Lua语言的函数返回值可以不止一个，因此可以用函数给多个变量赋值： 1a, b, c = function01() --function01()函数返回三个值依次赋给abc 数值运算符 和C语言一样，支持+，-，*，/，此外还有整除运算符//（Lua版本&gt;&#x3D;5.3）。 在Lua中，/运算是会包含小数部分的，//才能整除。 但Lua还多了一个^，这表示指数乘方运算。比如2^3结果为8，2^4结果为16。 连接两个字符串，可以用”..”运处符。如： 1&quot;This a &quot; .. &quot;string.&quot; --结果为：&quot;This a string.&quot; 比较运算符 &lt;小于，&gt;大于，&lt;=不大于，&gt;=不小于，==相等，~=不相等，这些操作符的运算结果只有true或false。 对于Table、Function和Userdata类型的数据，只能进行==和~=，二者都判断引用的是否是同一份数据，如： 123a=&#123;1,2&#125;; b=a; c=&#123;1,2&#125;print(a==b, a~=b) --true, falseprint(a==c, a~=c) --false, true 逻辑运算：and、or、not 注：在Lua中，只有false和nil才计算为false，其它任何数据都计算为true，0和空串也是true！ a and b：如果a为false，则返回a，否则返回b； a or b：如果a为true，则返回a，否则返回b； not取反，相当于!，!条件，条件为真返回假，条件为假返回真。 123456789print(4 and 5) --5print(nil and 13) --nilprint(false and nil) --falseprint(4 or 5) --4print(false or 12) --12--[[我们可以模拟C语言中的语句：x = a? b : c，在Lua中，可以写成：x = a and b or c。 最有用的语句是： x = x or v，它相当于：if not x then x = v end 。 ]] 运算符优先级 运算符优先级，从高到低顺序如下： ^not、- （一元运算）*、/ +、- ..&lt;、&gt;、&lt;=、&gt;=、~=、== and or 关键字 关键字是不能做为变量的。Lua的关键字不多，就以下几个： 1and break do else elseif end false for function if in local nil not or repeat return then true until while 三、数据类型 在Lua中，不管你在什么地方使用变量，都不需要声明，并且所有的这些变量总是全局变量，除非，你在变量名前加上local。 变量名字大小写相关，如Abb和abb是两个不同的变量。 可以用type()函数来检查变量是什么类型，该函数返回的是类型名称的字符串。 1、Nil类型nil类型表示一种没有任何有效值，它只有一个值nil，如果打印一个没有赋值的变量，便会输出一个nil值。 换句话说，当且仅当一个变量不等于nil时，这个变量即存在。 对于全局变量和table，nil还有一个“删除作用”，给全局变量或者table表里的变量赋一个nil值，等同于把它们删掉。 1var1 = nil 2、Boolean类型布尔值。在Lua中，只有false和nil才计算为false，其它任何数据都计算为true，0和空串也是true！ 1var2 = true 3、Number类型数值型，在Lua里，数值相当于C语言的double，且没有整数类型。 一般情况下，只要数值不是很大（比如不超过100,000,000,000,000），是不会产生舍入误差的。 1var3, var4 = 10, 3.14 5、String类型字符串。字符串在Lua中有几种方法来表示，可以用双引号或单引号来括起一个字符串，如： 12&#x27;This is a string.&#x27;&quot;This is Lua!&quot; 如果要保持原来的空白和换行，则需要用两个方括号括起来： 1234567javacode = [[public class Test&#123; public static void main(Str Args[])&#123; System.out.println(&quot;Hello world!&quot;); &#125;&#125;]] 使用 # 来计算字符串的长度，放在字符串前面，如下实例： 12345len = &quot;www.runoob.com&quot;print(#len)&gt; 14print(#&quot;www.runoob.com&quot;)&gt; 14 也可使用string.len()和utf8.len()函数获取字符串的长度，返回值为Number类型的数字。前者只用于计算包含ASCII字符串的长度，后者可以计算包含中文的字符串。如： 123local myStr01 = &quot;昨夜闲潭梦落fa&quot;print(utf8.len(myStr01))&gt; 14 类型转换：Lua会根据上下文在合理合法的情况下隐式进行数字和字符之间的转换。 另外，也可以使用tonumber()函数和tostring()函数手动控制字符与数字的转换： 123456789a = 666 b = &#x27;23163&#x27;print(a + 100)&gt; 766print(a + b)&gt; 23829print(tonumber(&quot;bbc&quot;))&gt; 报错！tonumber()的参数的每个字符必须都是数字！print(a + tonumber(&#x27;23163&#x27;))&gt; 23829 6、Table类型后面详细说。 table是 Lua 的一种数据结构用来帮助我们创建不同的数据类型，如：数组、字典等。 Lua table 使用关联型数组，你可以用任意类型的值来作数组的索引，但这个值不能是nil。 Lua table 是不固定大小的，你可以根据自己需要进行扩容。 Lua也是通过table来解决模块（module）、包（package）和对象（Object）的。 例如string.format表示使用format来索引table string。 7、Function类型函数类型，函数也是一种类型，也就是说，所有的函数，它本身就是一个变量。 在Lua中，函数是被看作是”第一类值（First-Class Value）”，函数可以存在变量里。 8、Userdata类型userdata是一种用户自定义数据，用于表示一种由应用程序或C&#x2F;C++语言库所创建的类型，可以将任意C&#x2F;C++的任意数据类型的数据（通常是 struct 和 指针）存储到 Lua 变量中调用。 9、Thread类型线程类型，在Lua中没有真正的线程。Lua中可以将一个函数分成几部分运行。 在 Lua 里，最主要的线程是协同程序（coroutine）。它跟线程（thread）差不多，拥有自己独立的栈、局部变量和指令指针，可以跟其他协同程序共享全局变量和其他大部分东西。 线程跟协程的区别：线程可以同时多个运行，而协程任意时刻只能运行一个，并且处于运行状态的协程只有被挂起（suspend）时才会暂停。 四、函数1、函数的定义上文提到，Lua中函数也是一种变量，所以定义函数要用关键字function： 1234function suma_b() ... return ...end 2、可变参数Lua函数可以接受可变数目的参数，和C语言类似，在函数参数列表中使用三点...表示函数有可变的参数。 123function func01(...) ...end","categories":[{"name":"编程","slug":"编程","permalink":"http://kouqiang.space/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://kouqiang.space/tags/%E7%BC%96%E7%A8%8B/"},{"name":"Lua","slug":"Lua","permalink":"http://kouqiang.space/tags/Lua/"}],"author":"寇强"},{"title":"HTML图像热区链接","slug":"HTML图像热区链接","date":"2023-12-19T11:55:00.000Z","updated":"2023-12-19T12:59:11.462Z","comments":true,"path":"2023/12/19/HTML图像热区链接/","link":"","permalink":"http://kouqiang.space/2023/12/19/HTML%E5%9B%BE%E5%83%8F%E7%83%AD%E5%8C%BA%E9%93%BE%E6%8E%A5/","excerpt":"","text":"HTML图像热区链接🎨图像热区链接 说明：对一张图片设置自定义形状区域链接到不同地址。 使用到的标签：&lt;img /&gt;、&lt;map&gt;&lt;/map&gt;、&lt;area /&gt; 使用方法： 先对目标图像标签设置usemap属性，属性值为井号#加自定义map名称： 1&lt;img src=&quot;...&quot; usemap=&quot;#map01&quot;/&gt; 给HTML文档中添加&lt;map&gt;&lt;/map&gt;标签，标签添加name属性，属性值为上面自定义的map名称，此处不加井号： 12&lt;img src=&quot;...&quot; usemap=&quot;#map01&quot;/&gt;&lt;map name=&quot;map01&quot;&gt;&lt;/map&gt; 注：该标签在源码中的位置任意，只要在&lt;html&gt;&lt;/html&gt;标签内部一般都能生效，但为了代码可读，建议与目标图片放在一起！ &lt;map&gt;&lt;/map&gt;标签内添加多个自定义的形状标签&lt;area&gt;，该标签有以下属性： shape属性： 定义链接热区的形状，有以下值可选： circle：设定区域为圆形； tect：设定区域为矩形； poly：设定区域为多边形； default：设定区域为整张图片。 coords属性： 用于定义热区的位置和大小，结合shape属性匹配设定： 对于圆形区域来说，该属性包含三个参数，分别为圆心的x、y坐标、圆的半径，如： 123&lt;map name=&quot;map01&quot;&gt; &lt;area shape=&quot;circle&quot; coords=&quot;50,50,10&quot;/&gt;&lt;/map&gt; 对于矩形区域来说，该属性包含四个参数，分别为x1、y1、x2、y2，代表矩形左上和右下顶点的坐标，如： 123&lt;map name=&quot;map01&quot;&gt; &lt;area shape=&quot;rect&quot; coords=&quot;10,10,50,50&quot;/&gt;&lt;/map&gt; 对于多边形区域来说，该属性可包含多个参数，分别为各顶点的x、y坐标，如： 123&lt;map name=&quot;map01&quot;&gt; &lt;area shape=&quot;poly&quot; coords=&quot;0,0,10,0,30,30,20,40,0,10&quot;/&gt;&lt;/map&gt; 若shape值为default，那么coords属性不会生效。 最后，给各个area标签添加必要的href、target等属性即可，如： 123456&lt;img src=&quot;&quot; totle=&quot;&quot; alt=&quot;&quot; usemap=&quot;#map01&quot;/&gt;&lt;map name=&quot;map01&quot;&gt; &lt;area shape=&quot;rect&quot; coords=&quot;10,10,50,50&quot; href=&quot;&quot; title=&quot;&quot; target=&quot;&quot;/&gt; &lt;area shape=&quot;circle&quot; coords=&quot;50,50,10&quot; href=&quot;&quot; title=&quot;&quot; target=&quot;&quot;/&gt; &lt;area shape=&quot;poly&quot; coords=&quot;0,0,10,0,30,30,20,40,0,10&quot; href=&quot;&quot; title=&quot;&quot; target=&quot;&quot;/&gt;&lt;/map&gt; 补充说明： 同时设置了defaul和形状的话，形状以外才是defaul的生效区域！ 以此可以实现依次点击图片中的物体进行人机验证、图片找茬等功能。","categories":[{"name":"前端","slug":"前端","permalink":"http://kouqiang.space/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://kouqiang.space/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Html","slug":"Html","permalink":"http://kouqiang.space/tags/Html/"}],"author":"寇强"},{"title":"HTML5多媒体","slug":"HTML5多媒体","date":"2023-12-18T11:00:00.000Z","updated":"2024-05-13T09:41:14.675Z","comments":true,"path":"2023/12/18/HTML5多媒体/","link":"","permalink":"http://kouqiang.space/2023/12/18/HTML5%E5%A4%9A%E5%AA%92%E4%BD%93/","excerpt":"","text":"HTML5多媒体一、概述在HTML5之前要在网页加入视频，必须使用object和embed元素并为其添加许多属性和参数，而且需要Flash插件。 而在HTML5中新增了&lt;video&gt;&lt;/video&gt;与&lt;audio&gt;&lt;/audio&gt;元素专门用于播放视频和音频。 1234567&lt;audio src=&quot;&quot; autoplay=&quot;autoplay&quot; preload=&quot;preload&quot; loop=&quot;loop&quot;&gt; 此处内容为不支持audio元素的页面显示的[替代文字]&lt;/audio&gt;&lt;video src=&quot;&quot;&gt; 此处内容为不支持video元素的页面显示的[替代文字]&lt;/video&gt; 二、基本属性和详细使用方法二者属性大致相同。 （一）常用基本属性 controls=&quot;&quot;属性设置播放控制条的显示，值为空或任意字段都会生效，样式为浏览器预设样式。 如果不添加该属性那么页面上将不显示任何内容，所以一般是必备属性，除非使用自定义控制条。 width和height属性是video标签独有的，设置播放视频界面的宽和高，单位默认为像素可省略，值为空或非法值或auto时以poster的实际尺寸（优先）或视频实际尺寸显示。 src属性设置音视频文件的URL地址。 autoplay属性值为空或任意字段都会生效，用于设置该媒体是否在页面加载完成后自动播放。 preload属性指定媒体文件是否预加载： none：不进行预加载。 metadata：只预加载媒体的元数据（媒体字节数、第一帧、播放列表、持续数间等）。 auto：全部预加载。 loop属性指定是否循环播放，属性值为空或任意字段都会生效。 poster属性用于指定视频加载中、加载失败或未点击播放时显示的图像。 1234567&lt;audio src=&quot;media/杀死那个石家庄人.mp3&quot; preload=&quot;auto&quot; loop=&quot;&quot; controls=&quot;&quot; poster=&quot;./img/moon01.png&quot;&gt; 此处内容为不支持audio元素的页面显示的替代文字&lt;/audio&gt;&lt;video src=&quot;media/VID_20231105_124116.mp4&quot; preload=&quot;auto&quot; controls=&quot;&quot; poster=&quot;./img/moon01.png&quot; wid=&quot;&quot; height=&quot;&quot;&gt; 此处内容为不支持video元素的页面显示的替代文字&lt;/video&gt; 三、上手1、音乐播放器2、视频播放器","categories":[{"name":"前端","slug":"前端","permalink":"http://kouqiang.space/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://kouqiang.space/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Html","slug":"Html","permalink":"http://kouqiang.space/tags/Html/"}],"author":"寇强"},{"title":"🎈C++基础语法","slug":"C++快速入门","date":"2023-10-01T09:20:00.000Z","updated":"2023-10-01T15:08:50.399Z","comments":true,"path":"2023/10/01/C++快速入门/","link":"","permalink":"http://kouqiang.space/2023/10/01/C++%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/","excerpt":"","text":"🎈C++基础语法一、基本相关概念 C++有个很强的优势，就是针对不同的对象去做实例化，这就是所谓的OO思想。 对象有两个要素：属性和行为。 OO思想的特点： 封装：封装意味着把对象的属性和方法结合成一个独立的系统单位，并尽可能隐藏对泉的内部细节。 抽象：抽象的过程是对具体问题进行概括的过程，是对一类公共问题进行统一描述的过程。为了使某些必要的信息得以顺利的交流，设计者必须制定一个抽象，就如同一个协议，一个得到所有参与活动的有效个体支持的协议。 继承：子类对象拥有与其基类相同的全部属性和方法，称为继承。 多态：多态是指在基类中定义的属性和行为被子类继承后，可以具有不同的数据类型或者表现行为等特性。 二、基础上手知识（0）基本语法知识（一）基本数据类型（二）常见函数1、输入输出 输入和输出并不是C++语言中的正式组成成分。C和C++本身都没有为输入和输出提供专门的语句结构。输入输出不是由C++本身定义的，而是在编译系统提供的I&#x2F;O库中定义的。 C++的输出和输入是用“流”(stream)的方式实现的。 在定义流对象时，系统会在内存中开辟一段缓冲区，用来暂存输入输出流的数据。在执行cout语句时，先把插入的数据顺序存放在输出缓冲区中，直到输出缓冲区满或遇到cout语句中的endl（或\\n，ends，flush）为止，此时将缓冲区中已有的数据一起输出，并清空缓冲区。输出流中的数据在系统默认的设备（一般为显示器）输出。 有关流对象cin、cout和流运算符的定义等信息是存放在C++的输入输出流库中的，因此如果在程序中使用cin、cout和流运算符，就必须使用预处理命令把头文件stream包含到本文件中：#include &lt;iostream&gt;。 尽管cin和cout不是C++本身提供的语句，但是在不致混淆的情况下，为了叙述方便,常常把由cin和流提取运算符&gt;&gt;实现输入的语句称为输入语句或cin语句,把由cout和流插入运算符&lt;&lt;实现输出的语句称为输出语句或cout语句。 12345678910#include &lt;iostream&gt;using namespace std;int main()&#123; int a; std::cin &gt;&gt; a; cout &lt;&lt; &quot;输出内容：&quot; &lt;&lt; a &lt;&lt; ‘\\n’; return 0;&#125; cin&gt;&gt; 1234cin&gt;&gt;变量1&gt;&gt;变量2&gt;&gt;……&gt;&gt;变量n;//如：int a,b,c;cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; cout&lt;&lt; 123456cout&lt;&lt;表达式1&lt;&lt;表达式2&lt;&lt;……&lt;&lt;表达式n;//如：cout&lt;&lt;a,b,c; //错误，不能一次插入多项cout&lt;&lt;a+b+c; //正确，这是一个表达式cout &lt;&lt; &quot;输出内容：&quot; &lt;&lt;&#x27;\\n&#x27; &lt;&lt; a; 换行： &#39;\\n&#39;、&quot;\\n&quot;和endl都可以起到换行的作用，但是有细微的差别。 1234//以下三条语句输出的结果是一样的：cin&gt;&gt;a&gt;&gt;&#x27;\\n&#x27;&gt;&gt;c;cin&gt;&gt;a&gt;&gt;&quot;\\n&quot;&gt;&gt;c;cin&gt;&gt;a&gt;&gt;endl&gt;&gt;c; endl 换行并刷新缓冲区，相当于&#39;\\n&#39;+flush。 using namespace std的作用： 命名空间，有了这条语句在使用cin和cout时前面可不用加::符号。","categories":[{"name":"编程","slug":"编程","permalink":"http://kouqiang.space/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://kouqiang.space/tags/C/"},{"name":"编程","slug":"编程","permalink":"http://kouqiang.space/tags/%E7%BC%96%E7%A8%8B/"}],"author":"寇强"},{"title":"C语言生成伪随机数","slug":"C语言生成随机数","date":"2023-09-19T09:15:00.000Z","updated":"2023-09-19T09:25:09.725Z","comments":true,"path":"2023/09/19/C语言生成随机数/","link":"","permalink":"http://kouqiang.space/2023/09/19/C%E8%AF%AD%E8%A8%80%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0/","excerpt":"","text":"C语言生成伪随机数： 头文件加入： 12#include &lt;stdlib.h&gt;#include &lt;time.h&gt; 添加这段代码： 1srand((unsigned int)time(0)); 然后就可以调用这段代码生成随机数了： 12345rand();//直接调用即可，如：int a = rand();A[i] = rand(); 实际使用： 123456789101112131415#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;int main()&#123; int A[10]; srand((unsigned int)time(0)); printf(&quot;这是给A[]随机赋的值：\\n&quot;); for(int i=0; i&lt;10; i++)&#123; //直接调用即可 A[i]=rand(); printf(&quot;第%d次：%d\\n&quot;, i+1, A[i]); &#125; return 0;&#125; 运行结果：","categories":[{"name":"编程","slug":"编程","permalink":"http://kouqiang.space/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://kouqiang.space/tags/%E7%BC%96%E7%A8%8B/"},{"name":"C语言","slug":"C语言","permalink":"http://kouqiang.space/tags/C%E8%AF%AD%E8%A8%80/"}],"author":"寇强"},{"title":"🔑数据结构_第八章：排序","slug":"🔑数据结构_第八章：排序","date":"2023-09-16T09:30:00.000Z","updated":"2024-05-13T09:26:17.684Z","comments":true,"path":"2023/09/16/🔑数据结构_第八章：排序/","link":"","permalink":"http://kouqiang.space/2023/09/16/%F0%9F%94%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E7%AC%AC%E5%85%AB%E7%AB%A0%EF%BC%9A%E6%8E%92%E5%BA%8F/","excerpt":"","text":"🔑数据结构_第八章：排序一、排序的概念排序Sort，就是重新排列表中的元素，使表中的元素满足按关键字有序的过程。 输入：$n$个记录$R_1,R_2,…，R_n$，对应关键字为$k_1,k_2,…,k_n$。 输出：输出序列的一个重排$R_1^{‘},R_2^{‘},…,R_n^{‘}$，使得有$K_1^{‘} \\le K_2^{‘} \\le … \\le K_n^{‘}$(也可以递减)。 排序算法的评价指标： 时间复杂度 空间复杂度 稳定性： 若待排序表中有两个元素$R_i$和$R_j$，其对应的关键字相等——即$key_i&#x3D; key_j$，且在排序前$R_i$在$R_j$的前面，若使用某一排序算法排序后，$R_i$仍然在$R_j$的前面，则称这个排序算法是稳定的，否则称排序算法是不稳定的。 问：稳定的排序算法一定要比不稳定的好吗？ 答：不一定！看实际业务需求！ 排序算法的分类： 内部排序：数据都在内存中，主要关注时间复杂度和空间复杂度。 外部排序：数据太多，无法全部放入内存，不仅要关注时间空间复杂度，还要关注如何使读写磁盘的次数更少！ 数据结构算法可视化网站：Data Structure Visualizations 二、插入排序直接插入排序、折半插入排序、希尔排序 （一）直接插入排序 1234567891011121314151617181920212223242526//直接插入排序——王道咸鱼//传入数组A[i]和数组长度nvoid InsertSort(int A[], int n)&#123; int i, j, temp; for(i=1; i&lt;n; i++)&#123; //将各元素插入已排好序的序列中 if(A[i] &lt; A[i-1])&#123; //若A[i]关键字小于前驱 temp=A[i]; //用temp暂存A[i] for(j=i-1; j&gt;=0 &amp;&amp; A[j]&gt;temp; i--) //检查所有前面已排好序的元素 A[j+1]=A[j]; //所有大于temp的元素都向后挪 A[j+1]=tepm; //复制到插入位置 &#125; &#125;&#125;//直接插入排序——王道教材void InsertSort(int A[], int n)&#123; int i, j; for(i=2; i&lt;=n; i++)&#123; if(A[i]&lt;A[i-1])&#123; A[0]=A[i]; for(j=i-1; A[0]&lt;A[j]; j--) A[j+1]=A[j]; A[j+1]=A[0]; &#125; &#125;&#125; 性能评估： 空间复杂度：$O(1)$； 时间复杂度：$O(n^2)$： 主要来自于对比关键字、移动元素，若有$n$个元素，则需要$n-1$躺处理。 最好情况：$O(n)$； 最坏：原本为逆序——$O(n^2)$。 稳定性：稳定。 （二）折半插入排序：因为已排好序的部分肯定是有序的，所以可以将查找插入位置的部分换成折半查找的方式。 当low&gt;high 时折半查找停止，应将[low, high]区间内的元素全部右移，再将temp复制到low所指位置。 而如果要保持算法稳定性，当A[mid]=temp时，应继续在mid所指位置右边寻找插入位置。 123456789101112131415161718//折半插入排序void InsertSort(int A[], int n)&#123; int i, j, low, high, mid; for(i=2; i&lt;=n; i++)&#123; //依次将A[2]~A[n]插入前面的已排序序列 A[0]=A[i]; //将A[i]暂存到A[0] low=1; high=i-1; //设置折半查找的范围 while(low&lt;=high)&#123; //折半查找（默认递增有序） mid=(low+high)/2; //取中间点 if(A[mid]&gt;A[0]) //查找左半子表 high=mid-1; else //查找右半子表 low=mid+1; &#125; for(j=i-1; j&gt;=high+1; j--) A[j+1]=A[j]; //统一后移元素，空出插入位置 A[high+1]=A[0]; //插入操作 &#125;&#125; 折半插入排序只能用于顺序表，链表就用不了！ 若将插入排序应用于链表，那么排序过程中只需更改指针而不用挪动元素，但是关键字的对比次数仍然是O(n2)数量级，整体看起来时间复杂度仍然是$O(n^2)$。 （三）希尔排序ShellSort1、算法逻辑希尔排序：先将待排序表分割成若干形如$L[i,i+ d,i+ 2d,..,i+ kd$的“特殊”子表，对各个子表分别进行直接插入排序。 缩小增量$d$，重复上述过程，直到$d&#x3D;1$为止。 演示1： 演示2： 2、代码实现1234567891011121314void ShellSort(int A[], int n)&#123; int i, j, d; //A[0]只是暂存单元不是哨兵，当j&lt;=0时，插入位置已到 for(d=n/2; d&gt;=1; d=d/2)&#123; //步长变化 for(i=d+1; i&lt;=n; i++)&#123; if(A[i]&lt;A[i-d])&#123; //需将A[i]插入有序增量子表 A[0]=A[i]; for(j=i-d; j&gt;0 &amp;&amp; A[0]&lt;A[j]; j-=d) A[j+d]=A[j]; //记录后移，查找插入的位置 A[j+d]=A[0]; //插入 &#125; &#125; &#125;&#125; 3、性能分析 空间复杂度：$O(1)$； 时间复杂度： 目前无法用数学手段证明确切的时间复杂度。 最坏时间复杂度为$O(n^2)$，当$n$在某个范围内时，可达$O(n^{1.3})$。 稳定性： 不稳定！ 适用性： 只适用于顺序表，不适用于链表。 总结： 三、冒泡排序和快排序（一）冒泡排序 1、概念从后往前(或从前往后)两两比较相邻元素的值，若为逆序——即$A[i-1]&gt;A[i]$——则交换它们，直到序列比较完。 称这样过程为“一趟”冒泡排序。 2、代码王道咸鱼学长： 12345678910111213141516171819202122//交换函数void swap(int &amp;a, int &amp;b)&#123; int temp=a; a=b; b=temp;&#125;//冒泡排序——从后往前升序排序void BubbleSort(int A[], int n)&#123; for(int i=0; i&lt;n-1; i++)&#123; bool flag=false; //表示本躺冒泡是否发生交换的标志 for(int j=n-1; j&gt;i; j--)&#123; //一趟冒泡过程 //若为逆序则交换 if(A[j-1]&gt;A[j])&#123; swap(A[j-1], A[j]); flag=true; &#125; &#125; if(flag==false) //本躺遍历没有发生交换，说明表已经有序 return; &#125;&#125; 我自己手撸（从前往后遍历升序排序）： 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;//交换两个数void swap(int &amp;a, int &amp;b)&#123; int temp; temp=a; a=b; b=temp;&#125;//冒泡排序——从前往后遍历升序排序void BubbleSort(int A[], int n)&#123; for(int i=0; i&lt;n-1; i++)&#123; for(int j=i+1; j&lt;n; j++)&#123; if(A[j]&lt;A[i]) swap(A[j], A[i]); &#125; &#125;&#125;int main()&#123; int A[10]; srand((unsigned int)time(0)); printf(&quot;这是A[]的值：\\n&quot;); for(int i=0; i&lt;10; i++)&#123; A[i]=rand(); printf(&quot;第%d次：%d\\n&quot;, i+1, A[i]); //int a = rand(); //printf(&quot;%d\\n&quot;, a); &#125; BubbleSort(A, 10); printf(&quot;\\n冒泡排序结果：\\n&quot;); for(int i=0; i&lt;10; i++)&#123; printf(&quot;第%d个数：%d\\n&quot;, i+1, A[i]); &#125; return 0;&#125; 运行结果： 3、性能评估 稳定性：稳定 时间复杂度： 最好（有序）：$O(n)$； 最坏（倒序）：$O(n^2)$； 平均：$O(n^2)$. 空间复杂度：$O(1)$. 可以应用于链表！ 每次执行交换swap()需要执行三次交换！ 需注意每次循环开始前检查是否已排好序，如果是直接结束！（上文中王道11、19、20行代码） （二）快速排序 1、算法逻辑算法思想： 在待排序表$L[1…n]$中任取一个元素pivot作为枢轴（或基准，通常取首元素），通过一趟排序将待排序表划分为独立的两部分$L[1…k-1]$和$L[k+1…n]$，使得$L[1…k-1]$中的所有元素小于pivot，$L[k+1…n]$中的所有元素大于等于pivot，则pivot放在了其最终位置$L(k)$上，这个过程称为一次“划分”。 然后分别递归地对两个子表重复上述过程，直至每部分内只有一个元素或空为止，即所有元素放在了其最终位置上。 2、代码实现1234567891011121314151617181920212223242526272829//对表进行划分/** 该方法用第一个元素的值pivot作为枢纽将待排序序列划分成左右两个子表：* 左子表的全部元素都小于pivot，右子表的全部元素都大于pivot；* 然后对其左右子表再各自递归进行该操作，直至每个子表中只含有一个元素时，整个序列就排好序了。*/int Partition(int A[], int low, int high)&#123; int pivot=A[low]; //第一个元素作为枢纽 //用low、high搜索枢纽的最终位置，low向右移，high向左移，直至二者重合 while(low&lt;high)&#123; while(low&lt;high &amp;&amp; A[high]&gt;=pivot) high--; A[low]=A[high]; //比枢纽小的元素移动到左端 while(low&lt;high &amp;&amp; A[low]&lt;=pivot) low++; A[high]=A[low]; //比枢纽大的元素移动到右端 &#125; A[low]=pivot; //low、high重合，枢纽元素存放到最终位置 return low; //返回存放枢纽的最终位置&#125;//快速排序void QuickSort(int A[], int low, int high)&#123; if(low&lt;high)&#123; //跳出递归的条件——当递归最内层的子表中只剩一个元素（即low=high）时说明整个序列排序完成 int pivotpos=Partition(A,low,high); //划分 QuickSort(A,low,pivotpos-1); //划分左子表 QuickSort(A,pivotpos+1,high); //划分右子表 &#125;&#125; 3、性能评估可以将其看作n个结点的二叉树：最小高度为$[log2n]+1$，最大高度为$n$。 时间复杂度： 受递归层数影响： 最好：$O(nlog_2n)$（每次选的枢轴元素都能将序列划分成均匀的两部分）。 最坏：$O(n^2)$（若序列原本就有序或逆序，则时空复杂度最高（可优化，尽量选择可以把数据中分的枢轴元素））。 ❗平均时间复杂度：$O(nlog_2n)$（实际情况中更接近最好情况）。 空间复杂度： 也受递归层数影响： 最好：$O(log_2n)$. 最坏：$O(n)$. 稳定性：不稳定！ 快速排序是所有内部排序算法中平均性能最优的排序算法！ 四、直接选择排序和堆排序（一）简单选择排序 1、算法思想选择排序：每一趟在待排序元素中选取关键字最小(或最大)的元素加入有序子序列。 2、代码实现 123456789101112//快速排序void SelectSort(int A[], int n)&#123; for(int i=0; i&lt;n-1; i++)&#123; //一共进行n-1躺 int min=A[i]; //记录最小元素值 for(int j=i+1; j&lt;n; j++)&#123; //在[i+1,n-1]范围内寻找最小值（n为元素个数而不是数组下标） if(A[j]&lt;min) min=A[j]; //更新最小元素值 &#125; if(A[i]!=min) //若第一个元素不是最小值则交换位置，否则不做处理 swap(A[i], min); &#125;&#125; 3、性能评估 时间复杂度：$O(n^2)$. 无论有序、逆序还是乱序都要进行n-1躺处理。 空间复杂度：$O(1)$. 稳定性：不稳定。 适用性：顺序表和链表都适用。 （二）堆排序1、相关概念与算法思想（1）数据结构——“堆” 大根堆：根结点$\\ge$左右子树的完全二叉树； 小根堆：根结点$\\le$左右子树的完全二叉树； （2）算法思想*注：以下是升序排序为例： 先将待排序序列改造成大根堆，这样子对应完全二叉树（以下称为“树”）的根结点就是整个序列中最大的那一个； 然后将根结点和最后一个叶子结点交换，此时整个序列中最后一个元素就是排序好了的； 再把除去最后一个已排好序的结点的子树重新改造为大根堆； 循环2、3步骤，直至只剩最后一个根节点未排序，那么此时整个序列已经排好序了！ 2、代码实现 12345678910111213141516171819202122232425262728293031//将以k为根的子树调整为大根堆void HeadAdjust(int A[], int k, int len)&#123; A[0]=A[k]; //A[0]暂存子树的根结点 for(int i=2*k; i&lt;len; i*=2)&#123; //沿key较大的子结点向下筛选 if(i&lt;len &amp;&amp; A[i]&lt;A[i-1])&#123; i++; //取key较大子结点的下标 &#125; if(A[0]&gt;=A[i]) break; //筛选结束 else&#123; A[k]=A[i]; //将A[i]调整到双亲结点上 k=1; //修改k值，以便继续向下筛选 &#125; &#125; A[k]=A[0]; //被筛选结点的值放入最终位置&#125;//建立大根堆void BuildMaxHeap(int A[], int len)&#123; for(int i=len/2; i&gt;0; i--) //从后往前调整所有非终端节点 HeadAdjust(A,i,len);&#125;//堆排序的完整逻辑void HeapSort(int A[], int len)&#123; BuildMaxHeap(A,len); //初始建堆 for(int i=len; i&gt;1; i--)&#123; //n-1躺的交换和建堆过程 swap(A[i], A[1]); //交换堆顶元素和堆底元素 HeadAdjust(A, 1, i-1); //把剩余的待排序元素整理成堆 &#125;&#125; 3、性能分析 时间复杂度：$O(n\\log_2n)$. 空间复杂度：$O(1)$. 稳定性：不稳定。 4、堆的插入和删除❗是在堆里面不是在排序序列里面❗ （1）插入 先将新的元素放到表尾； 再根据实际情况将元素不断“上升”，直到无法继续上升为止。 （2）删除 将目标元素删除，用表尾元素代替删除元素； 再根据实际情况将元素不断“下坠”，直到无法继续下坠为止。 五、归并排序（一）算法思想 （二）代码实现 12345678910111213141516171819202122232425int *B=(int *)malloc(n*sizeof(int)); //辅助数组B//A[low...mid]和A[mid+1...high]各自有序，将两个部分归并void Merge(int A[], int low, int mid, int high)&#123; int i, j, k; for(k=low; k&lt;=high; k++) B[k]=A[k]; //将A中所有元素复制到B中 for(i=low, j=mid+1, k=1; i&lt;mid&amp;&amp;j&lt;=high; k++)&#123; if(B[i]&lt;=B[j]) A[k]=B[i++]; //将较小值复制到A中 else A[k]=B[j++]; &#125; while(i&lt;=mid) A[k++]=B[i++]; while(j&lt;=high) A[k++]=B[j++];&#125;void MergeSort(int A[], int low, int high)&#123; if(low&lt;high)&#123; int mid=(low+high)/2; //从中间划分 MergeSort(A,low,mid); //对左半部分归并排序 MergeSort(A,mid+1,high); //对右半部分归并排序 Merge(A,low,mid,high); //归并 &#125;&#125; （三）性能评估 时间复杂度：$O(nlog_2n)$. 空间复杂度：$O(n)$. 稳定性：稳定。 总结： 六、各种排序算法性能分析总结 算法 时间复杂度 空间复杂度 稳定性 直接插入排序InsertSort $O(n^2)$ $O(1)$ 稳定 折半插入排序 $O(n^2)$ $O(1)$ 稳定 希尔排序ShellSort 最坏$O(n^2)$，当$n$在某个范围内时可达$O(n^{1.3})$ $O(1)$ 不稳定 冒泡排序BubbleSort $O(n^2)$ $O(1)$ 稳定 快速排序QuickSort $O(nlog_2n)$ 最好$O(log_2n)$，最坏$O(n)$ 不稳定 （简单）选择排序SelectSort $O(n^2)$ $O(1)$ 不稳定 堆排序HeapSort $O(nlog_2n)$ $O(1)$ 不稳定 归并排序MergeSort $O(nlog_2n)$ $O(n)$ 稳定","categories":[{"name":"编程","slug":"编程","permalink":"http://kouqiang.space/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://kouqiang.space/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://kouqiang.space/tags/%E7%AE%97%E6%B3%95/"}],"author":"寇强"},{"title":"🔑数据结构_第七章：查找","slug":"🔑数据结构_第七章：查找","date":"2023-09-11T06:45:00.000Z","updated":"2024-05-13T09:24:19.832Z","comments":true,"path":"2023/09/11/🔑数据结构_第七章：查找/","link":"","permalink":"http://kouqiang.space/2023/09/11/%F0%9F%94%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E7%AC%AC%E4%B8%83%E7%AB%A0%EF%BC%9A%E6%9F%A5%E6%89%BE/","excerpt":"","text":"🔑数据结构_第七章：查找一、基本概念 查找：在数据集合中寻找满足某种条件的数据元素的过程称为查找； 查找表（查找结构）：查找的数据集合称为查找表，它由同一类型的数据元素(或记录)组成； 关键字：数据元素中唯一标识该元素的某个数据项的值，使用基于关键字的查找，查找结果应该是唯一的。 对查找表的常见操作： 仅查找符合条件的数据元素——静态查找表——仅关注查找速度即可； 插入、删除某个数据元素——动态查找表——除了查找速度，还要注意插&#x2F;删操作是否方便实现。 查找算法的评价指标： 查找长度：在查找运算中，需要对比关键字的次数称为查找长度； 平均查找长度(ASL,Average Search Length)：所有查找过程中进行关键字的比较次数之和的平均值。ASL的数量级反映了查找算法的时间复杂度。 评价一个查找算法的效率时，通常考虑查找成功&#x2F;查找失败两种情况的ASL。 通常认为查找任何一个元素的概率都相同。 二、顺序查找（一）算法思想顺序查找，又叫线性查找，通常用于线性表。算法思想：从头到 jio 挨个找 (或者反过来也OK)。就是遍历对比。 （二）代码实现方法1 123456789101112131415//要查找的顺序表typedef struct&#123; ElemType *elem; //动态数组基址 int TableLen; //表的长度&#125;SSTable;//顺序查找——查找表ST中关键字为key的元素，返回其数组下标int Search_Seq(SSTable ST, ElemType key)&#123; //标记查到的元素下标 int i; //循环遍历查找 for(i=0; i&lt;ST.TableLen &amp;&amp; ST.elem[i]!=key; i++); //循环结束，查找成功则返回查到的元素的数组下标i，没查到则返回-1 return i==ST.TableLen? -1 : i;&#125; 方法2 1234567//查找表的0号元素默认不存储数据，查找时使其等于key，然后从尾到头遍历，查找失败则返回0int Search_Seq(SSTable ST, ElemType key)&#123; ST.elem[0]=key; int i; for(i=ST.Table; ST.elem[i]!=key; i--); return i;&#125; （三）性能分析ASL成功 &#x3D; (1+2+3+…+n)&#x2F;n &#x3D; (n+1)&#x2F;2; ASL失败 &#x3D; n+1; 时间复杂度为：O(n)。 （四）优化（对有序表） 三、二分查找（折半查找） 仅适用于有序的顺序表！！！ （一）算法思想二分法，没什么好说的。 （二）代码实现1234567891011121314151617181920212223//待查找的有序表typedef struct&#123; ElemType *elem; int TableLen;&#125;SSTable;//折半查找——从表L中查找等于key的数组元素，返回数组下标int Binary_Search(SSTable L, ElemType key)&#123; //定义左中右三个位置的标识 int low=0, high=L.TableLen-1, mid; //循环查找 while(low&lt;=hile)&#123; mid=(low+high)/2; if(L.elem[mid]==key) return mid; else if(L.elem[mid]&gt;key) high=mid-1; else low=mid+1; &#125; //当low&gt;high时循环结束，未查找到，返回-1 return -1;&#125; （三）性能评估 四、索引查找（分块查找）（一）算法思想 查找表里存储的元素为分块的规律，块有序，块内元素无序。 按照块的规律给查找表建立索引表，查找数据时先将数据与索引表对比，确定查找范围，再在查找表里按此范围顺序查找。 默认分块是按从小到大的顺序排列的。 12345678910//定义索引表typedef struct&#123; //最大关键字 ElemType maxValue; int low, high; //int mid; //折半查找需要的mid变量&#125;//顺序表存储实际待查找元素ElemType List[]; 关键字先在索引表中查找： 可以顺序查找对比 1.判断关键字是否小于索引表中第一个分块的maxValue； （1）小于，说明key就在该分块内，接下来去查找表中该分块的[low, high]区间内查找即可。 （2）不小于，说明key在后面的分块内，那么向后找到下一个分块，重复执行步骤（1）（2）即可。 也可以折半查找 1.初始化索引表：mid = (low + high) / 2; 2.判断key和mid 的大小关系： key &lt; mid high = mid - 1; mid = (low + high) / 2; 此时如果low&gt;high，那么直接跳到步骤3； 重复步骤2； key &gt; mid low = mid + 1; mid = (low + high) / 2; &#96; 此时如果low&gt;high，那么直接跳到步骤3； 重复步骤2； key = mid 直接去当前mid所指的块内查找即可； 3.说明key就在low所指的分块内，接下来去查找表中查找该分块对应的范围即可。 在查找表中查找 顺序遍历即可。 当索引表low &gt; high时，查找元素必定在low所指分块内的原因： （二）性能评估1、查找效率分析——ASL 对于顺序查找索引表： 当有n个元素时，将其分为√n个块，每块有√n个元素，这样ASL会达到最小值：ASL&#x3D;√n+1。 对于折半查找索引表： 不重要。。。 扩展与优化 五、二叉排序树的定义及运算（一）概念 二叉排序树： 左子树上结点总是小于根，右子树上结点总是大于根。 即：左孩子 &lt; 根结点 &lt; 右孩子的二叉树，根据这个特点对其中序遍历，得到的序列一定是大小递增的序列。 （二）查找 12345678910111213141516171819202122232425262728293031323334353637383940//二叉排序树结点typedef struct BSTNode&#123; int data;//数据域 struct BSTNode *lchild, *rchild;//左右孩子指针&#125;BSTNode, *BSTree;//查找算法——在二叉排序树中寻找值为key的结点//循环方式实现BSTNode *BST_Search(BSTree T, int key)&#123; while(T!=NULL &amp;&amp; key!=T-&gt;data)&#123;//若树空或者等于根节点值，则循环结束 if(key &lt; T-&gt;data)//小于 T=T-&gt;lchild; else T=T-&gt;rchild; &#125; return T;&#125;//递归方式实现——王道官方BSTNode BST_Search(BSTree T, int key)&#123; if(T==NULL) return NULL; if(T-&gt;data==key) return T; else if(key &lt; T-&gt;data) return BSTSearch(T-&gt;lchild, key);//在左子树中找 else return BSTSearch(T-&gt;rchild, key);//在右子树中找&#125;//递归方式实现——自己写BSTNode BST_Search(BSTree T, int key)&#123; if(T==NULL || T-&gt;data==key) return T; if(key &gt; T-&gt;data) T=T-&gt;rchild; else T=T-&gt;lchild; Bst_Search(T, key);&#125; （三）插入 若原二叉排序树为空，则直接插入结点； 否则，判断，若关键字k小于根结点值，则插入到左子树；若关键字k大于根结点值，则插入到右子树。 1234567891011121314151617181920212223242526272829303132333435363738394041424344//王道官方——递归实现//给二叉排序树插入kint BST_Insert(BSTree &amp;T, int k)&#123; //若原树为空或定位到了合适的插入位置，则以k为data创建结点插入 if(T==NULL)&#123; T=(BSTree)malloc(sizeof(BSTNode)); T-&gt;data=k; T-&gt;lchild=T-&gt;rchild=NULL; return 1;//返回1，插入成功 &#125; else if(k==T-&gt;data)//树中存在相同值结点，插入失败返回0 return 0; else if(k &lt; T-&gt;data) return(BST_Insert(T-&gt;lchild)); else return(BST_Insert(T-&gt;rchild));&#125;//给二叉排序树插入k——循环实现int BST_Insert(BSTree &amp;T, int k)&#123; //先判断树空，空则直接插入 if(T==NULL)&#123; T=(BSTree)malloc(sizeof(BSTNode)); T-&gt;lchild=T-&gt;rchild=NULL; T-&gt;data=k; return 1; &#125; //不空，循环找位置插入： while(!T==NULL)&#123; if(k==T-&gt;data) //存在相同的数，插入失败，返回0 return 0; else if(k &lt; T-&gt;data) T=T-&gt;lchild; else T=T-&gt;rchild; &#125; //找到了合适的位置，插入 T=(BSTree)malloc(sizeof(BSTNode)); T-&gt;lchild=T-&gt;rchild=NULL; T-&gt;data=k; //T-&gt;father-&gt;xchild=T return 1;&#125; （四）二叉排序树的构造 设有序列str=&#123;......&#125;，数据元素个数为n，以此构建二叉排序树： 123456void Creat_BST(BSTree &amp;T, int str[], int n)&#123; T=NULL; for(int i=0; i&lt;n; i++)&#123; BST_Insert(T, str[i]); &#125;&#125; 同一序列，若数据元素顺序不同，构造出来的二叉树可能相同也可能不同！ （四）删除分三种情况： 删除的是叶子结点，那么直接删即可； 删除的结点只有左子树或只有右子树，那么之间删除结点再让其左&#x2F;右子树连上来即可； 删除的结点既有左子树又有右子树： 先找到目标元素的直接前驱或直接后继，用这个元素的值替换掉要删除元素的值； 再在其右子树中删除其直接前驱或直接后继即可。 （五）性能评估查找的性能分析： 空间复杂度： 循环方法：O(1)； 递归方法：O(h)；&#x2F;&#x2F;h为树的高度 时间复杂度： 最坏情况为树的高度：O(h)； 平均查找长度：O(log2n+1); 查找长度：在查找运算中，需要对比关键字的次数称为查找长度，反映了查找操作时间复杂度。 （六）平衡二叉树1、平衡二叉树的构造 定义：平衡二叉树(Balanced Binary Tree)，简称平衡树(AVL树)，树上任一结点的左子树和右子树的高度之差不超过1。 结点平衡因子 &#x3D; 左子树高 - 右子树高。 在平衡二叉树中插入结点，有可能会导致不平衡，通常插入操作分为以下四种情况： （1）LL情况在左子树的左结点插入新结点： （2）RR情况 （3）LR （4）RL （5）查找效率分析 2、平衡二叉树的删除 六、散列查找（一）散列表（哈希表） 散列表 (Hash Table)，又称哈希表，是一种数据结构，特点是：数据元素的关键字与其存储地址直接相关。 我们通过散列函数&#x2F;哈希函数建立关键字与存储地址的联系。 若不同的关键字通过散列函数映射到同一个值，则称它们为同义词； 通过散列函数确定的位置已经存放了其他元素，则称这种情况为冲突。 处理冲突的方法之一——拉链法： 用拉链法（又称链接法、链地址法）处理“冲突”：把所有“同义词”存储在一个链表中： PS：将链表变成有序链表，效率会进一步提高！ （二）查找逻辑 先用哈希函数计算关键字的对应存储地址，查找到后再去哈希表里查找，例如图中； 性能评估 查找成功 总之，冲突越多，查找效率越低，而哈希函数越优秀，产生的冲突越少。 理论上，散列查找的最优时间复杂度可达到O(1)。 查找失败 装填因子： $\\alpha$ &#x3D; 表中记录数 &#x2F; 散列表长度 （三）常见哈希函数&#x2F;散列函数1、除留余数法$H(key)&#x3D;key%p$： 散列表长m，取一个不大于m但最接近或等于m的质数p。 一定得是质数，才能尽可能的让更多的元素分布均匀！ 当然，考试标准答案是质数，但在实际业务场景中还得根据实际情况选择！ 2、直接定址法$H(key)&#x3D;key$ 或 $H(key)&#x3D;a \\times key+b$： 其中，a和b是常数。这种方法计算最简单，且不会产生冲突。 它适合关键字的分布基本连续的情况，若关键字分布不连续，空位较多，则会造成存储空间的浪费。 3、数字分析法 4、平方取中法取关键字的平方值的中间几位作为散列地址。 具体取多少位要视实际情况而定。 这种方法得到的散列地址与关键字的每位都有关系，因此使得散列地址分布比较均匀，适用于关键字的每位取值都不够均匀或均小于散列地址所需的位数。 总之，散列查找是典型的“用空间换时间”的算法，只要散列函数设计的合理，则散列表越长，冲突的概率越低。 （四）常见冲突处理方法1、拉链法处理冲突的方法之一——拉链法： 用拉链法（又称链接法、链地址法）处理“冲突”：把所有“同义词”存储在一个链表中： PS：将链表变成有序链表，效率会进一步提高！ 2、开放定址法所谓开放定址法，是指可存放新表项的空闲地址既向它的同义词表项开放，又向它的非同义词表项开放。 其数学递推公式为：$$H_i&#x3D;(H(key)+d_i)%m$$其中$i&#x3D;0,1,2,…,k(k \\le m-1)$，$m$表示散列表表长，$d_i$为增量序列，$i$可理解为“第$i$次发生冲突”。 关于$d_i$的确定有三种方法： 线性探测法——$d_i&#x3D;0,1,2,…,m-1$： 即发生冲突时，每次往后探测相邻的下一个位置是否为空。 空则存储在下位置，不空则重复检测下一个，直到存下为止。 缺点：线性探测法很容易造成同义词、非同义词的“聚集 (堆积)”现象，严重影响查找效率。 产生原因——冲突后再探测一定是放在某个连续的位置。 平方探测法——$d_i&#x3D;0^2,1^2,(-1)^2,2^2,(-2)^2,…,k^2,(-k)^2$： 又称二次探测法，其中$k\\le \\frac{m}{2}$。 非重点小坑：采用此方法处理时，前提条件是哈希表的表长必须为$4j+3$，这样才能使得所有单元格都能被探测到！否则只会重复检测其中的某些位置！ 查找：也是此方法查找即可。 伪随机序列法： 就是让$d_i$等于一个你自己确定的具体序列。 总结 查找：进行查找时同样也是这样操作，直到遇到空位表示查找失败。 ❗删除：若是直接删掉元素会导致空位出现从而影响查找，所以应该用自定义的删除标识标记此处为已删除！ 3、再哈希法&#x2F;再散列法 4、建立一个公共溢出区另设立向量OverTable[0..v]为溢出表。 所有冲突的记录，不管它们由哈希函数得到的哈希地址是什么，一旦发生冲突，都填入溢出表。","categories":[{"name":"编程","slug":"编程","permalink":"http://kouqiang.space/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://kouqiang.space/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://kouqiang.space/tags/%E7%AE%97%E6%B3%95/"}],"author":"寇强"},{"title":"LATEX常用语法总结","slug":"LATEX常用语法总结","date":"2023-09-02T09:45:00.000Z","updated":"2023-10-20T05:38:10.208Z","comments":true,"path":"2023/09/02/LATEX常用语法总结/","link":"","permalink":"http://kouqiang.space/2023/09/02/LATEX%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/","excerpt":"","text":"LATEX常用语法一、入门常用 行内公式：用两个美元符号即可：$公式内容$，如：$ax+b=0$显示为：$ax+b&#x3D;0$。 多行公式：用两个美元符号，不能与公式内容在同一行： 123$$%...公式内容...$$ 上标：^，下标：_，这两个符号只会将它后面的一个字符解析为上下标，但可以同时有上标和下标且代码前后顺序不影响解析效果，如：$a^2+b_2=c^2_3$和$a^2+b_2=c_3^2$，都显示为：$a^2+b_2&#x3D;c^2_3$。 如果上下标内容有多个字符，则须用&#123;&#125;括起来：$a^&#123;x+y&#125;+b_&#123;ij&#125; = c_&#123;def&#125;^&#123;ghi&#125;$显示为：$a^{x+y}+b_{ij} &#x3D; c_{def}^{ghi}$。 单行注释：用%。 多行注释：语法不统一，部分解析器还不支持，所以还是用单行注释吧。 强制换行： 两个反斜杠：\\\\； \\par； \\newline。 二、常用符号（1）数学符号 符号名称 LATEX代码 显示效果 符号名称 LATEX代码 显示效果 加号减号 +和- $+$和$-$ 星号 \\ast或* $\\ast$或$*$ 乘号 \\times $\\times$ 大括号 \\&#123; \\&#125; ${}$ 除号 \\div $\\div$ 分数 \\frac&#123;a&#125;&#123;b&#125; $\\frac{a}{b}$ 加或减 \\pm $\\pm$ 大于等于 \\ge $\\ge$ 减或加 \\mp $\\mp$ 小于等于 \\le $\\le$ 并集 \\cup $\\cup$ 远大于 \\gg $\\gg$ 交集 \\cap $\\cap$ 远小于 \\ll $\\ll$ 恒等于 \\equiv $\\equiv$ 等价符号 \\sim $\\sim$ 约等于 \\approx $\\approx$ 全等于 \\cong $\\cong$ 因为 \\because $\\because$ 所以 \\therefore $\\therefore$ 无穷大 \\infty $\\infty$ 开根号 根号：\\sqrt&#123;x&#125;；n次根号：\\sqrt[n]&#123;x&#125; 根号：$\\sqrt{x}$；n次根号：$\\sqrt[n]{x}$ 极限 \\lim_&#123;a \\to b&#125; (Typora不能正确显示) $\\lim_{a \\to b}$ 正确格式： 求和 \\sum_&#123;a&#125;^&#123;b&#125;(Typora不能正确显示) $\\sum_{a}^{b}$ 正确格式： 积分 \\int_&#123;a&#125;^&#123;b&#125;和\\int\\limits_&#123;a&#125;^&#123;b&#125; $\\int_{a}^{b}$和$\\int\\limits_{a}^{b} $ 曲线积分 \\oint_&#123;a&#125;^&#123;b&#125; $\\oint_{a}^{b} $ 向上取整 \\lceil x \\ceil $\\lceil x \\rceil$ 向下取整 \\lfloor x \\rfloor $\\lfloor x \\rfloor$ （二）希腊字母 符号名称 读法 LATEX代码 显示效果 符号名称 读法 LATEX代码 显示效果 阿尔法 &#x2F;‘ælfə&#x2F; \\alpha $\\alpha$ 贝塔 &#x2F;‘bi:tə&#x2F;或 &#x2F;‘beɪtə&#x2F; \\beta $\\beta$ 伽马 &#x2F;‘gæmə&#x2F; \\gamma $\\gamma$ 德尔塔 &#x2F;‘deltə&#x2F; \\delta $\\delta$ 欸普赛隆 \\epsilon $\\epsilon$ \\varepsilon $\\varepsilon$ \\zeta $\\zeta$ \\eta $\\eta$ \\theta $\\theta$ \\vartheta $\\vartheta$ \\iota $\\iota$ \\kappa $\\kappa$ \\lambda $\\lambda$ \\mu $\\mu$ \\nu $\\nu$ \\xi $\\xi$ o $o$ \\pi $\\pi$ \\varpi $\\varpi$ \\rho $\\rho$ \\varrho $\\varrho$ \\sigma $\\sigma$ \\varsigma $\\varsigma$ \\tau $\\tau$ \\upsilon $\\upsilon$ \\phi $\\phi$ \\varphi $\\varphi$ \\chi $\\chi$ \\psi $\\psi$ \\omega $\\omega$ \\Delta $\\Delta$ \\Omega $\\Omega$ \\Sigma $\\Sigma$ \\Lambda $\\Lambda$ 凑合看吧懒得抄了。 三、多行公式与简单对齐 多行公式： 首先是\\left和\\right，后面分别必须跟内容否则报错，要显示大括号就跟\\&#123;，不显示内容就跟英文点号.，中间可以不加空格。 1234$$\\left \\&#123; \\right.$$ 然后是\\begin&#123;matrix&#125;和\\end&#123;matrix&#125;，内部才是公式内容，如： 123456789$$\\left \\&#123;\\begin&#123;matrix&#125;%这里写公式内容：x_1+x_2+x_3=0 \\\\ 2x_1+2x_2+2x_3=0\\end&#123;matrix&#125;\\right.$$ 显示效果： $$\\left { \\begin{matrix} %这里写公式内容 x_1+x_2+x_3&#x3D;0 \\ 2x_1+2x_2+2x_3&#x3D;0 \\end{matrix} \\right.$$ 如果想要使公式对齐，可在要对齐的位置处添加&amp;符号： 123456789$$\\left \\&#123;\\begin&#123;matrix&#125;%这里写公式内容x_1+x_2+x_3&amp;=0 \\\\ 2x_1+2x_2+2x_3&amp;=0\\end&#123;matrix&#125;\\right.$$ $$\\left {\\begin{matrix}%这里写公式内容x_1+x_2+x_3&amp;&#x3D;0 \\2x_1+2x_2+2x_3&amp;&#x3D;0\\end{matrix}\\right.$$","categories":[{"name":"其他工具","slug":"其他工具","permalink":"http://kouqiang.space/categories/%E5%85%B6%E4%BB%96%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"学习总结","slug":"学习总结","permalink":"http://kouqiang.space/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"},{"name":"LATEX","slug":"LATEX","permalink":"http://kouqiang.space/tags/LATEX/"},{"name":"工具","slug":"工具","permalink":"http://kouqiang.space/tags/%E5%B7%A5%E5%85%B7/"},{"name":"Typora","slug":"Typora","permalink":"http://kouqiang.space/tags/Typora/"},{"name":"快捷键","slug":"快捷键","permalink":"http://kouqiang.space/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"}],"author":"寇强"},{"title":"🔑数据结构_第六章：图","slug":"🔑数据结构_第六章：图","date":"2023-08-27T00:00:00.000Z","updated":"2024-05-13T09:26:31.021Z","comments":true,"path":"2023/08/27/🔑数据结构_第六章：图/","link":"","permalink":"http://kouqiang.space/2023/08/27/%F0%9F%94%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E5%9B%BE/","excerpt":"","text":"🔑数据结构_第六章：图第六章、图（一）图的基本概念1、定义： 线性表是一对一，树是一对多，图就是多对多。 图由顶点和边组成，顶点即数据节点，边即顶点间的联系，每条边都一定连接着两个顶点，但每个顶点不一定有几条边相连。 图G由顶点集V和边集E组成，记为G = (V, E)；V(G)表示图G中所有顶点的集合，为有限非空集；E(G)表示图G中所有边的集合，可以是空集。 **|V|表示图G中顶点的总个数，也称图G的阶；|E|**表示图G中边的条数。 线性表可以是空表，树可以是空树，但是图不能是空图！ 2、无向图和有向图 无向图 边为无向边的图称为无向图，无向边也称为边。 边是顶点的无序对，记为(v,w)或(w,v)，其中v、w为顶点&#x2F;互为邻接点，(v,w)&#x3D;(w,v)。 可以说边(v,w)依附于顶点w和v，或者说边(v,w)与顶点w、v相关联。 对于上图中图G可表示为：$$\\begin{align}G_1 &amp;&#x3D; (V_1,E_1) \\V_1 &amp;&#x3D; { A,B,C,D,E } \\E_1 &amp;&#x3D; { (A,B),(B,D),(B,E),(C,D),(C,E),(D,E) }\\end{align}$$ 有向图 边为有向边的图称为有向图，有向边也称为弧：从左指向右，从弧尾指向弧头。 弧是顶点的有序对，记为&lt;v,w&gt;，其中v、w为顶点，v称为弧尾，w称为弧头，&lt;v,w&gt;≠&lt;w,v&gt;。 &lt;v,w&gt;称为从顶点v到顶点w的弧，表示v邻接到w，或w邻接自v。 对于上图中图G可表示为： $$\\begin{align}G_2 &amp;&#x3D; (V_2, E_2) \\V_2 &amp;&#x3D; { A,B,C,D,E } \\E_2 &amp;&#x3D; { &lt;A,B&gt;,&lt;A,C&gt;,&lt;A,D&gt;,&lt;A,E&gt;,&lt;B,A&gt;,&lt;B,C&gt;,&lt;B,E&gt;,&lt;C,D&gt; }\\end{align}$$ 3、简单图与多重图考研不探讨多重图。 4、顶点的度、入度、出度 对于无向图 顶点v的度是指依附于该顶点的边的条数，记为**TD(v)**。 无向图中全部顶点（v）的度的和等于边数的2倍，即在具有n个顶点e条边的无向图中：$$\\sum_{i&#x3D;1}^{n} TD(v_i) &#x3D; 2e$$ 对于有向图 入度是以顶点v为终点的有向边的数目，记为ID(v)； 出度是以顶点v为起点的有向边的数目，记为OD(v)； **顶点v的度TD(v)等于其入度和出度之和：TD(v) &#x3D; ID(v) + OD(V)**，即在具有n个顶点、e条边的有向图中：$$\\sum_{i&#x3D;1}^{n}TD(v_i) &#x3D; \\sum_{i&#x3D;1}^{n}ID(v_i) + \\sum_{i&#x3D;1}^{n}OD(v_i)$$ 在具有n个顶点、e条边的有向图中，入度数目&#x3D;出度数目&#x3D;边数：$$\\sum_{i+1}^{n}ID(v_i) &#x3D; \\sum_{i+1}^{n}OD(v_i) &#x3D; e$$ 5、顶点 - 顶点关系描述 路径：顶点vp到顶点vq逐渐的一条路径是指顶点序列：vp, vi1, vi2, vi3, …… vq。 回路：第一个顶点和最后一个顶点相同的路径称为回路或环。 简单路径：在路径序列中，顶点不重复出现的路径称为简单路径。 简单回路：除第一个顶点和最后一个顶点外，其余顶点不重复出现的回路称为简单回路。 路径长度：路径上边的数目。 点到点的距离：从顶点u出发到顶点v的最短路径若存在，则此路径的长度称为从u到v的距离。若从u到v根本不存在路径，则记该距离为无穷（∞）。 无向图——顶点的连通：无向图中，若从顶点v到顶点w有路径存在，则称v和w是连通的。 有向图——顶点的强连通：有向图中，若从顶点v到顶点w和从顶点w到顶点v之间都有路径，则称这两个顶点是强连通的。 6、连通图与强连通图 无向图的连通图 任意两个顶点都是连通的，否则为非连通图。 常见考点——对于n个顶点的无向图G： 若G是连通图，则最少有n-1条边； 若G是非连通图，则最多可能有C2n-1条边。 有向图的强连通图 任意一对顶点都是强连通的。 常见考点： 对于n个顶点的有向图G，若G是强连通图，则最少应有n条边（形成回路）。 7、子图对于无向图和有向图来说：设有两个图G&#x3D;(V, E)和G‘&#x3D;(V‘, E‘)，若V‘是V的子集，E‘是E的子集，则称G‘是G的子图。 若G‘和G的顶点完全一样，只是边不同，那么我们称G‘为G的生成子图。 *注：并非从图G中任意选取一些顶点和边组成的集合就是子图，必须满足这些选出来的顶点和边能组合成正确的图才行！ 8、连通分量和强连通分量极大连通子图：包含尽可能多的顶点和边的连通子图。 极大强连通子图：包含尽可能多的顶点和边的强连通子图。 无向图的连通分量 无向图中的极大连通子图称为无向图的连通分量。 有向图的强连通分量 有向图中的极大强连通子图称为有向图的强连通分量。 9、生成树与生成森林极小连通子图：边尽可能的少，但要保持联通。 生成树 连通图的生成树是指包含图中全部顶点的一个极小连通子图。 若图G的顶点数为n，则它的生成树含有n-1条边。 对于生成树而言，若砍去它的一条边则会变成非连通图，若加上一条边则会出现一个回路。 生成森林 在非连通图中，连通分量的生成树构成了这个非连通图的生成森林。 10、边的权、带权图&#x2F;网 边的权： 在一个图中（无论有向或无向），每条边都可以标上具有某种含义的数值，该数值称为该边的权值。 带权图&#x2F;网： 边上带有权值的图（无论有向或无向）称为带权图，也称网。 带权路径长度： 当图（无论有向或无向）是带权图时，一条路径上所有边的权值之和，称为该路径的带权路径长度。 11、几种特殊的图（1）完全图 无向完全图：任意两个顶点之间都有边的图。 n个顶点的无向完全图的总边数为**C2n**个。 有向完全图：任意两个顶点之间都有两条互指的弧的图。 n个顶点的有向完全图的总边数为**2C2n**个。 （2）稀疏图和稠密图稀疏图和稠密图是相对而言的，并没有单独的判断标准！ （3）树和森林 树： 不存在回路，且连通的无向图。 n个顶点的树，必有n-1条边。 常见考点：n个顶点的图，若边数|E|&gt;n-1，则一定有回路！ 森林： 多个树的集合。 有向树： 一个顶点的入度为0，其余所有顶点的入度均为1的有向图，称为有向树。 入度为0的那个顶点可看作树的根结点。 注：有向树并不是强连通图！ 总结： （二）图的存储与实现1、邻接矩阵法（1）普通图 顶点数有n个，那么对应的邻接矩阵大小是n*n。 若将图G的顶点编号为v1，v2，…vn，则：$$A[i][j]&#x3D;\\left{\\begin{align}1,&amp; \\ \\ \\ \\ \\ 若(v_i,v_j)或&lt;v_i,v_j&gt;是E(G)的边\\0,&amp; \\ \\ \\ \\ \\ 若(v_i,v_j)或&lt;v_i,v_j&gt;不是E(G)的边\\end{align}\\right.$$ 无向图的邻接矩阵是个对称矩阵，而有向图的不是。 有向图中：A指向B，那么在矩阵中的A行B列的值为1（横的指向竖的）。 无向图的度等于结点自身所在行或列的非0元素个数。 有向图的入度等于节点所在列的非0元素个数，而出度等于节点所在行的非0元素个数，度等于二者之和。 两种图的的邻接矩阵法求顶点的度&#x2F;入度&#x2F;出度的时间复杂度均为O(|V|)。 （2）带权图 在普通图的基础上稍加改造即可，可将原先矩阵中表示有连接的数字1用权值替代，没有边的位置用自定义的数字表示。（根据实际业务需求决定）。 （3）性能分析空间复杂度通常很高，只适合存储稠密图。 （4）邻接矩阵的特殊性质设图G的邻接矩阵为A(矩阵元素为0和1)，则An的元素An[i][j]等于由顶点i到顶点j的长度为n的路径的数目。 2、邻接表法 1234567891011121314151617181920//定义“顶点”typedef struct VNode&#123; int data; //顶点信息 ArcNode *first; //第一条边/弧&#125;VNode, AdjList[100]; //将该顶点结构变换为一个顶点数组//定义“边/弧”typedef struct ArcNode&#123; int adjvex; //边/弧指向哪个顶点 struct ArcNode *next; //指向下一条弧的指针 //InfoType info; //边的权值&#125;;//定义图typedef struct&#123; //声明图里面的顶点数组 AdjList vertices; //定义顶点和边/弧的数量 int vexnum, arcnum;&#125;ALGraph; 注：图的邻接表表示结果并不唯一！而用邻接矩阵法表示时，只要确定了顶点编号，那么矩阵就是唯一的！ 邻接表与邻接矩阵对比： 邻接表 邻接矩阵 空间复杂度 无向图O(|V|+|2E|)，有向图O(|v|+|E|) O(|V|2) 适合用于 存储稀疏图，稠密图也可 稠密图 表示方式&#x2F;表示结果 不唯一 唯一 计算度&#x2F;出度&#x2F;入度 计算有向图的度、入度不方便，其余很方便 须遍历对应行或列，较为方便 找相邻的边 找有向图的入边不方便，其余都方便 须遍历对应行或列，较为方便 3、十字链表、邻接多重表（工大不考）十字链表用于存储有向图，邻接多重表由于存储无向图。 （1）十字链表法 空间复杂度：O(|E|+|V| )。 如何找到指定顶点的所有出边？——顺着绿色线路找。 如何找到指定顶点的所有入边？——顺着橙色线路找。 注：十字链表法只适合存储有向图！ （2）邻接多重表法 空间复杂度：O(|V|+|E|)。 删除边、结点等操作很方便。 注：邻接多重表只适用于存储无向图！ （三）图的基本操作1、Adjacent(G,x,y)：判断图G是否存在边(x,y)或&lt;x,y&gt;： 对于无向图： 邻接矩阵法： 只需判断两个目标结点在邻接矩阵中的对应位置的矩阵元素值是否为1即可，为1则存在，为0不存在。 时间复杂度为O(1)。 邻接表法： 遍历其中一个结点的所有边结点。 时间复杂度：O(1)~O(|V|)。 对于有向图： 原理同上。 2、Neighbors(G, x)：列出图G中与结点x相邻的边： 无向图： 邻接矩阵法： 遍历目标节点在矩阵中的所在行&#x2F;列，把值为1的元素全找出来即可。 时间复杂度为O(|V|)。 邻接表： 遍历目标结点对应的链表即可 时间复杂度：O(1)~O(|V|)。 有向图 邻接矩阵法： 找出边遍历对应的行，找入边遍历对应的列。 时间复杂度为O(|V|)。 邻接表： 找出边同上，而要找入边的话就必须遍历所有的边才行！ 时间复杂度：出边为O(1)~O(|V|)，而入边为O(|E|)。 3、InsertVertex(G, x)：在图G中插入顶点x： 无向图和有向图都是如此： 直接在矩阵或邻接表末尾插入即可。 4、DeleteVertex(G, x)：从图G中删除顶点x： 无向图： 邻接矩阵法： 在矩阵中将目标结点所在的行和列的所有元素值都改为0，再将用于存储结点的一维数组中的结点删去； 给结点结构体中添加一个bool类型的判空标识，这样删除结点时只需改动此标识即可。 只需修改矩阵中一行和一列的元素，时间复杂度为O(|V|)。 邻接表： 除了要删除结点和结点指向链表中所有数据，还要遍历整个链表找到所有相关的边进行删除。 时间复杂度O(|1|)~O(|E|)。 有向图： 邻接矩阵：同上。 邻接链表： 删除出边只需删除结点指向的链表即可，时间复杂度为O(1)~O(|V|)； 但删除入边就需要遍历找入边了，时间复杂度为O(|E|)。 5、AddEdge(G, x, y)：若边(x,y)、&lt;x,y&gt;不存在，则向图G中添加该边。 无向图和有向图相同： 邻接矩阵：只需更改矩阵里的对应元素值为1即可，时间复杂度为O(1)。 邻接链表：在对应结点的对应链表中，采用尾插法或头插法都可，时间复杂度为O(1)~O(|V|)。 6、FirstNeighbor(G,x)：求图G中顶点x的第一个邻接点，若有则返回顶点号，若x无邻接顶点或图中不存在x，则返回-1： 无向图 邻接矩阵： 只需扫描对应的行或列，遇到的第一个值为1的数据返回即可。 时间复杂度为O(1)~O(|V|)。 邻接链表： 只需扫描结点对应的链表，返回该链表中第一个元素即可。 时间复杂度为O(1)。 有向图： 邻接矩阵： 原理同上，找出边横向遍历，找入边纵向遍历。 时间复杂度为O(1)~O(|V|)。 邻接链表： 同样，找出边一步到位，找入边就得遍历了。 时间复杂度为O(1)~O(|E|)。 7、NextNeighbor(G, x, y)：x为y的邻接点，找出x的除y之外的下一个邻接点，若有则返回顶点号，若无（y是x的最后一个邻接点）则返回-1： 算法在FirstNeighbor(G,x)的基础上，找到第y个，再往下扫描一个即可。 8、Get_edge_value(G, x, y)和Set_edge_value(G, x, y, v)：获取和设置某条边的权值： 与Adjacent(G,x,y)雷同，在其基础上增加一条获取或修改权值的指令即可。 时间复杂度：O(1)~O(|V|)。 （四）图的遍历1、广度优先遍历BFS有向图和无向图都完美适配！ （1）算法逻辑与树的广度优先遍历之间存在联系，而树的广度优先遍历即层序遍历。 图与树的不同即有回路，在树的层序遍历基础上解决这个回路问题即是图的广度优先遍历算法。 解决方式：给每个节点增加一个“访问标识”（如bool的0和1），用于记录在遍历过程中是否已访问过该结点。 算法思路： 1.找到与一个顶点相邻的所有顶点； 标记哪些顶点被访问过； 需要一个辅助队列。 FirstNeighbor(G,x): 求图G中顶点x的第一个邻接点，若有则返回顶点号。若x没有邻接点或图中不存在x，则返回-1。NextNeighbor(G,x,y): 假设图G中顶点y是顶点x的一个邻接点，返回除y之外顶点x的下一个邻接点的顶点号，若y是x的最后一个邻接点，则返回-1。 （2）代码实现 123456789101112131415161718192021222324252627282930313233343536//广度优先遍历void BFSTaverse(Graph G1)&#123; //一、生成并初始化“访问标记数组”（用于标记所有顶点是否已被访问） bool visited[MAX_VERTEX_NUM]; for(int i=0; i&lt;G.vexnum; ++i) visited[i] = false; //二、初始化辅助队列Q InitQueue(Q); //三、从0号顶点开始遍历 for(int i=0; i&lt;G.vexnum; ++i)&#123; //对每个连通分量调用一次BFS if(!visited[i]) //v_i未访问过，从v_i开始BFS BFS(G, i); &#125;&#125;//对单个连通图的遍历算法void BFS(Graph G1, int v)&#123; //从顶点v出发遍历图G1 //从第一个结点出发 visit(v); //访问初始顶点v visited(v) = true; //对v做已访问标记 Enqueue(Q, v); //顶点v入队列Q //对其余结点的处理 while(!isEmpty(Q))&#123; //若队列Q不为空则执行循环体，为空说明遍历结束 Dequeue(Q, v); //顶点v出队 //w初始情况下等于v的第一个邻接顶点，若顶点存在其值不可能小于0，若顶点不存在则其值被赋为-1，结束循环： for(w=FirstNeighbor(G,v); w&gt;=0; w=NextNeighbor(G,v,w))&#123; //循环找到所有邻接点，并在循环体内访问和入队 if(!visited[w])&#123; //w为v的尚未访问的邻接顶点 visit(w); //访问顶点w visited[w] = true; //对w做已访问标记 Enqueue(Q, w); //顶点w入队 &#125; &#125; &#125;&#125; 注： FirstNeighbor(G,x)：求图G中顶点x的第一个邻接点，若有则返回顶点号，若x无邻接顶点或图中不存在x，则返回-1。NextNeighbor(G, x, y)：x为y的邻接点，找出x的除y之外的下一个邻接点，若有则返回顶点号，若无（y是x的最后一个邻接点）则返回-1。 若图采用邻接矩阵法存储，那么遍历序列是唯一的，如果采用邻接表法存储，那么遍历结果不唯一！ （3）性能分析 时间复杂度 邻接矩阵：$O(|V|^2)$。 邻接链表：$O(|V|+|E|)$。 空间复杂度 （4）广度优先生成树与森林图由广度优先遍历过程得到的序列，可生成“广度优先生成树”： 同理： 注：若用邻接矩阵存储图，则以上二者的生成结果是唯一的，若用邻接链表存储图，则以上二者的生成结果不唯一。 最后： 2、深度优先遍历DFS（1）算法逻辑树的深度优先遍历分为先根遍历和后根遍历，二图的深度优先遍历类似于树的先根遍历。 树的先根遍历： （2）代码实现1234567891011121314151617181920212223242526272829303132//声明“访问标记数组”bool visited[MAX_VERTEX_NUM];//对图G进行深度优先遍历void DFSTraverse(Graph G)&#123; //初始化“访问标记数组” for(v=0; v&lt;G.vexnum; ++v) visited[v] = false; /* 此处从v=0处调用DFS方法去遍历它在图G中所在的连通分量； 完成后在整个图中寻找还未被访问的顶点，找到后再遍历它所在的连通分量， 如此循环执行就可以完整无误地遍历完整个图： */ for(v=0; v&lt;G.vexnum; ++v)&#123; if(!visited[v]) DFS(G, v); &#125;&#125;//从顶点v出发，深度优先遍历它所在的连通分量void DFS(Graph G, int v)&#123; //访问目标定点v visit(v); //更改“访问标识” visited[v] = true; //依次遍历寻找“下一个”邻接顶点 for(w=FirstNeighbor(G, v); w&gt;=0; w=NextNeighbor(G, v, w))&#123; //递归调用自己进行遍历 if(!visited[w]) DFS(G, w); &#125;&#125; （3）性能分析 空间复杂度： 来自函数调用栈，最坏情况为$O(|V|)$。 时间复杂度： 邻接矩阵存储的图：$O(|V|^2)$； 邻接链表存储的图：$O(|V|+|E|)$。 （4）深度优先生成树&#x2F;森林与广度优先生成树&#x2F;森林原理一样。 3、图的遍历和图的连通性 对无向图进行BFS&#x2F;DFS遍历： 调用BFS&#x2F;DFS函数的次数&#x3D;连通分量数。 对于连通图，只需调用1次 BFS&#x2F;DFS。 对无向图进行BFS&#x2F;DFS遍历： 对于普通有向图，调用BFS&#x2F;DFS函数的次数不一定，视具体情况。 而对于强连通图，只需调用1次 BFS&#x2F;DFS。 总结： （五）图的应用1、最小生成树（1）概念 生成树：连通图的生成树是指包含图中所有顶点的一个连通子图。 顶点有$n$个，则生成树的边有$n-1$条。 最小生成树： 边的权值之和最小的生成树。 （2）Prim算法从某一个顶点开始构建生成树；每次将代价最小的新顶点纳入生成树，直到所有顶点都纳入为止。 时间复杂度为$O(|V|^2)$。 时间复杂度不依赖于$|E|$，因此适合用于稠密图。 （3）KrusKal算法每次选择一条权值最小的边，使这条边的两头连通(原本已经连通的就不选)，直到所有结点都连通。 时间复杂度为$O(|E|\\log_2|E|)$。 适合于稀疏图。 2、最短路径 （1）单源最短路径——BFS算法只适用于无权图，或各边权值都相同的图！ 对BFS算法稍加改动即可： 新建一个二维数组，一行d[]记录结点到源结点的最短路径，另一行path[]记录其直接前驱； visit一个结点时，修改其最短路径长度d[]并在path[]中记录其前驱结点。 1234567891011121314151617181920212223242526272829303132333435//求图G中顶点u作为源顶点到其他顶点的最短路径void BFS_MIN_Distance(Graph G, int u)&#123; //初始化辅助数组 for(int i=0; i&lt;G.vexnum; i++)&#123; d[i] = ∞; //路径长度 path[i] = -1; //前驱 visited[i] = false; //访问标记数组 &#125; //算法开始，源结点u自身路径长度为0 d[u] = 0; //源结点u设为已被访问 visited[u] = true; //源结点u入队 EnQueue[Q,u]; //核心代码 while(!isEmpty(Q))&#123; //u先出队 DeQueue(Q,u); //找到u的“后继” for(w=FirstNeighbor(G,u); w&lt;G.vexnum; w=NextNeighbor(G,u,w))&#123; //如果该节点未被访问，那么“访问”该结点 if(!visited[w])&#123; //路径长度等于前驱的路径长度+1 d[w] = d[u] + 1; //标记其前驱 path[w] = u; //标记为已被访问 visited(w) = true; //入队 EnQueue(Q, w); &#125; &#125;//判断是否还有邻接结点，有则继续执行循环体，无则结束循环 &#125;&#125; （2）单源最短路径——Dijkstra算法迪杰斯特拉算法——无权图和有权图都适用！ 带权路径长度：当图是带权图时，一条路径上所有边的权值之和成为该路径的带权路径长度。 需要三个数组： bool final[G.vexnum]：标记各顶点是否已找到最短路径，初始化将源结点所在位置设为true，其余为false； int dist[G.vexnum]：对应的最短路径长度，初始化将源结点所在位置设为0，与源结点直接相连的结点的值就是其路径权值，其余的设为∞； int path[G.vexnum]：路径上的前驱，初始化将源结点设为-1，邻接结点对应数值为源结点所在位置（此例中为0），其余可为-1。 运行过程（该例中以V0为源结点） 初始化数组； 循环遍历final[]数组，找到所有标记为false的结点（意为还未找出与V0之间最短路径的结点），在这些节点中找到dist[]值最小的顶点Vi（此处为V4：dist[4]=5），令final[i]=true： 检查所有邻接自Vi的顶点（V0、V1、V2、V3），若其final[]值为false（排除了V0），则更新dist[]和path[]信息： 检查V1、V2、V3与V4的路径权值各自加上V0到V4的路径权值（5）得到的值，是否比原来dist[]中存储的值要小。 若是，则dist[]更改为此值，并把path[]的值改为4。 若否，则不做处理。 循环2、3步骤，直到final[]中所有数据都为true： 循环遍历final[]数组，找到所有标记为false的结点，在这些节点中找到dist[]值最小的顶点Vi，令final[i]=true…… 最终结果： 时间复杂度：$O(|V^2|$)。 注：该算法不适用于有负权值的图！ （3）各顶点间的最短路径——Floyd算法第一阶段： 12345678910111213//初始化矩阵A和path[]//核心代码for(int k=0; k&lt;n; k++)&#123; //以结点k为中转点 for(int i=0; i&lt;n; i++)&#123; //两个for循环遍历整个数组A for(int j=0; j&lt;n; j++)&#123; if(A[i][j] &gt; A[i][k]+A[k][j])&#123; //判断当前的第k个结点为中转点时的路径是否比原来的路径短 A[i][j] = A[i][k] + A[k][j]; //若是则应用此路径 path[i][j] = k; //同时更改存储路径信息的表path[][] &#125; &#125; &#125;&#125; 评价： 时间复杂度为$O(|V^3|)$。 可用于带有负权值的图。 但不能用于带有负权值回路的图！ （4）总结 BFS算法 Djkstra算法 Floyd算法 无权图 ✔ ✔ ✔ 带权图 ❌ ✔ ✔ 带负权值的图 ❌ ❌ ✔ 带负权值回路的图 ❌ ❌ ❌ 时间复杂度 邻接矩阵$O( V ^2)$、邻接链表$O( 通常用于 求无权图的单源最短路径 ①求带权图的单源最短路径、②所有顶点间的最短路径 求带权图中各顶点间的最短路径 3、有向无环图描述表达式有向无环图：没有环路的有向图。DAG图。 用有向无环图表示算术表达式： 这太简单了没什么好说的。 4、拓扑排序（1）AOV网定点表示活动的有向无环图： （2）拓扑排序找到做事的先后顺序。 拓扑排序的实现： 从AOV网中选择一个没有前驱 (入度为0)的顶点并输出； 从网中删除该顶点和所有以它为起点的有向边。 重复1和2直到当前的AOV网为空或当前网中不存在无前驱的顶点为止。 代码实现 123456789101112131415161718192021222324252627282930313233343536#define MaxVertexNum 100 //图中顶点数目最大值typedef struct ArcNode&#123; //边表结点 int adjvex; //该弧所指向的顶点的位置 struct ArcNode *nextarc; //指向下一条弧的指针 //InfoType info; //网的边权值&#125;ArcNode;typedef struct VNode&#123; //顶点表结点 VertexType data; //顶点信息 ArcNode *firstarc; //指向第一条依附该顶点的弧的指针&#125;VNode,AdjList[MaxVertexNum];typedef struct&#123; AdjList vertices; //邻接表 int vex, arcnum; //图的顶点数和弧数&#125;Graph; //Graph是以邻接表存储的图类型bool TopologicalSort(Graph G)&#123; InitStack(S); //初始化栈，存储入度为0的顶点 for(int i=0; i&lt;G.vexnum; i++) if(indegree[i]==0) Push(S, i); //将所有入度为0的顶点进栈 int count=0; //计数，记录当前已经输出的顶点数 while(!IsEmpty(S))&#123; //栈不空，则存在入度为0的顶点 Pop(S, i); //栈顶元素出栈 print[count++]=i; //输出顶点i for(p=G.vertices[i].firstarc; p; p=p-&gt;nextarc)&#123; //将所有i指向的顶点的入度减1，并且将入度为0的顶点压入栈S v=p-&gt;adjvex; if(!(--indegree[v])) Push(S, v); //入度为0，则入栈 &#125; &#125; if(count&lt;G.vexnum) return false; //拓扑排序失败，有向图中有回路 else return true; //拓扑排序成功&#125; 时间复杂度： 邻接表储存：O(|V|+|E|)； 邻接矩阵存储：O(|V|2)。 （3）逆拓扑排序与拓扑排序相反，每次删除的是出度为0的顶点。 （4）基于深度优先遍历算法实现逆拓扑排序 5、关键路径（1）相关概念 AOE网： 在带权有向图中，以顶点表示事件，以有向边表示活动，以边上的权值表示完成该活动的开销(如完成活动所需的时间)，称之为用边表示活动的网络，简称AOE网(Activity On Edge NetWork)。 性质： 只有在某顶点所代表的事件发生后，从该顶点出发的各有向边所代表的活动才能开始； 只有在进入某顶点的各有向边所代表的活动都已结束时，该顶点所代表的事件才能发生。另外，有些活动是可以并行进行的。 仅有一个入度为0的顶点，称为**开始顶点(源点)**，它表示整个工程的开始； 也仅有一个出度为0的顶点，称为**结束顶点 (汇点)**，它表示整个工程的结束。 从源点到汇点的有向路径可能有多条，所有路径中，具有最大路径长度的路径称为关键路径，而把关键路径上的活动称为关键活动； 完成整个工程的最短时间就是关键路径的长度，若关键活动不能按时完成，则整个工程的完成时间就会延长。 **活动ai的最早开始时间ei**——指该活动弧的起点所表示的事件的最早发生时间。 **活动ai的最迟开始时间li**——该活动的弧的终点所表示事件的最迟发生时间与该活动所需时间之差。 **事件vk的最迟发生时间vl(k)**——在不推迟整个工程完成的前提下，该事件最迟必须发生的时间。 **活动ai的最迟开始时间l(i)**——该活动弧的终点所表示事件的最迟发生时间与该活动所需时间只差。 活动ai的**时间余量：di&#x3D;li-ei**，表示在不增加工程总时间的情况下，活动ai可以拖延的时间。 时间余量为0的活动就是关键活动，不可拖延。 由关键活动组成的路径就是关键路径。 （2）求关键路径的步骤： 求所有事件的最早发生时间 ve()； 按拓扑排序序列，依次求各顶点的ve(k)： $$ve(源点)&#x3D;0 \\ve(k)&#x3D;Max{ve(j)+Weight(v_j,v_k)}，v_j为v_k的任意前驱$$ 求所有事件的最迟发生时间 vl()； 按逆拓扑排序序列，依次求各顶点的vl(k)： vl(汇点) &#x3D; ve(汇点)； vl(k) &#x3D; Min{vl(j) - Weight(vk, vj)}，vj为vk的任意后继。 求所有活动的最早发生时间e()； 若边&lt;vk, vj&gt;表示活动ai，则有e(i) &#x3D; ve(k)。 求所有活动的最迟发生时间I()； 若边&lt;vk, vj&gt;表示活动ai，则有l(i) &#x3D; vl(j) - Weight(vk, vj)。 求所有活动的时间余量d()。 时间余量d(i) &#x3D; l(i) - e(i)。 由此，我们求出了所有关键活动，他们的路径就是这个图的关键路径： 关键活动：a2、a5、a7； 关键路径：V1→V3→V4→V6。 （3）相关特性 若关键活动耗时增加，则整个工程的工期将增长； 缩短关键活动的时间，可以缩短整个工程的工期； 当缩短到一定程度时，关键活动可能会变成非关键活动。 可能有多条关键路径，只提高一条关键路径上的关键活动速度并不能缩短整个工程的工期，只有加快那些包括在所有关键路径上的关键活动才能达到缩短工期的目的。","categories":[{"name":"编程","slug":"编程","permalink":"http://kouqiang.space/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://kouqiang.space/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://kouqiang.space/tags/%E7%AE%97%E6%B3%95/"}],"author":"寇强"},{"title":"SVG入门基础_01","slug":"SVG入门基础","date":"2023-08-23T14:00:00.000Z","updated":"2023-08-23T17:22:11.818Z","comments":true,"path":"2023/08/23/SVG入门基础/","link":"","permalink":"http://kouqiang.space/2023/08/23/SVG%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/","excerpt":"","text":"SVG入门基础_01一、SVG介绍SVG 是使用 XML 来描述二维图形和绘图程序的语言，SVG指可伸缩矢量图形 (Scalable Vector Graphics)。 SVG 指可伸缩矢量图形 (Scalable Vector Graphics) SVG 用来定义用于网络的基于矢量的图形 SVG 使用 XML 格式定义图形 SVG 图像在放大或改变尺寸的情况下其图形质量不会有所损失 SVG 是万维网联盟的标准 SVG 与诸如 DOM 和 XSL 之类的 W3C 标准是一个整体 SVG 的历史和优势在 2003 年一月，SVG 1.1 被确立为 W3C 标准。 参与定义 SVG 的组织有：Sun公司（已被Oracle公司收购）、Adobe、苹果公司、IBM 以及柯达。 与其他图像格式相比，使用 SVG 的优势在于： SVG 可被非常多的工具读取和修改（比如记事本）。 SVG 与 JPEG 和 GIF 图像比起来，尺寸更小，且可压缩性更强。 SVG 是可伸缩的。 SVG 图像可在任何的分辨率下被高质量地打印。 SVG 可在图像质量不下降的情况下被放大。 SVG 图像中的文本是可选的，同时也是可搜索的（很适合制作地图）。 SVG 可以与 JavaScript 技术一起运行。 SVG 是开放的标准。 SVG 文件是纯粹的XML。 二、SVG基本属性 svg文件一般以.svg为后缀名（全部小写）。 坐标系统： 在一个SVG画布中也有自己的坐标系统，与CSS坐标系统的工作方式相同，即其坐标系统的y轴向下为正方向，x轴向右为正方向，父元素左上角为坐标原点。 SVG中属性的数值的默认单位： 默认以px为单位，代码中可写可不写，当然还可自定义cm、mm、ch、em、rem、pc等单位。 视窗和画布： 画布：SVG画布是无限大的，理论上我们也可以画无限大的东西。我们画的所有东西都在画布上。 视窗：我们在&lt;svg&gt;标签里面定义的大小width=&quot;&quot; height=&quot;&quot;即为视窗大小。 视窗和我们画的图像默认都往屏幕左上角对齐，如果图像内容大小超过了视窗大小，超出的部分就不会显示出来，这里涉及到&lt;svg&gt;标签的overflow属性，下文详细介绍。 123&lt;svg version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;100%&quot; height=&quot;100%&quot; style=&quot;outline: 1px solid black; overflow: visible&quot;&gt; &lt;!-- ...内容... --&gt;&lt;/svg&gt; 代码解析： SVG代码以 &lt;svg&gt; 元素开始，包括开启标签 &lt;svg&gt; 和关闭标签 &lt;/svg&gt; 。这是根元素。width和height属性可设置此SVG文档的宽度和高度。version属性可定义所使用的SVG版本，xmlns属性可定义SVG命名空间。 三、SVG基本形状元素（一）基本几何图形1、矩形&lt;rect&gt;123&lt;svg version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;300&quot; height=&quot;600&quot; style=&quot;outline: 1px solid black; overflow: hidden&quot;&gt; &lt;rect width=&quot;300px&quot; height=&quot;150px&quot; x=&quot;50px&quot; y=&quot;10px&quot; fill=&quot;gray&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;&lt;/svg&gt; 显示结果： 代码解析： &lt;rect /&gt;标签为单标签，定义矩形图形。 width、height属性定义自身的尺寸（宽和高），二者必须都有有效值，否则&lt;rect /&gt;定义失败！ x、y属性定义图形在x、y轴上的偏移距离。 fill属性定义图形内部的填充颜色，值与html所支持的相同，默认不输入或者输入值有误时为纯黑色。 rx、ry属性定义图形的圆角，二者只定义其中一个时，未定义的那个继承已定义的；若都定义了但属性值不同且不为0，则x与y方向上按实际数值显示*；若其中一个数值为0，则二者都不生效！","categories":[{"name":"前端","slug":"前端","permalink":"http://kouqiang.space/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"学习总结","slug":"学习总结","permalink":"http://kouqiang.space/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"},{"name":"前端","slug":"前端","permalink":"http://kouqiang.space/tags/%E5%89%8D%E7%AB%AF/"},{"name":"工具","slug":"工具","permalink":"http://kouqiang.space/tags/%E5%B7%A5%E5%85%B7/"},{"name":"SVG","slug":"SVG","permalink":"http://kouqiang.space/tags/SVG/"}],"author":"寇强"},{"title":"📷小寇的摄影入门笔记 - 1.相机与镜头","slug":"小寇的摄影笔记","date":"2023-07-16T16:00:00.000Z","updated":"2023-08-10T04:57:34.445Z","comments":true,"path":"2023/07/17/小寇的摄影笔记/","link":"","permalink":"http://kouqiang.space/2023/07/17/%E5%B0%8F%E5%AF%87%E7%9A%84%E6%91%84%E5%BD%B1%E7%AC%94%E8%AE%B0/","excerpt":"","text":"📷小寇的摄影入门笔记 - 1.相机与镜头这里讲的只是部分理论，该文章主要讲相机的使用原理而不对摄影理论知识做过多阐述（因为我也是个菜鸡） 一、相机（一）前言（二）单反相机的介绍1、单反分类——按取景方式区分 反镜头反光相机——即单反 所谓“单镜头”是指摄影曝光光路和取景光路共用一个镜头，不像旁轴相机或者双反相机那样取景光路有独立镜头。“反光”是指相机内一块平面反光镜将两个光路分开：取景时反光镜落下，将镜头的光线反射到五棱镜，再到取景窗；拍摄时反光镜快速抬起，光线可以照射到胶片或感光元件CMOS或CCD上。 微单 采用电子取景器（EVF）且具有数码单反功能 市面上有微单和单电两种称呼。 旁轴相机 旁轴相机，也称为旁轴取景式相机，由于取景光轴位于摄影镜头光轴旁边，而且彼此平行，因而取名“旁轴”相机。在整个照相机技术发展过程中，这种相机的品类是最为繁多的一种。 2、单反的结构与原理 3、单反相机的相关名词及参数佳能EOS 600D详细参数（[佳能EOS 600D_百度百科 (baidu.com)](https://baike.baidu.com/item/佳能EOS 600D&#x2F;5719189)）： 佳能EOS 600D是佳能（Canon）于2011年2月7日发布的一款单反相机产品。 佳能EOS 600D的机身尺寸约133.1×99.5×79.7毫米，重量约570克（CIPA方针），约515克（仅机身），有黑色一种颜色。 佳能EOS 600D采用一枚1800万像素CMOS传感器，搭配DIGIC 4处理器，采用了18-55毫米 IS II套机镜头，感光度范围是ISO100-6400，通过扩展之后最高感光度可以达到ISO12800。搭配有一块3英寸104万像素高清晰可旋转液晶屏，还配有一块1120毫安时的LP-E8电池。 是半画幅(APS-C)相机！ （1）相机成像传感器CCD和CMOS的区别首先，我们要知道什么叫CCD，什么叫CMOS。 CCD(Charged-CoupledDevice)，原意为电荷耩合组件。 CMOS(ComplemnentarvMetal-OxideSemniconduotor)，含义是互补金属氧化物半导体。 我们知道目前的数码相机所使用的CCD或CMOS，其像素从几百万至几千万。 二者差异： CCD技术成熟。成像技术好，被广泛应用在民用消费级，轻便入门级，准专业入门级的数码相机或摄像机上。 CCD制造工艺复杂，成本高，世界上只有少数几家电子产业巨头能生产。 CCD耗电量大，而且像素提升难度大。 CMOS与CCD比较，制造工艺简单，耗电量低，成本低，所以发展迅速。专业级单反等高端数码相机均使用CMOS。 CMOS也有一定缺点，即在频繁启动相机或摄像机时，CMOS会由多变的电流而产生热量，导致杂波、噪点较多而影响画质。所以，追求画面清晰度和高质量，CMOS相机尽量不用或少用连拍。 目前市面上绝大多数单反传感器都是CMOS的，很少有CCD的。 参考文章：CCD好，还是CMOS好？ - 知乎 (zhihu.com) （2）画幅画幅讲的是传感器尺寸，常见的单反有全画幅和半画幅，其他画幅不常见所以不做讨论。 全画幅：Full frame,也就是我们常说的全幅。全画幅的传感器尺寸相当于我们在早些年用的胶片相机里安装的胶卷的尺寸，是非常实用和热门的画幅尺寸。在这个领域，也是各个厂商竞争的很激烈的一个领域。 APS画幅：Advanced Photo System。 APS画幅有三种尺寸：H型，30.3×16.6mm，长宽比为16:9；C型：24.9×16.6mm，长宽比为3:2；P型：30.3×10.1mm，长宽比为3:1。 APS-C画幅指的就是数码相机的CCD(CMOS)的尺寸与APS的C型画幅大小相仿，大约在25mmX17mm左右。差不多是全画幅CCD(CMOS)面积的一半，也称半幅机。大多数的数码单反相机是APS-C画幅的。但尺寸相仿但也小有出入。一般尼康的最大，它的全画幅比例系数是X1.5；佳能的稍稍的小一点点，它的全画幅比例系数是X1.6；适马的最小，它的全画幅比例系数是X1.7。 平时我们见到的多数相对便宜一些的单反都是半画幅（APS-C）的，大厂官方报价在三四千到七八千不等，新手入门完全够用。而全画幅的就很专业也更贵了，一般都在一万块以上。 参考文章：了解相机画幅 这一篇就够了 - 知乎 (zhihu.com) 4、曝光三要素——感光度、快门、光圈（1）感光度ISOISO即感光度，其概念是从传统胶片感光度引入的，是指用一个具体的感光度数值来表示感光元件对光线的敏感程度。即在其他条件相同的情况下，感光度数值越高，单位时间内，相机的感光元件感光越充分，也就是画面亮度就越高。 单反都有个原生感光度和扩展感光度： 原生感光度：就是我们平时拍照可以简单调整的感光度范围，一般在100~6400，有些相机可能更高。 扩展感光度：相机在基础感光度的基础上，相机用自己的内置算法强行提亮或者是压暗画面得到的结果。一般在相机设置里可以打开或关闭。 那平时我们如何使用呢？选择哪种呢？ 实际上，每个传感器，也就是CMOS，其实都有且仅有一个基本感光度，就是原生最低感光度，一般就是我们使用的ISO&#x3D;100。传感器的开发人员会将这个基本感光度下的噪点控制到最低，而其他感光度则都是信号增益放大的结果。由于都没有像基准感光度似的做过优化，所以ISO值越大噪点就会越来越多。 而扩展感光度，则不仅仅是信号增益放大的结果， 还要经过相机中内置软件的计算，来模拟更高或更低感光度的效果。多一层处理，光信号转变为物理信号的过程中就必然会有损失，那么画质也就会降低。 所以原生ISO的范围越大，说明感光元件的性能越强，而扩展ISO的范围则只代表在图片宽容度允许的情况下，相机允许的最大调整范围。 因此，我们拍照时一般都调整ISO&#x3D;100，这样画质是最优的。除非特殊情景，否则都用不到扩展感光度。 参考文章：原生ISO、扩展ISO、自动ISO，这些ISO理论要玩摄影你得懂 (sohu.com) （2）快门 快门的原理 快门主要是用来控制光线照射在感光元件上的时间(或控制光线感光在感光元件上的时间)，也就是控制曝光时间的重要元件。每当快门帘开启时，光线便可以照射于感光元件上，使感光元件受光并显影，而当快门帘关闭时，光线自然就无法进到感光元件上，进而完成一次曝光。所以快门时间越长，代表感光元件受光时间越长，照片就会越亮；反之则会越暗。 然而在摄影世界里，除非是拍摄特殊慢快门的主题，不然比较少会使用1 秒、2秒、5秒这种单位，比较常见的反而是1&#x2F; 30 秒 , 1&#x2F; 60 秒, 1&#x2F; 125 秒, 1&#x2F; 500 秒这类的快门速度。也因此相机上大多会以30, 60, 125, 500的数字来显示快门速度，而接近1 秒则会以1&#x2F;3 “、1&#x2F;2 “、1 “ , 2 “ , 5 “的方式表达。所以请务必注意，相机显示30，代表快门速度为1&#x2F;30 秒，而非30秒(30”)。 机械快门、电子快门与电子前帘快门 机械快门 我们用取景框取景模式拍的照片使用的就是机械快门，拍照时会听到快门的咔嗒声。 其工作原理很简单，传感器始终处于工作状态，当用户按下快门按钮时，快门帘的第一个动作（前帘）会迅速挡住影像传感器，然后又迅速打开，这样来自镜头的光线就可以照射到影像传感器上，迅速将其曝光。当首次曝光完成时，快门帘的第二个动作（后帘）会再次挡住影像传感器并保持关闭状态。 优点：适合长时间曝光；在所有照明条件下的表现都很稳定；适合拍摄快速移动的主体和平移画面。 缺点：不能静音拍摄；最高快门速度通常比电子快门慢，大多为1&#x2F;4000秒或1&#x2F;8000秒；机身震动可能会影响成像效果；有些单反在该模式下不能调整照片长宽比例。 电子快门 我们用屏幕实时取景模式拍照片时使用的就是电子快门。 电子快门是通过打开和关闭相机影像传感器来完成曝光的。通常，电子快门通过逐行读取影像传感器的数据来完成曝光。 优点：可静音拍摄；无快门震动；快门速度上限不受机械动作限制，目前的最高速度可达1&#x2F;16000秒或1&#x2F;32000秒；连拍速度比机械快门和电子前帘快门更高。 缺点：闪烁灯光下容易出现斑马条纹；可能导致快速移动的主体出现变形失真（果冻现象）；与闪光灯的高速同步有较高的技术要求，旧款机型大多无法实现高速同步，新机型也有同步快门速度限制；长时间曝光容易导致发热量剧增，且部分机型甚至有曝光时间不得超过一秒的限制。 电子前帘快门 电子前帘快门是机械快门和电子快门的混合体，因此也有厂商将其成为“混合快门”。它是通过相机内置的程序控制机械快门和电子快门的动作，各取其优点组合而成。在这个模式下，“快门”的前帘和后帘开合动作，将分别由电子快门（前帘）和机械快门（后帘）来完成，可以避免机身震动，减轻避免果冻现象和闪烁光源造成的“斑马条纹”现象。 优点：有效避免快门震动；比全机械快门更安静；避免果冻现象；有效减轻了斑马条纹现象；在所有照明条件下表现都很稳定。 缺点：不能完全静音（比纯机械快门的噪声低）；不能与闪光灯一起使用；最高快门速度限制较多，大多数机型的上限为1&#x2F;2000秒。 我们如何选择用哪种快门？ 其实日常拍摄中二者没有多少区别，用哪种都行，主要是在特定场景下怕拍出来的东西失真所以才切换快门方式。拍摄场景中有人造光源的话建议用机械快门，如果是纪实摄影推荐使用电子快门因为是静音的不会打扰到别人。 当然只是建议，一般也不会有很严重的失真，你喜欢用取景框取景或屏幕取景在于自己。 参考文章：详解相机的机械快门、电子快门和电子前帘快门 (baidu.com) 我们拍照时如何选择快门时长？ 上图我们可以了解到，在其它参数设置合适的情况下，快门时间越短，越适合拍高速运动的物体，快门时间越长，拍到运动的物体越容易带拖影。 一般而言若我们想定格某个瞬间，比如为了拍清晰高速运动的物体，我们会采用较快的快门速度(如1&#x2F;500秒或更快)；如果我们想呈现具有动态感的画面，我们可以放慢快门速度(如1秒或更慢)。 具体选择什么样的快门没有标准答案，取决于你的拍摄对象和个人风格。 安全快门 什么是安全快门？安全快门就是指：在手持相机情况下，可以拍出清晰不晃动的最低快门速度要求，基本上快门速度只要高过它，正常站立情况下都能拍出清晰的照片。那么安全快门速度究竟是多少呢？ 安全快门 &#x3D; 1 &#x2F; 焦距(mm)举例：使用85mm焦段拍摄，安全快门为1&#x2F;85秒，所以至少使用1&#x2F;85的快门速度；使用50mm，则至少使用1&#x2F;50的快门速度。特例：安全快门最好不要低于1&#x2F;30秒，若今天使用16mm或24mm，虽然安全快门为1&#x2F;16和1&#x2F;24 ，但建议仍以1&#x2F;30作为最低快门速度，当然手很稳的生物除外。 什么是B快门？ 当大家在做慢快门摄影的时候会发现，快门时间大多只有整数的(如1”, 2”, 5”, 10”, 15”, 20”, 25”, 30”)，且最高就只有30”，今天如果我想要自己曝一个7”、或是我想要曝光多久就曝多久的话，那我该怎么办？没错，就是利用B快门。 所谓B快门是源自英文Bulb，当选用B快门的时候，相机的曝光就完全经由手动，快门按下时间有多长，曝光的时间就有多长，爱曝多久都是自己决定，且不会有最高秒数限制，因此在许多摄影题材都相当好用(如夜景、烟火、星空、晨昏等等)。 怎么知道自己相机有没有B快门呢？一般而言只要看看相机的转盘上有没有B这个代号、或是M模式中将快门调到比30”更慢，看看是否会显示B的字样就知道了。若还是不确定的话，可以直接去官网找相机型号，之后点选「产品规格」去找快门这栏，就能得知是否支持B快门。 参考文章：摄影基础入门：5分钟看懂快门速度是什么？快门越快越好？ - 知乎 (zhihu.com) （3）光圈 相机的成像原理都是小孔成像，而调整光圈大小就是调整这个孔的大小。 一般而言我们会用f&#x2F;值来表示光圈的大小，比如说f&#x2F;1 , f&#x2F;1.4 , f&#x2F;2 , f&#x2F;2.8 , f&#x2F;4 , f&#x2F;5.6 , f&#x2F;8 , f&#x2F;11 , f&#x2F;16 , f&#x2F;22。数值越大，光圈孔径越小！ f值越大，进光量越少，画面越暗。 当然我们调整光圈大小可不是为了调整画面的明暗，而是为了调整景深！ 什么是景深 我们在日常生活中，比如眼睛看街道上十几米外的东西时，离眼睛很近和很远的物体会变模糊，那么景深就是实现的这种对前景物体和背景物体的模糊效果。 参考下图： 景深与光圈大小的关系： f值越小，景深越浅，前后景相对越模糊。 f值越大，景深越深，前后景相对越清晰。 那么什么情况下我们需要调整光圈和景深呢？ 一般来讲，我们拍摄风光景色等大场景时就需要使用大f值&#x2F;小光圈&#x2F;较深的景深。 拍摄人像、产品等精致的小场景时需要用到小f值&#x2F;大光圈&#x2F;较浅的景深来虚化前后景以突出被拍摄物体的精致感。 PS：这里讲的只是部分理论，该文章主要讲相机的使用原理而不对摄影理论知识做过多阐述。（因为我也是个菜鸡） 文章参考：曝光三要素：光圈、快门、ISO感光度 | 新手摄影入门指南 - 知乎 (zhihu.com) 二、镜头（一）镜头的购买我们在购买相机的时候，一般卖家都会给出这么个说法：你选择仅购买机身还是套机？ 仅购买机身就是指不要镜头，只要机子，这样子花费少，但是没有镜头肯定拍不了照！所以自己没有镜头的小白肯定还要买镜头，预算少可以买官方推荐的套机镜头（一般都挺实用），预算多可以自己按需购买其他镜头。 套机就是指顺便买一个或多个镜头（官方推荐的搭配），机身有了镜头才能拍照，这样子肯定花费多出一个镜头的钱。 去哪儿购买镜头？ 相机厂商都有自己生产出售适配自家产品的镜头，型号多完全兼容，保证质量的同时价格也高。 有很多第三方专门生产镜头的厂商，比如日本三大品牌：腾龙Tamron、适马Sigma、图丽Tokina； （二）镜头的分类及特性（三）镜头的参数详解","categories":[{"name":"摄影","slug":"摄影","permalink":"http://kouqiang.space/categories/%E6%91%84%E5%BD%B1/"}],"tags":[{"name":"学习总结","slug":"学习总结","permalink":"http://kouqiang.space/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"},{"name":"摄影","slug":"摄影","permalink":"http://kouqiang.space/tags/%E6%91%84%E5%BD%B1/"},{"name":"笔记","slug":"笔记","permalink":"http://kouqiang.space/tags/%E7%AC%94%E8%AE%B0/"}],"author":"寇强"},{"title":"专业外语电子笔记","slug":"专业外语电子笔记","date":"2023-04-20T13:10:00.000Z","updated":"2023-05-10T03:33:31.435Z","comments":true,"path":"2023/04/20/专业外语电子笔记/","link":"","permalink":"http://kouqiang.space/2023/04/20/%E4%B8%93%E4%B8%9A%E5%A4%96%E8%AF%AD%E7%94%B5%E5%AD%90%E7%AC%94%E8%AE%B0/","excerpt":"","text":"专业外语电子笔记有关Wittkowers - “Architectural Principles in the Age of Humanism”的内容梗概 一、建筑与人类主义的关系 人类主义是一种反对中世纪神权主义的理念，它把人放在一个建构的世界中心，认为人是独立自主的个体，有自己的思想和信仰。建筑是人类生活的重要组成部分，人类主义理念影响了建筑设计，建筑成为了表现人类多样性和文化传统的载体。 二、理性与美学的平衡 文艺复兴时期，人类主义思想强调理性和智慧的重要性，但同时也意识到富有美学感染力的建筑对人类情感的重要性。建筑师们开始注重建筑的形式和比例，建筑通过设计成为了一种卓越的艺术形式。 三、建筑与空间的关系 人类主义吸取了古罗马的建筑风格，追求大型和开阔的建筑空间。建筑师们借鉴了古希腊的神殿设计，把高大的柱子和梁带作为支撑结构，以创造高大的空间。建筑中开放的空间使人类活动在其中，成为这个时代艺术创作的主旨。 四、归纳与分类 人类主义的思想重视知识的整合和系统化，建筑的设计也受到了相应的影响。在建筑设计中，人类主义要求从设计中归纳出基于智慧和知识的分类体系，以帮助人类更好地理解和利用建筑空间。 五、神权与人类的关系 与中世纪的神权主义不同，人类主义认为人类是自由和独特的个体，有自己的思想和信仰。因此，建筑在设计中不再是一个象征神圣权力的表现形式，而是一个展示人类独特性的载体。 小组部分01.对建筑师的影响 As we’ll see, this is a book that had an extraordinary impact on two distinct groups. The first was the Renaissance architectural historian. This book offered a new approach to the way we understand the architecture of the 15th and the 16th century in Italy. The other group was the modernist architect. It is strange to think that a book on the Renaissance might have an impact on modernist thinking,but this book revolutionized our understanding of geometry,modular pattern, and the ways in which diagrams can be used to explain the work of the architect. 正如我们将看到的，这本书对两个不同的群体产生了非凡的影响： 第一是文艺复兴时期的建筑历史学家。这本书为我们理解意大利15世纪和16世纪的建筑提供了一种新的方法。另一个是现代主义建筑师。奇怪的是，一本关于文艺复兴的书可能会对现代主义思想产生影响，但这本书彻底改变了我们对几何学、模块化模式以及用图表解释建筑师作品的方式的理解。 The first is that it was highly invested in an abstract and intellectual approach to the Renaissance. It underscored the rise of theory in the 15th and 16th century, and the ways in which the works of a given architect might offer a coherent kind of investigation into a set of problems surrounding perspective, proportion, geometry, and the advent of ideal form and architecture.This highly abstract approach had repercussions. 首先，它高度投入了对文艺复兴的抽象和理智的方法。 它强调了理论在15世纪和16世纪的兴起，以及特定建筑师的作品可以为围绕透视、比例、几何以及理想形式和建筑的出现的一系列问题提供连贯的研究。这种高度抽象的方法引起了反响 02.维特科夫的假设与范式 What it means, ironically, is that Wittkower was absolutely disinvested from the complexities of history. He was not interested in the cultural context out of which architecture arose.He does not delve into religious history, the monastic orders, particular events that might have marked the Renaissance. Instead, he steps back to analyze architectural form as an autonomous project. 具有讽刺意味的是，这意味着维特科夫完全被剥夺了历史的复杂性，他对建筑产生的文化背景不做考虑。他没有深入研究宗教历史、修道院秩序，以及可能标志着文艺复兴的特殊事件，相反，他退后一步，将建筑形式作为一个自主项目进行分析。 At the heart of this approach is the notion of the paradigm. The word paradigm comes from the Greek. It means both pattern and to show side-by-side.The assumption on Wittkower’s part is that Renaissance architects were after such paradigms, that they sought and developed them, and ultimately, through that process, were after the core principles of architectural form. 这种方法的核心是范式的概念。范式这个词来自希腊语，它意味着图案和并排显示。维特科夫的假设是，文艺复兴时期的建筑师追求的是这样的范式，他们寻求并发展它们，最终，通过这个过程，追求的是建筑形式的核心原则。 By the same token, what’s also true is that Wittkower’s very own approach became paradigmatic.In other words, it offered a standard means of approaching the historical past, of interpreting the past, and even of generating form itself. 同样正确的是，Wittkower自己的方法成为了典范。换句话说，它提供了一种标准的方法来接近历史的过去，解释过去，甚至生成形式本身。 03.维特科夫认为绝对重要的问题 Furthermore, the book is broken up into four chapters that deal with issues that Wittkower took to be absolutely fundamental. 此外，这本书分为四章，讨论了维特科夫认为绝对重要的问题。 First, there is the question of symbolism. In other words, how buildings mean. 首先，是象征主义的问题。换句话说，建筑物是什么意思。 The second chapter looks at the problem of the appropriation of form.In other words, how did architects look back to the deep past, and in particular, to the pagan classical past, seize that tradition, reinterpret in syntax and reinvent classicism as a system. 第二章是形式侵占问题。换言之，建筑师是如何回顾过去的，尤其是异教古典主义的过去——抓住这一传统在语法上重新解释，并将古典主义重新打造为一个系统。 Third, the question of typology and the development of building types.Are we talking about churches?Are we talking about villas?Are we talking about institutional buildings? 第三章：类型学问题和建筑类型的发展。 我们说的是教堂吗？我们说的是别墅吗？我们说的是机构建筑吗？ And lastly, the question of proportion. The geometric ideal. The question of measure. 最后，比例问题。几何理想、衡量的问题。 04.维特科夫对建筑深层结构的探索 To read Wittkower is to see a process of mental abstraction at work. In other words, what Wittkower was after wasn’t the discrete cultural meaning of a particular building in a particular context. He’s not after giving us some real and robust sense of the 16th century world view. Instead, he wants to bring together the classical kit of parts that make a building formalize itself, that allow it to transform into the buildings we still have today. 读维特考尔的作品，就是看到一个精神抽象的过程在起作用。换句话说，Wittkower所追求的并不是特定环境中特定建筑的离散文化意义。他并没有给我们带来16世纪世界观的真实而有力的感觉。相反，他希望将经典的部件组合在一起，使建筑形式化，使其能够转变为我们今天仍然拥有的建筑。 In other words, Wittkower is looking for a kind of deep structure,we might call it, that organizes architectural form.He’s going after the identification of their component parts.What is a portico?What is a column?This is why ultimately, he relies on diagrams to explain architecture. 换句话说，Wittkower正在寻找一种深层结构，我们可以称之为，组织建筑形式。他在寻找他们的组成部分：什么是门廊？什么是专栏？这就是最终他依赖图表来解释架构的原因。 He looks through the complex appearance of a building like this in all its three-dimensionality and distills it into its most basic elements through plan, sometimes elevation.In other words, he develops a syntax, a language, a form. 他在所有的三维空间中观察像这样的建筑的复杂外观，并通过平面图（有时是立面图）将其提炼为最基本的元素。换句话说 他发展了一种语法、一种语言、一种形式。 更多内容请查看专业外语电子笔记 - 寇强的个人空间 (kouqiang.space)","categories":[{"name":"建筑学","slug":"建筑学","permalink":"http://kouqiang.space/categories/%E5%BB%BA%E7%AD%91%E5%AD%A6/"}],"tags":[{"name":"建筑学","slug":"建筑学","permalink":"http://kouqiang.space/tags/%E5%BB%BA%E7%AD%91%E5%AD%A6/"},{"name":"笔记","slug":"笔记","permalink":"http://kouqiang.space/tags/%E7%AC%94%E8%AE%B0/"}],"author":"寇强"},{"title":"下载 bilibili 字幕文件","slug":"下载BILI字幕文件","date":"2023-04-06T23:25:00.000Z","updated":"2023-05-13T03:35:06.558Z","comments":true,"path":"2023/04/07/下载BILI字幕文件/","link":"","permalink":"http://kouqiang.space/2023/04/07/%E4%B8%8B%E8%BD%BDBILI%E5%AD%97%E5%B9%95%E6%96%87%E4%BB%B6/","excerpt":"","text":"下载 bilibili 字幕文件打开一个 bilibili 网页，鼠标右键，然后点击 “检查” 选项切换到 “Network”，然后重新打开此网页 在搜索栏中输入json 进行过滤，然后可以看到一个 后缀为.json 的文件，即为该视频对应的字幕文件。 提取字幕文件中的文本文字首先将上述字幕文件下载到本地，然后执行如下代码，提取字幕文件中的文本内容。 123456789101112import jsonjson_path = &#x27;D:/System/Desktop/001.json&#x27;# 读取 json 文件with open(json_path, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as load_f: content = json.load(load_f) res = &#x27;&#x27; body = content[&#x27;body&#x27;] for data in body: res = res + data[&#x27;content&#x27;] + &#x27;，&#x27; print(res) ————————————————版权声明：本文为CSDN博主「悄悄地努力」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/weixin_46034990/article/details/127492282","categories":[{"name":"其他工具","slug":"其他工具","permalink":"http://kouqiang.space/categories/%E5%85%B6%E4%BB%96%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://kouqiang.space/tags/%E5%B7%A5%E5%85%B7/"},{"name":"bilibili","slug":"bilibili","permalink":"http://kouqiang.space/tags/bilibili/"},{"name":"python","slug":"python","permalink":"http://kouqiang.space/tags/python/"}],"author":"寇强"},{"title":"🔑数据结构_第一章：绪论","slug":"🔑数据结构_第一章：绪论","date":"2023-03-11T12:00:00.000Z","updated":"2024-05-13T09:26:57.145Z","comments":true,"path":"2023/03/11/🔑数据结构_第一章：绪论/","link":"","permalink":"http://kouqiang.space/2023/03/11/%F0%9F%94%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E7%BB%AA%E8%AE%BA/","excerpt":"","text":"🔑数据结构_第一章：绪论2023.3.11开始 第一章、绪论（一）什么是数据结构 数据结构三要素： 逻辑结构 四种常见的逻辑结构： 集合（408考纲早已去除，此处不做讨论） 线性结构（二、三章）——一对一 树状结构（第四章）——一对多 图结构&#x2F;网结构（第五章）——多对多 数据的运算 针对于某种逻辑结构，结合实际需求，定义基本运算。 增 删 查 物理结构 数据的物理存储结构有以下四种： 顺序存储：逻辑顺序和物理顺序都是线性结构。 链式存储：逻辑上相邻的元素在物理位置上也可以不相邻。 索引存储 散列存储（第六章） 若采用顺序存储，则各个数据元素在物理空间上必须是连续的；若采用非顺序存储，则各个数据元素在物理空间上可以是离散的。 数据的存储结构会影响存储空间分配的方便程度，和系统对数据的运算速度。 运算的定义是针对逻辑结构的，指出运算的功能。 运算的实现是针对存储结构的，指出运算的具体操作步骤。 补充： 数据类型 是一个值的集合和定义在此集合上的一组操作的总称。 原子类型：其值不可再分的数据类型。 如bool类型、int类型等。 结构类型：其值可以在分解成若干分量的数据类型。 如结构体等。 抽象数据类型ADT（Abstract Data Type） 是抽象数据的组织和与之相关的操作。 （二）算法的基本概念1、什么是算法程序 &#x3D; 数据结构 + 算法 数据结构：如何用数据正确的描述现实世界的问题，并存入计算机。 算法：如何高效地处理这些数据，以解决实际问题。 算法(Algorithm)是对特定问题求解步骤的一种描述，它是指令的有限序列，其中的每条指令表示一个或多个操作。 2、算法的五个特性 有穷性： 一个算法必须能在执行有穷步之后结束，且每一步都可在有穷时间内完成。 注：算法必须是有穷的，二程序可以是无穷的。 确定性： 算法中每条指令必须具有确切的含义，对于相同的输入只能得到相同的输出。 可行性： 算法中描述的操作都可以通过已经实现的基本运算执行有限次来实现。 输入： 一个算法可以有零个或多个输入，这些输入取自于某个特定的对象的集合。 输出： 一个算法有一个或多个输出，这些输出是与输入有着某种特定关系的量。 只要以上任何一个特性不满足，那就不能称之为一个算法！ 3、“好”算法的特质 正确性： 算法应能够正确地解决求解问题。 可读性： 算法应具有良好的可读性，以帮助人们理解。 健壮性： 输入非法数据时，算法应能适当的做出反应和处理，而不会产生莫名其妙的输出和结果。 高效率与低存储量需求 即时间复杂度和空间复杂度都比较低。 （三）算法效率的度量1、时间复杂度 定义：算法中所有语句的频度之和记为T(n)，它是该算法问题规模n的函数，时间复杂度主要分析T(n)的数量级。 基本运算：最深层循环内的语句。基本运算的频度与T(n)同数量级，因此通常采用算法中的基本运算的频度f(n)来分析算法的时间复杂度。 因此，算法的时间复杂度记为：$$T(n) &#x3D; O(f(n))$$ 时间复杂度的计算（同样适用于空间复杂度） 只需关注最深层次的循环里的某一基本运算共进行了多少次即可！ 加法规则：只需保留最高阶数的那一个即可。 $$T(n) &#x3D; T_1 + T_2 &#x3D; O(f(n)) + O(g(n)) &#x3D; O(max(f(n),g(n)))$$ 乘法规则：$$T(n) &#x3D; T_1(n) \\times T_2(n) &#x3D; O(f(n)) \\times O(g(n)) &#x3D; O(f(n) \\times O(g(n))$$ 常见的渐近时间复杂度为：$$O(1)&lt;O(log_2n)&lt;O(n)&lt;O(nlog_2n)&lt;O(n^2)&lt;O(n^3)&lt;O(2^n)&lt;O(n!)&lt;O(n^n)$$ 巧计：常对幂指阶 例1： 123456789//算法一：逐步递增型爱你void loveYou(int n)&#123; //n为问题规模 int i = 1; //爱你的程度 while(i &lt;= n)&#123; i++; //每次+1 printf(&quot;I Love You %d&quot;, i); &#125; printf(&quot;I Love You More Than %d\\n&quot;, n);&#125; 该算法的时间复杂度为：$$T(n) &#x3D; 3n + 3 &#x3D; O(n)$$ 例2： 123456789101112//算法二：嵌套循环型爱你void loveYou(int n)&#123; int i = 1; while(i &lt;= n)&#123; i++; printf(&quot;I Love You %d\\n&quot;, i); for(int j = 1; j &lt;= n; j++)&#123; //while嵌套for循环 printf(&quot;I am an iron man\\n&quot;); &#125; &#125; printf(&quot;I Love You More Than%d\\n&quot;, n);&#125; 该算法的时间复杂度为：$$T(n) &#x3D; O(n) + O(n^2) &#x3D; O(n^2)$$ 例3： 123456789//算法三：指数递增型爱你void loveYou(int n)&#123; int i = 1; while(i &lt;= n)&#123; i *= 2; printf(&quot;I Love You %d\\n&quot;, i); &#125; printf(&quot;I Love You More Than%d\\n&quot;, n);&#125; 该算法的时间复杂度为：$$T(n) &#x3D; O(log_2n)$$ 三种复杂度： 最坏时间复杂度：有参考价值 平均时间复杂度：有参考价值 最好时间复杂度：基本没有参考价值 2、空间复杂度 算法的空间复杂度S(n)定义为运行该算法所耗费的内存空间，它是问题规模n的函数，记为：$$S(n) &#x3D; O(g(n))$$ 程序运行时，程序代码被放到内存中，程序运行所需的数据的空间也会被开辟出来，而它们占用空间的大小是固定的，与问题规模无关。 例1： 123456789//算法一：逐步递增型爱你void loveYou(int n)&#123; //n为问题规模 int i = 1; //爱你的程度 while(i &lt;= n)&#123; i++; //每次+1 printf(&quot;I Love You %d&quot;, i); &#125; printf(&quot;I Love You More Than %d\\n&quot;, n);&#125; 该算法中，无论问题规模怎么变，算法运行所需的内存空间都是固定的常量，该算法的空间复杂度为常数阶，数学表达为：$$S(n) &#x3D; O(1)$$ 如果一个算法的空间复杂度为常数阶的话，我们称这个算法可以原地工作——算法所需空间为常量，即：$$O(1)$$ 例2： 12345void test(int n)&#123; int flag[n]; //声明一个长度为n的数组 int i; //......&#125; 那么该算法的空间复杂度为：$$S(n) &#x3D; O(n)$$我们在谈论某个算法的空间复杂度时，只需关注它是什么数量级、什么阶数就可以了。 例3： 1234void test(int n)&#123; int flag[n][n]; //二维数组 int n;&#125; 那么该算法的空间复杂度为：$$S(n) &#x3D; O(n^2)$$ 例4： 12345void test(int n)&#123; int flag[n][n]; //二维数组 int flag[n]; int n;&#125; 那么该算法的空间复杂度为：$$S(n) &#x3D; O(n^2) + O(n) &#x3D; O(n^2)$$ 例5： 1234567891011121314//递归型爱你void loveYou(int i)&#123; int flag[n]; //...省略数组初始化代码 if(n &gt; 1)&#123; loveYou(n - 1); &#125; printf(&quot;I Love You %d\\n&quot;, n);&#125;int main()&#123; loveYou(5); return 0;&#125; 那么该算法的空间复杂度为：$$S(n) &#x3D; O(n^2)$$ 当函数发生递归调用时，空间复杂度就等于递归调用的深度。 补充： O(n)的数学表达：$$O(f(n)) &#x3D; \\lim_{x \\to \\infty} \\frac{T(n)}{F(n)} &#x3D; k$$","categories":[{"name":"编程","slug":"编程","permalink":"http://kouqiang.space/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://kouqiang.space/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://kouqiang.space/tags/%E7%AE%97%E6%B3%95/"}],"author":"寇强"},{"title":"🔑数据结构_第二章：线性表","slug":"🔑数据结构_第二章：线性表","date":"2023-03-11T12:00:00.000Z","updated":"2024-05-13T09:26:25.057Z","comments":true,"path":"2023/03/11/🔑数据结构_第二章：线性表/","link":"","permalink":"http://kouqiang.space/2023/03/11/%F0%9F%94%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8/","excerpt":"","text":"🔑数据结构_第二章：线性表第二章：线性表（一）线性表的定义、基本操作概述1、定义线性表是具有相同数据类型的n(n&gt;0)个数据元素的有限序列，其中n为表长，n为0时为空表。 若用L命名线性表，则其一般表示为：$$L &#x3D; (a_1, a_2, …, a_i, a_{i+1}, …, a_n)$$ a1为表头元素，an为表尾元素。 除第一个元素外的每个元素都只有一个直接前驱，除最后一个元素外的每个元素都只有一个直接后驱。 2、线性表的特点 表中的元素个数有限。 表中元素具有逻辑上的顺序性，表中元素有其先后次序。 表中元素每个都是数据元素，每个元素都是单个元素。 表中元素的数据类型都相同，每个元素占有相同大小的存储空间。 表中元素具有抽象性，即仅讨论元素间的逻辑关系，而不考虑元素究竟表示什么内容。 注：线性表是一种逻辑结构，表示元素之间一对一的相邻关系。而顺序表和链表是指存储结构，不要混淆！ 2、可以进行的基本操作①改 创建&#x2F;初始化线性表： InitList(&amp;L)：构造一个空的线性表。 销毁&#x2F;删除线性表： DestroyList(&amp;L)：销毁表并释放其内存空间。 *更改某个元素的值： 可自定义。 ②查 按值查找元素： LocateElem(L,e)：在表L中查找具有给定关键字值的元素。 按位查找元素： GetElem(L,i)：获取表L中第第i个元素的值。 求表长： Length(L)：返回表L中元素的个数。 判空操作： Empty(L)：若L为空表，返回true，否则返回false。 ③增 插入元素： ListInsert(&amp;L,i,e)：在表L的第i个位序插入元素e。（前插） 特殊情况： 在表第一个结点之前插入。 在表末尾插入。 ④删 删除元素： ListDelete(&amp;L,i,&amp;e)：删除表L的第i个元素，并用e返回被删元素的值！ 特殊情况 删除第一个结点 删除末尾结点 *注：①基本操作的实现取决于采取哪种存储结构，存储结构不同，算法的实现也不同。②符号&amp;代表C++语言中的引用，在C语言中用指针也可以达到同样的效果。 （二）线性表的顺序表示——顺序表1、概念线性表描述了一种逻辑上的存储关系，而我们用顺序表可以在物理层面实现这种存储方式。所以，顺序表就是逻辑顺序与物理顺序都相同的一种实现线性表的方式。 也是一种随机存储的存储结构。 通常用高级程序设计语言中的数组来描述。 2、特点： 随机访问。 存储密度高，每个节点只存储数据元素。 逻辑上相邻的元素物理上也相邻，所以插入和删除操作可能需要移动大量元素。 3、基本操作（1）插入向表中第i个位置插入元素e： 123//①判断输入值i是否合法，不合法则返回错误信息终止程序运行，合法则下一步；//②找到第i个位置的元素，将该元素和它所有后继，由末尾第一个开始依次向后移动一个元素位置；//③空出来的位置存放e，运行结束。 最好情况：在表尾插入元素，不执行移动，时间复杂度为O(1)。 最坏情况：在表头插入元素，所有元素都被移动一次，时间复杂度为O(n)。 平均时间复杂度：O(n)。 （2）删除删除表中第i个位置的元素，并返回删掉元素的内容： 123//①判断输入值i是否合法，不合法则返回错误信息终止程序运行，合法则下一步；//②找到第i个位置的元素，将其内容赋值给另一变量m，然后删掉该元素，并将该元素的所有后继，由第一个开始依次向前移动一个元素位置；//③返回m，运行结束。 最好情况：删除表尾元素，不执行移动，时间复杂度为O(1)。 最坏情况：删除表头元素，所有元素都被移动一次，时间复杂度为O(n)。 平均时间复杂度：O(n)。 （3）按值查找（顺序查找）for循环遍历，挨个比较值，返回目标元素索引值。 最好情况：查找的元素就在表头，仅需比较一次，时间复杂度为O(1)。 最坏情况：查找的元素在末尾或不存在，所有元素都要比较一次，时间复杂度为O(n)。 平均时间复杂度：O(2)。 4、代码实现（1）顺序表的实现——静态分配123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include &lt;cstdio&gt;//顺序表的静态实现#define MaxSize 10 //定义全局最大长度typedef struct&#123; //定义该结构体为一个顺序表 //此处的数组类型完全可以根据具体需求自定义 int data[MaxSize]; //手动定义顺序表的数据域，定义为数组，数组大小不能更改，所以该顺序表是静态分配 int length; //手动定义该顺序表的长度标识&#125;SqList; //起别名为SqList//初始化顺序表：将L的n个结点初始化，初始化数据为mbool initList(SqList &amp;L,int n, int m)&#123; //判断输入是否合法 if(n &gt; MaxSize) return false; //for循环遍历数据与中所有内容赋值为0 for(int i = 0; i &lt; MaxSize; i++) L.data[i] = m; //设定顺序表的长度为n（此处的长度指的是存储了内容的有效长度） L.length = n;&#125;//给表L中第i个位置插入元素e（i为索引值），插入成功返回true，失败返回falsebool insertList(SqList &amp;L,int i,int e)&#123; //先判断i的值是否合法 if(i &lt; 0 || i &gt;= L.length)&#123; printf(&quot;输入i不合法！\\n&quot;); return false; &#125; printf(&quot;输入i合法！\\n&quot;); //再插入------------- L.length = 5, i = 4 for(int j = L.length-1; j &gt; i; j--)&#123; L.data[j] = L.data[j+1]; &#125; L.data[i] = e; L.length++; return true;&#125;//删除表L中第i个位置的元素并将删除元素的内容用e返回int deleteL(SqList &amp;L, int i)&#123; //先判断i的值是否合法 if(i &lt; 0 || i &gt;= L.length)&#123; printf(&quot;输入i不合法！\\n&quot;); return false; &#125; //再删除 int d = L.data[i]; for(int j = i; j &lt; L.length-1; j++)&#123; L.data[j] = L.data[j+1]; &#125; L.length--; return d;&#125;//按值查找：查询表L中值为8的结点（假设只有一个），查询到则返回其索引值，查不到则返回0int queryL(SqList L, int i)&#123; for(int j = 0; j &lt; L.length; j++)&#123; if(L.data[j] == i) return j+1; &#125; return 0;&#125;//按位查找：查找表L中第i（i是索引值）个元素，返回其内容int lookForWithI(SqList L, int i)&#123; //判断i值合法性 if(i &lt; 0 || i &gt;= L.length)&#123; printf(&quot;您输入的i值不合法！\\n&quot;); return 0; &#125; return L.data[i];&#125;int main()&#123; //实现一个静态分配的顺序表 SqList L; //初始化顺序表：将L的n个结点初始化，初始化数据为m bool initL = initList(L,5,4); printf(&quot;初始化是否成功？%d\\n&quot;,initL); printf(&quot;----------------------------------------\\n以下为初始化结果：\\n&quot;); for(int i = 0; i &lt; L.length; i++)&#123; printf(&quot;顺序表的第%d个结点数据：%d\\n&quot;,i+1,L.data[i]); &#125; printf(&quot;----------------------------------------\\n&quot;); //给表中内容赋值——给表L中第i个位置插入元素e（i为索引值！） bool inserL = insertList(L,4,8); printf(&quot;插入是否成功？%d\\n&quot;,inserL); printf(&quot;----------------------------------------\\n以下为插入结果：\\n&quot;); for(int i = 0; i &lt; L.length; i++)&#123; printf(&quot;顺序表的第%d个结点数据：%d\\n&quot;,i+1,L.data[i]); &#125; printf(&quot;----------------------------------------\\n&quot;); //删除表L中第i个元素（i为索引值！） int deleteD = deleteL(L, L.length-1); printf(&quot;删除元素为：%d\\n&quot;,deleteD); printf(&quot;----------------------------------------\\n以下为删除结果：\\n&quot;); for(int i = 0; i &lt; L.length; i++)&#123; printf(&quot;顺序表的第%d个结点数据：%d\\n&quot;,i+1,L.data[i]); &#125; //按值查找：查询表L中值为4的结点（假设只有一个），查询到则返回其“位序”，查不到则返回0 int q = NULL; q = queryL(L, 8); printf(&quot;----------------------------------------\\n以下为查询结果：\\n%d&quot;, q); //按位查找，返回内容 int r = lookForWithI(L, 4); printf(&quot;----------------------------------------\\n以下为按位查询结果：\\n%d\\n&quot;, r); return 0;&#125; （2）顺序表的实现——动态分配（三）线性表的链式表示——链表逻辑上相邻，但物理上不相邻的存储方式即为线性表的链式存储。 每个存放数据的结点中有数据域和指针域，除了存放原来的数据，还要存储指向直接后继或直接前驱或其他地方的指针。 链表有四种：单链表、双链表、循环单链表、循环双链表。 是一种非随机存储的存储结构。 优点 插入和删除操作不用移动元素，只需修改指针。 不需要大量连续的存储空间来存储数据。 缺点 失去了顺序表可随机存储的优点，因此查找某个特定结点时需要从头遍历依次查找。 附加指针域，有浪费空间的缺点。 1、单链表（1）单链表的创建 基于C的伪代码实现： 12345678910typedef struct LNode&#123; //定义单链表节点类型的结构体 ElemType data; //定义节点中的数据域 struct Node *next; //定义节点中的指针域&#125;LNode,LinkList; //所以这就是一个节点//说明：//用malloc在内存中任意一处申请一块LNode结构体大小的空间并将返回的void类型指针转化为该结构体类型的指针类型//使用别名LinkList创建一个LNode结构体类型的指针，接收在内存中新开辟空间的地址LinkList *p = (LNode *)malloc(sizeof(LNode));//这样子我们我们就新创建了一个新结点 自己手撸： 不带头结点： 123456789101112//声明结点结构体typedef struct LNode&#123; int data; struct LNode *L;&#125;LNode, L_Link;//声明头结点L_Link initL_withotHeadNode()&#123; L_Link L; L = NULL; return L;&#125; 带头结点： 12345678910111213141516171819//声明结点结构体typedef struct LNode&#123; int data; struct LNode *L;&#125;LNode, L_Link;//声明头结点L_Link initL_withHeadNode()&#123; L_Link L = (L_Link)malloc(sizeof(LNode)); //判断空间分配是否成功 if(L == NULL)&#123; printf(&quot;空间分配未完成，链表创建失败！&quot;); return L; &#125; //头结点的数据域和指针域都为空——NULL L-&gt;data = NULL; L-&gt;next = NULL; return L;&#125; 判断表是否为空： 123456789//不带头结点：bool emptyList_withoutHeadNode(L_Link L)&#123; return (L == NULL);&#125;//带头结点：bool emptyList_withHeadNode(L_Link L)&#123; return (L-&gt;next == NULL);&#125; （2）单链表的查找①按位查找②按值查找（3）单链表结点的插入①前插将数据e插入到表L的第i（位序）个位置（之前）： 思路1：新建指针p，通过循环遍历使p指向第i-1个结点的位置，然后将新节点插入到p之后。 不带头结点的表： 因为对于不带头结点的表，在表为空时插入第一个结点需要更改头指针，而在其它地方插入都相当于在某个特定节点之后插入，所以需要判断两种情况（以下代码中的第7行）： 1234567891011121314151617181920212223242526272829303132333435L_Link insertL_withoutHeadNode(L_Link L, int i, int e)&#123; //判断i值合法性 if(i &lt; 1)&#123; printf(&quot;i值不合法！&quot;); return L; &#125; //判断i是否为1，若为1，则创建第一个结点 if(i == 1)&#123; L_Link N1 = (L_Link)malloc(sizeof(LNode)); L = N1; N1-&gt;next = L;//使新结点指向原来L指向的节点，避免断链。若原本是空表，则N1-&gt;next为NULL，即尾结点N1指针域为空，合理！ N1-&gt;data = e; return L; &#125; //i值不为1，则遍历寻找第i-1个位序的结点再插入 L_Link p = L; for(int j = 1; j &lt; i-1; j++)&#123; //注：这里j的初始值为1，那么循环体就要比j = 0少运行一次，因此循环结束p就指向了i-1的位置 p = p-&gt;next; &#125; //以上循环体也可调用按位查找方法来替换： /* p = L_Link searchL_num(L, i-1); */ //此时指针p指向第i-1个结点 //再判断p值，值为空说明位置不存在 if(p == NULL)&#123; printf(&quot;i值不合法！&quot;); return L; &#125; L_Link N1 = (L_Link)malloc(sizeof(LNode)); N1-&gt;next = p-&gt;next; p-&gt;next = N1; N1-&gt;data = e; return L;&#125; 带头结点的表： 对于带头结点的表，不论在那儿插入都相当于在某个指定节点之后插入，所以不用分情况： 1234567891011121314151617181920212223L_Link insertL_withHeadNode(L_Link L, int i, int e)&#123; //判断i值合法性 if(i &lt; 1)&#123; printf(&quot;i值不合法！&quot;); return L; &#125; L_Link p = L; //挪指针 for(int j = 0; j &lt; i-1; j++)&#123; p = p-&gt;next; &#125; //此时p指向i-1个结点 //再判断指针位置是否存在 if(p == NULL)&#123; printf(&quot;i值不合法！&quot;); return L; &#125; L_Link N1 = (L_Link)malloc(sizeof(LNode)); N1-&gt;next = p-&gt;next; p-&gt;next = N1; N1-&gt;data = e; return L;&#125; 思路二：以上方法都需要先循环遍历到第i-1个结点的位置，甚是啰嗦！ 新思路：新节点直接插到第i个节点后面，然后交换新节点和第i个结点的数据，效果也是一样的： 1 ②后插将数据e插入到表L的第i个元素之后。 思路： 有关链表的增删改查所有手撸源码： 懒得整理了，就这样看吧： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300#include &lt;cstdio&gt;#include &lt;cstdlib&gt;//链表的代码实现//单链表//定义结构体为一个链表的结点，多个结构体（结点）连在一起就是链表typedef struct LNode&#123; int data; //每个节点都有数据域 struct LNode *next; //每个节点都有指向下个结点的指针&#125;LNode, *L_Link;//初始化单链表（不带头结点）bool initL_withoutHead(L_Link &amp;L)&#123; L = NULL; //空表，暂时还没有任何结点 return true;&#125;//初始化单链表（带头结点）bool initL_withHead(L_Link &amp;L)&#123; //分配一个头结点 L = (LNode *)malloc(sizeof(LNode)); //判断分配是否成功 if(L == NULL) return false; //头结点的指针域为空，即头节点后没有结点 L-&gt;next = NULL; //头结点的数据域也为空 L-&gt;data = NULL; return true ;&#125;//判断链表是否为空//不带头结点：bool emptyList_withoutHeadNode(L_Link L)&#123; return (L == NULL);&#125;//带头结点：bool emptyList_withHeadNode(L_Link L)&#123; return (L-&gt;next == NULL);&#125;//插入（带头结点的表）：在表L的第i（i是位序）个位置插入元素e（e是数据域内要存的内容而不是结点）L_Link insertL_withHeadNode(L_Link L, int i, int e)&#123; //判断i值合法性 if(i &lt; 1)&#123; printf(&quot;i值不合法！&quot;); return L; &#125; L_Link p = L; //挪指针 for(int j = 0; j &lt; i-1; j++)&#123; p = p-&gt;next; &#125; //此时p指向i-1个结点 //再判断指针位置是否存在 if(p == NULL)&#123; printf(&quot;i值不合法！&quot;); return L; &#125; L_Link N1 = (L_Link)malloc(sizeof(LNode)); N1-&gt;next = p-&gt;next; p-&gt;next = N1; N1-&gt;data = e; return L;&#125;//插入（已初始化的不带头结点的表）L_Link insertL_withoutHeadNode(L_Link L, int i, int e)&#123; //判断i值合法性 if(i &lt; 1)&#123; printf(&quot;i值不合法！&quot;); return L; &#125; //判断i是否为1，若为1，则创建第一个结点 if(i == 1)&#123; L_Link N1 = (L_Link)malloc(sizeof(LNode)); L = N1; N1-&gt;next = L;//使新结点指向原来L指向的节点，避免断链。若原本是空表，则N1-&gt;next为NULL，即尾结点N1指针域为空，合理！ N1-&gt;data = e; return L; &#125; //i值不为1，则遍历寻找第i个位序的结点再插入 L_Link p = L; for(int j = 1; j &lt; i-1; j++)&#123; //注：这里j的初始值为1，那么循环体就要比j = 0少运行一次，因此循环结束p就指向了i-1的位置 p = p-&gt;next; &#125; //以上循环体也可调用按位查找方法来替换： /* p = L_Link searchL_num(L, i-1); */ //此时指针p指向第i-1个结点 //再判断p值，值为空说明位置不存在 if(p == NULL)&#123; printf(&quot;i值不合法！&quot;); return L; &#125; L_Link N1 = (L_Link)malloc(sizeof(LNode)); N1-&gt;next = p-&gt;next; p-&gt;next = N1; N1-&gt;data = e; return L;&#125;//后插操作：在指定结点p的后面插入元素ebool insert_behind(L_Link &amp;P, int e)&#123; //判断位置合法性 if(P == NULL)&#123; printf(&quot;后插操作：结点p不合法！\\n&quot;); return false; &#125; L_Link s = (L_Link)malloc(sizeof(LNode)); s-&gt;data = e; s-&gt;next = P-&gt;next; P-&gt;next = s; return true;&#125;//前插操作01：在指定结点p的前面插入元素ebool insert_front_01()&#123; /* * 思路：传入头指针和p结点，依次遍历找到p和p之前结点的位序，再插入 * 缺点：时间复杂度为O(n)！费时费力，不建议使用！ */ return true;&#125;//前插操作02：在指定结点p的前面插入元素e（e为数据域的值而不是结点）bool insert_front_02(L_Link P, int e)&#123; /* * 思路二：先插到后面，再交换二者的值，结果等同于前插 * 优点：时间复杂度为O(1)！ */ //实现： //先插到后面： insert_behind(P, e); //再交换二者的值 P-&gt;next-&gt;data = P-&gt;data; P-&gt;data = e; return true;&#125;//前插操作03：在指定结点P的前面插入结点Sbool insert_front_03(L_Link P, L_Link S)&#123; //先插到后面： S-&gt;next = P-&gt;next; P-&gt;next = S; //再交换二者的值 int temp = P-&gt;data; P-&gt;data = S-&gt;data; S-&gt;data = temp; return true;&#125;//删除操作——按位序删除结点（只探讨带头结点的情况），并用e保存删除的数据bool deleteL(L_Link &amp;L, int i, int &amp;e)&#123; /* * 核心思路：将目标元素i的直接后继的数据域赋值给i，删除i的直接后继，效果也是删除了i位的结点 * 如果目标元素是最后一个元素，那就只能循环遍历 */ //先定位 int j = 0; L_Link p = L; while(j &lt;= i)&#123; p = p-&gt;next; j++; &#125; if(p == NULL)&#123; printf(&quot;删除操作：i值不合法！\\n&quot;); return false; &#125; //先判断目标结点是否是末尾结点 if(p-&gt;next == NULL)&#123; //是末尾节点，循环找p的直接前驱 L_Link p_pre = L; for(int jj = 0; jj &lt; j-1; jj++)&#123; p_pre = p_pre-&gt;next; &#125; e = p-&gt;data; p_pre-&gt;next = p-&gt;next; free(p); return true; &#125; //不是末尾节点，直接操作 e = p-&gt;data; p-&gt;data = p-&gt;next-&gt;data; p-&gt;next = p-&gt;next-&gt;next; free(p); return true;&#125;//单链表的查找（带头结点）//按位查找，返回第i个元素（i为位序）LNode* GetElemById(L_Link L, int i)&#123; //判断i值合法性 if(i &lt; 1)&#123; printf(&quot;按位查找：i值不合法！&quot;); return NULL; &#125; L_Link p; for(int j = 0; p!=NULL &amp;&amp; j&lt;i; j++)&#123; p = p-&gt;next; &#125; return p;&#125;//按值查找：找到数据域==e的结点并返回LNode* GetElemByData(L_Link L, int e)&#123; L_Link p = L-&gt;next; while(p!=NULL &amp;&amp; p-&gt;data!=e)&#123; p = p-&gt;next; &#125; return p;&#125;//求表长int L_length(L_Link L)&#123; int len = 0; L_Link p = L; while(p!=NULL)&#123; p = p-&gt;next; len++; &#125; return len;&#125;//单链表的建立——将一些数据转换为链表的形式储存//尾插法/* * 思路：创建链表的同时创建一个尾指针，新建结点到尾部时直接调用尾指针定位，方便又快捷 *///实现：LNode * creatList_inTail()&#123; //创建空表（带一个头结点） L_Link L = (L_Link)malloc(sizeof(LNode)); L-&gt;next = NULL; L-&gt;data = NULL; //创建尾指针 L_Link L_tail = L; //循环创建节点 int x = NULL; scanf(&quot;请输入要存储的数据（输入999完成输入）：%d&quot;, x); while(x!=999)&#123; L_Link q = (L_Link)malloc(sizeof(LNode)); q-&gt;data = x; q-&gt;next = NULL; L_tail-&gt;next = q; L_tail = q; //手动控制循环结束 scanf(&quot;请输入要存储的数据（输入999完成输入）：%d&quot;, x); &#125; return L;&#125;//头插法/* * 思路：把尾插法中的尾指针改成头指针 *///实现：L_Link creatList_inHead()&#123; L_Link L = (L_Link)malloc(sizeof(LNode)); L-&gt;next = NULL; L-&gt;data = NULL; int x = NULL; scanf(&quot;请输入要存储的数据（输入999完成输入）：%d&quot;, x); while(x!=999)&#123; L_Link q = (L_Link)malloc(sizeof(LNode)); q-&gt;data = x; q-&gt;next = L-&gt;next; L-&gt;next = q; scanf(&quot;请输入要存储的数据（输入999完成输入）：%d&quot;, x); &#125; return L;&#125;//！！！注！！！采用该方法创建的链表，其存储的数据是与我们输入的数据的顺序相反的，效果就是倒置！int main()&#123; //先声明一个要指向单链表第一个结点的指针L L_Link L; //初始化 //增删改查...... return 0;&#125; 单链表的判空：判断指针L是否为NULL，是则为空。 2、双链表双链表就是每个节点都带有两个指针（域）的结点，第一个指针prior指向前一个结点，第二个next指针指向直接后继结点。 解决了单链表无法逆向检索的缺点。 以下讨论的都是带头结点的链表： （1）初始化1234567891011//定义结点结构体typedef struct doubleList&#123; //一个数据域两个指针域 int data; struct doubleList *prior, *next;&#125;DList, D_Link;//初始化D_Link initDList()&#123; &#125; 3、循环单链表 4、循环双链表 5、静态链表 其实就是结构体数组，在内存中申请了一块连续的大空间，用来存放n个结构体结点。每个节点有数据域和游标&#x2F;指针域。 6、顺序表和链表的比较（1）逻辑结构 都属于线性表，都是线性结构。 （2）物理结构 顺序表 优点：支持随机存储，存储密度高。 缺点：大片连续存储空间分配不方便，改变容量不方便。 链表 优点：离散的小空间分配方便，改变容量也方便。 缺点：不可随机存取，存储密度低。 （3）基本操作总结对比增、删、改(创销)、查 增 删 改——创 改——销 查 时间复杂度 顺序表 定位到数组的目标序列，插入值，更改表长 定位到数组的目标序列，删除值，更改表长 ①静态分配：创建结构体，结构体属性有两个——数据域和长度标识，数据域为一个数组，用来存放数据；②动态分配： 逐项遍历数组元素并删除，最后更改表长标识 按值查找——逐项遍历对比；按位查找——随机访问 O(n)，主要来自移动元素 链表 先新建结点，再将节点插入其中。①单链表只能从头至尾循环遍历；②双链表可逆向遍历；③链表可任意遍历 先定位到目标节点，再清除数据域，然后更改前后指针，最后释放空间 先创建头指针，如果带头结点就把头指针指到头结点，不带头结点就把头指针指向第一个结点或自身 逐项遍历到尾结点，删除节点属性&#x2F;数据域，更改前后指针，释放空间 ①先判断是否是第一个结点或尾结点；②否，则循环遍历寻找目标 O(n)，主要来自于查找目标元素 （四）章节练习题","categories":[{"name":"编程","slug":"编程","permalink":"http://kouqiang.space/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://kouqiang.space/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://kouqiang.space/tags/%E7%AE%97%E6%B3%95/"}],"author":"寇强"},{"title":"🔑数据结构_第三章：栈、队列和数组","slug":"🔑数据结构_第三章：栈、队列和数组","date":"2023-03-11T12:00:00.000Z","updated":"2024-05-13T09:26:40.426Z","comments":true,"path":"2023/03/11/🔑数据结构_第三章：栈、队列和数组/","link":"","permalink":"http://kouqiang.space/2023/03/11/%F0%9F%94%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97%E5%92%8C%E6%95%B0%E7%BB%84/","excerpt":"","text":"🔑数据结构_第三章：栈、队列和数组第三章：栈、队列和数组（一）栈1、什么是栈 栈是只允许在一端进行插入或删除的线性表。 栈顶top：线性表允许进行插入删除的那一端。 栈底buttom：固定的，不允许插入和删除的那一端。 空栈：不含任何元素的空表。 特性：先进后出。 栈的数学性质：n个不同元素进栈，出栈元素不同的排列个数为：$$\\frac{1}{n+1}C^n_{2n}$$这个公式称为卡特兰数，可用数学归纳法证明，有兴趣的同学可以自己动手试试()。 2、栈的基本操作 InitStack(&amp;s)：初始化一个空栈。 StackEmpty(s)：判空，空则返回true，否则返回false。 Push(&amp;S, x)：进栈&#x2F;入栈，若栈S未满，则将x加入使之成为新栈项。 Pop(&amp;S, &amp;x)：出栈&#x2F;弹栈，若栈非空则弹出栈顶元素并用x返回。 GetTop(&amp;S, &amp;x)：读栈顶元素，若栈非空则用x返回栈顶元素。 DestroyStack(&amp;S)：销毁栈，并释放掉栈S所占用的存储空间。 在解答算法题时，若题干未做出函数限制，则可以直接使用这些基本的操作函数。 3、用顺序存储结构实现栈——顺序栈（1）栈的定义用一组地址连续的存储单元存放所有元素，同时附设一个指针top指示当前栈顶元素的位置。 12345#define Maxsize 50 //定义栈中元素的最大个数typedef struct&#123; ElementType data[Maxsize]; //用一个数组存放栈中元素 int top; //栈顶“指针”&#125; SqStack; 注：栈顶指针初始化时默认值可以是-1也可以是0，若为-1，那么data[top]就是用索引值来访问元素，若为0，那么data[top]就是用位序值来访问。 我们可以用data[top]访问当前栈顶元素，用data[Maxsize-1]定位到元素数组末尾（判满能用得到）。 （2）初始化操作初始化时设置S.top=-1，栈顶元素S.data[S.top]。 123void InitStack(SqStack &amp;S)&#123; S.top = -1;&#125; （3）判空123bool StackEmpty(SqStack S)&#123; return (S.top == -1);&#125; （4）进栈栈不满时，栈顶指针先+1，再将入栈元素放进去，最后返回操作成功与否。 12345678910111213bool Push(SqStack &amp;S, ElemType x)&#123; //先判栈满 if(S.top == Maxsize-1) return false; //不满再入栈 S.top++; S.data[S.top] = x; /* 大佬写的代码： S.data[++S.top] = x; */ return true;&#125; （5）出栈先判空，再执行。 先取栈顶元素值，再指针自减一。 123456bool Pop(SqStack &amp;S, ElemType x)&#123; if(S.top == -1) return false; x = S.data[S.top--]; return true;&#125; （6）读取栈顶元素先判栈空，再执行。 1234567//使用调用者的x记录读取元素的值：bool GetTop(SqStack S, ElemType &amp;x)&#123; if(S.top == Maxsize-1) return false; x = S.data[S.top]; return true;&#125; （7）*共享栈 就是把两个栈，栈顶对栈顶放在同一片连续的存储空间里（比如数组），各自的栈底都处在空间的两头，空间的占用是从两头向中间延伸，只有当整个存储空间存满时才会发生上溢。 存取数据的时间复杂度为O(1)，所以对存取效率没什么影响。 4、用链式存储结构实现栈——链栈 采用连式存储的栈，称为链栈。 优点是便于多个栈共享存储空间和提高效率，且不存在栈满上溢的情况。 通常采用单链表实现，并规定所有操作都是在单链表的表头进行的。 栈的链式存储类型可描述为： 1234typedef struct Linknode&#123; ElemType data; //数据域 struct Linknode *next; //指针域&#125; *LiStack; //栈类型定义 基本操作的实现与单链表基本相同，只不过链栈的插入删除等只在表头进行，因此代码实现需要的方法更少更简单而已。 同样，对于带头结点和不带头结点的链栈，实现起来同链表一样需要考虑头结点。 （二）队列1、队列的基本概念（1）定义 队列简称队，也是一种操作受限的线性表。它只允许在表的一端插入、另一端删除。 插入元素称为入队或进队，删除元素称为出队或离队。 特点：先进先出，后进后出，尾进头出。 以下代码演示中，我们用front表示队首指针，用rear表示队尾指针，并且规定，队首指针始终指向第一个数据域，队尾指针指向最后一个数据域的下一个位置，而初始化队空时，俩指针都指向初始位置（当然也可以规定尾指针rear指向最后一个元素本身的位置，怎么习惯怎么来）。 （2）常见基本操作 InitQueue(&amp;Q)：初始化队列，构造一个空队列。 QueueEmpty(Q)：判空。 EnQueue(&amp;Q, x)：入队，若队Q未满，则将x加入使之成为新队尾。 DeQueue(&amp;Q, &amp;x)：出队，若队非空，则将队头元素赋值给x，再将队头元素删除。 GetHead(Q, &amp;x)：读队头元素，若队非空，则将队头元素赋值给x。 2、队列的实现——顺序存储结构（1）普通顺序存储 定义 12345#define Maxsize 50 //定义最大个数typedef struct &#123; ElemType data[Maxsize]; //用数组存储元素 int front, rear; //定义队头指针和队尾指针&#125; SqQueue; 初始化 1Q.front = Q.rear = 0; 进队：若队不满，先送值到队尾元素，再将队尾指针+1。 出队：若队非空，先取队头元素值，再将队头指针+1。 出现的问题：俩指针挪到队尾就G了，前头的空间没使用，出现假溢出的情况。解决方法——使用循环队列。 （2）循环队列解决队首指针挪到队尾就动不了的方法：当队首指针到达队尾——即Q.front = Maxsize-1时，重置指针Q.front = 0。 初始化 123void InitQueue(SqQueue &amp;Q)&#123; Q.front = Q.rear = 0;&#125; 判队空 当循环队列存满时，尾指针rear指向尾元素的下一个元素——头元素，此时头尾指针相同，我们无法判断队列状态为空还是满。 对此，我们有三种解决方案： 少用一个存储单元，不让它真正的存满，这样子队尾指针永远在最后一个元素的下一位置，且不会和队首指针重合。这也是较为普遍的一种做法： 12345//队满条件：(Q.rear+1)%Maxsize == Q.front;//队空条件：Q.rear == Q.front; 结构体中增设元素个数标识Q.size，初始化值为0，每次入队Q.size++，每次出队Q.size--，这样队满队空只需判断Q.size的值即可： 12345//队满：Q.size == Maxsize;//队空：Q.size == 0; 后面的算法我都用这种方法来实现！ 结构体中增设队满队空标识Q.tag，初始值为0。 每次入队前先将tag值赋为1，每次出队前赋为0。 tag等于0时，若因出队导致Q.front == Q.rear，则为队空；tag等于1时，若因入队导致Q.front == Q.rear，则为队满。 1234567//出队前判空Q.tag = 0;Q.front++;if(Q.front==Q.rear &amp;&amp; tag==0) return false;//入队前判满 不行，没搞懂 入队（从队尾） 12345678910bool EnQueue(SqQueue &amp;Q, ElemType x)&#123; //入队前判满 if(Q.size == Maxsize-1) return false; //未满，入队 Q.data[Q.rear++] = x; //更改Q.size Q.size++; return true;&#125; 出队（从队首） 123456789bool DeQueue(SqQueue Q, ElemType &amp;x)&#123; //出队前判空 if(Q.size == 0) return false; //不空，出队 x = Q.data[Q.front--]; //更改Q.size Q.size--;&#125; 3、队列的实现——链式存储结构（1）定义队列的链式存储称为链队列，实际上是一个同时带有头指针和尾指针的单链表，头指针指向第一个结点，尾指针指向尾结点而不是尾结点之后的区域，入队从尾指针操作，出队从头指针操作。 以下演示均为带头结点的栈队列。 12345678910//定义结点——经典的链表节点typedef struct LinkNode&#123; ElemType data; //经典数据域data struct LinkNode *next; //经典链表指针域next&#125;*LinkNode;//定义链队列typedef struct&#123; LinkNode *front, *rear;&#125;*LinkQueue; （2）初始化123456void InitQueue(LinkQueue &amp;Q)&#123; //建立头结点 Q.front = Q.rear = (LinkQueue*)malloc(sizeof(LinkNode)); //头结点指针域默认为空 Q.front-&gt;next = NULL;&#125; （3）判空因为链队列空间是动态分配的，所以一般不用考虑空间溢出的问题，且当Q.rear = Q.front时表示队列空。 123bool IsEmpty(LinkQueue Q)&#123; return (Q.front == Q.rear);&#125; （4）入队队尾入队，不用判满，直接创建结点→更改队尾指针即可。 12345678void EnQueue(LinkQueue &amp;Q, ElemType x)&#123; //创建结点 LinkQueue *s = (LinkQueue*)malloc(sizeof(LinkNode)); //插入队列 Q.rear-&gt;next = s; Q.rear = s; s-&gt;next = NULL;&#125; （5）出队队首位置操作出队，需要先判空，将出队内容返还给调用者提供的x。 123456789101112131415bool DeQueue(LinkQueue &amp;Q, ElemType &amp;x)&#123; if(IsEmpty(Q)) return true; x = Q.front-&gt;data; LinkQueue *p = Q.front-&gt;next; Q.front-&gt;next = p-&gt;next; /* 到这一步还需判断我们删除的结点是不是唯一的一个结点（不算头结点）， 如果是，那么还得更改尾指针rear = front，否则free掉空间后队空了但是尾指针不等于front，野了！ */ if(p == Q.rear) Q.rear = Q.front; free(p); return true;&#125; 4、双端队列（1）普通双端队列双端队列是指允许两端都可以进行入队和出队操作的队列，如下图，其元素的逻辑结构仍是线性结构。 将队列的两端分别称为前端和后端，两端都可以入队和出队。 入队时，前端进的元素排列在队列中后端进的元素的前面，后端进的元素排列在队列中前端进的元素的后面。 出队时，无论前端还是后端，先出的元素排列在后出的元素的前面。 （2）受限的双端队列①输出受限的双端队列允许在一端进行插入和删除，但在另一端只允许插入的双端队列称为输出受限的双端队列。 ②输入受限的双端队列允许在一端进行插入和删除，但在另一端只允许删除的双端队列称为输入受限的双端队列。 若我们限定双端队列从某个端点插入的元素只能从该端点删除，则该双端队列就成了两个栈底相邻接的栈。 实际双端队列的考题不会很复杂，通常仅判断序列是否满足题设条件，带入验证即可。 （三）栈和队列的应用1、在括号匹配中的应用多个大小括号组合在一起，输入左括号相当于压栈，输入右括号，如果与栈顶左括号匹配，那直接消解弹栈，如果不匹配则说明输入非法， 报错。 123456//基本算法思想/*1.初始一个空栈，顺序读入括号;2.若是左括号，则压栈，若是右括号，则判断与栈顶括号能否匹配消解，能则消消乐，不能则报错;3.算法结束时，栈为空，否则括号序列不匹配。*/ 2、栈在表达式求值中的应用书本此处讲的主要是针对*后缀表达式*的求值操作。 后缀表达式：后缀表达式，指的是不包含括号，运算符放在两个运算对象的后面，所有的计算按运算符出现的顺序，严格从左向右进行（不再考虑运算符的优先规则）。 从左到右遍历进栈，一直到最终获得结果。遇到是数字就进栈，遇到是符号，就将处于栈顶的两个数字出栈，进行运算，运算结果进栈，一直到最终获得结果。 eg：中缀表达式A+B*(C-D)-E/F写成后缀表达式为ABCD-*+EF/-，它的运算过程详细如下： 步 扫描项 项类型 动作 栈中内容 1 初始化空栈 空 2 A 操作数 进栈 A 3 B 操作数 进栈 A、B 4 C 操作数 进栈 A、B、C 5 D 操作数 进栈 A、B、C、D 6 - 运算符 C、D出栈，计算C-D，计算结果R1进栈 A、B、R1 7 * 运算符 B、R1出栈，计算B*R1，计算结果R2入栈 A、R2 8 + 运算符 A、R2出栈，计算A+R2，计算结果R3入栈 R3 9 E 操作数 进栈 R3、E 10 F 操作数 进栈 R3、E、F 11 &#x2F; 运算符 E、F出栈，计算E&#x2F;F，计算结果R4入栈 R3、R4 12 - 运算符 R3、R4出栈，计算R3-R4，计算结果R5入栈 R5 3、栈在递归中的应用程序调用自身，用少量代码解决某些难题，但通常效率不是很高。 递归次数过多容易造成栈溢出。 书中以斐波那契数列为例：$$\\begin{equation}Fib(n)&#x3D;\\left { \\begin{aligned}Fib(n-1)+Fib(n-2), n&gt;1 \\1, n&#x3D;1 \\0, n&#x3D;0\\end{aligned} \\right.\\end{equation}$$这是典型的一个递归的例子，用程序实现如下： 12345678int Fib(int n)&#123; //斐波那契数列的实现 if(n==0) return 0; //边界条件 else if(n==1) return 1; //边界条件 else return Fib(n-1) + Fib(n-2); //递归表达式&#125; 该递归执行过程： graph TD id01[\"Fib(5)\"] id02[\"Fib(4)\"] id03[\"Fib(3)\"] id04[\"Fib(3)\"] id05[\"Fib(2)\"] id06[\"Fib(2)\"] id07[\"Fib(1)\"] id08[\"Fib(2)\"] id09[\"Fib(1)\"] id10[\"Fib(1)\"] id11[\"Fib(0)\"] id12[\"Fib(1)\"] id13[\"Fib(0)\"] id14[\"Fib(1)\"] id15[\"Fib(0)\"] id01 --- id02 & id03 id02 --- id04 & id05 id04 --- id08 & id09 id08 --- id14 & id15 id05 --- id10 & id11 id03 --- id06 & id07 id06 --- id12 & id13 必须注意递归模型不能是循环定义的，其必须满足下面的两个条件： 递归表达式(递归体)。 边界条件(递归出口)。 递归的精髓在于能否将原始问题转换为属性相同但规模较小的问题。 可以将递归算法转换为非递归算法，通常需要借助栈来实现这种转换。 4、队列在层次遍历中的应用有时候我们需要对数据逐层操作，比如二叉树的逐层遍历，这时候可以用队列结构。 graph TD A((A))-->B((B)) A((A))-->C((C)) B((B))-->D((D)) D((D))-->G((G)) C((C))-->E((E)) E((E))-->H((H)) E((E))-->I((I)) C((C))-->F((F)) 该想法的逻辑： 根结点入队。 若队空（所有结点都已处理完毕），则结束遍历；否则重复操作3。 队列中第一个结点出队，并访问之。若其有左孩子，则将左孩子入队；若其有右孩子，则将右孩子入队，返回操作2。 层次二叉树遍历的过程： 序 说明 队内 队外 1 A入 A 2 A出，B、C入 B、C A 3 B出，D入 C、D A、B 4 C出，E、F入 D、E、F A、B、C 5 D出，G入 E、F、G A、B、C、D 6 E出，H、I入 F、G、H、I A、B、C、D、E 7 F出 G、H、I A、B、C、D、E、F 8 G、H、I出 A、B、C、D、E、F、G、H、I 5、队列在计算机系统中的应用队列在计算机系统中的应用场景很多，以下仅举例两处： 主机与打印机的通信 主机发送文件的速度比打印机打印的速度要快得多，通常会设置一个打印数据缓冲区，主机很快地把数据发给打印机，然后扭头去做其他事让打印机慢慢处理，打印缓冲区中所存储的数据就是一个队列。 CPU，操作系统通常按照每个请求在时间上的顺序，把它们排成一个队列，让CPU按照该队列完成各项请求。这样既可以满足不同程序或用户的请求，又能使CPU正常运行。 （四）数组和特殊矩阵此处，我们研究如何将矩阵更有效地存储在内存中，并能方便的提取矩阵中的元素。 什么是数组 数组（Array）是有序的元素序列。 若将有限个相同的类型变量的集合命名，那么这个名称称为数组名。 组成数组的各个变量称之为数组的分量，也称为数组的元素，有时也称为下标变量。用于区分各个元素的数字下标称为元素下标或索引值（从0开始而不是1）。 这种有序排列的同类数据元素的集合称为数组。 什么是矩阵 矩阵（Matrix）是一个按照长方阵排列的复数或实数集合，最早来自于方程组的系数及常数所构成的方阵。 矩阵是二维数据组成的。 数组和矩阵的区别 数组中的元素可以是字符或字符串，而矩阵只能是数。 矩阵是二维的，而数组可以是n维的。 矩阵显示时元素之间无逗号，数组元素之间用逗号隔开。 1、简单数组的定义与存储结构 定义： 数组是由n个相同类型的元素构成的有限序列，每个数据元素称为一个数组元素，每个元素在n个线性关系中的序号称为该元素的下标，下标的取值范围称之为数组的维界。 数组与线性表的关系：数组是线性表的推广。一维数组可视为一个线性表，二维数组可视为其元素也是定长线性表的线性表，以此类推。数组一旦被定义，其维数和维界就不再改变，因此，除了数组结构的初始化和销毁外，数组只有存取元素和修改元素的操作。 存储结构： 大多数计算机语言都提供了数组数据类型，其物理结构与逻辑结构相同，一个数组的所有元素在内存中占用一段连续的存储空间。 （1）对于一维数组以一维数组A[0...n-1]为例，其存储结构关系式为：$$LOC(a_i) &#x3D; LOC(a_0) + i \\times L，(0 \\le i &lt; n)$$其中，L是每个数组元素所占的存储单元（下同）。 （2）对于多维数组（包含普通矩阵）对于多维数组的存储方式，有两种映射方法：按行优先存储和按列优先存储。 下面就以二维数组为例描述。 ①按行优先存储基本思想是先按照多维数组的行号来读取存储元素，先存储行号较小的元素，行号相同时先存储列号较小的元素。 设某二维数组的行下标与列下标的范围分别是[0,h1]与[0,h2]，则存储结构关系式为：$$LOC(a_{i,j}) &#x3D; LOC(a_{0,0}) + \\left [ i \\times (h_2 + 1) + j \\right ] \\times L$$例如数组A[2][3]，它按行优先存储的结果如下图所示： 后文中的数组或矩阵若无特别说明则一致采取该存储方式。 ②按列优先存储同上，按列优先存储就是按列优先存储。其存储结果关系式为：$$LOC(a_{i,j}) &#x3D; LOC(a_{0,0}) + \\left [ j \\times (h_1 + 1) + i \\right ] \\times L$$例如数组A[2][3]，它按列优先存储的结果如下图所示： 3、特殊矩阵的压缩存储 压缩存储：指为多个值相同的元素只分配一个存储空间，对零元素不分配存储空间，其目的是节省存储空间。 特殊矩阵：指具有许多相同元素或零元素，并且这些相同矩阵元素或零元素的分布有一定的规律性的矩阵。 常见的特殊矩阵有对称矩阵、上（下）三角矩阵、对角矩阵等。 特殊矩阵的存储方法： 找出特殊矩阵中值相同的元素的分布规律，把那些呈现规律性分布的、值相同的多个矩阵元素压缩到一个存储空间中。 （1）对称矩阵 是一个方阵，行数&#x3D;列数！ 定义：若对一个n阶矩阵A中的任意一个元素ai,j的值，都有ai,j &#x3D; aj,i（1&lt;&#x3D;i, j&lt;&#x3D;n），则称其为对称矩阵。 其中的元素可以划分为三部分，即上三角区、主对角线和下三角区，如图： 对于n阶对称矩阵而言，上三角区和下三角区存放的对应数据是一样的，如果我们还采取多维数组存放所有数据元素的话那会浪费将近一半的存储空间，所以，我们只将主对角线元素和上三角区（或下三角区）的元素储存。 数组大小应为多少： 第一行存储一个元素，第二行两个，第三行三个……以此类推，第n行存储n个，那么数组总长应为1+2+3+...+n，即：$$\\frac {(1+n) \\times n}{2}$$ 重点：我们还需要实现一个将某个元素的『矩阵内坐标』与『数组下标』对应转换的一个函数： 下面按照行优先存储、数组下标从0开始的情况实现： ①i,j→k对于矩阵内元素ai,j，与他的数组B下标k对应： ai,j在数组B中的下标k &#x3D; ai,j之前的总元素个数 &#x3D; 之前各行元素数量的和+自己所在的列数：$$k&#x3D;1+2+…(n-1)+j-1\\ \\ \\ \\ \\ →\\ \\ \\ \\ \\ k&#x3D;\\frac{i(i-1)}{2}+j-1$$ ②k→i,j（2）三角矩阵 与对称矩阵几乎无异，只是需要在数组最后加一个元素存储常量C而已，同时对位置映射函数稍加改动即可。 （3）三对角矩阵&#x2F;带状矩阵当|i-j|&gt;1时，有ai,j&#x3D;0，即只有对角线方向有三条线的数据。 $$ k=2i+j-3\\\\ i \\ge (k+2)/3，向上取整；或i \\le (k+1)/3+1，向下取整\\\\ j=k-2i+3 $$ （4）稀疏矩阵只有很少个元素的值不为0。 ①采用“三元组”压缩存储策略 缺点：不能随机读写。 ②十字链表法 **总结：","categories":[{"name":"编程","slug":"编程","permalink":"http://kouqiang.space/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://kouqiang.space/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://kouqiang.space/tags/%E7%AE%97%E6%B3%95/"}],"author":"寇强"},{"title":"🔑数据结构_第五章：树与二叉树","slug":"🔑数据结构_第五章：树与二叉树","date":"2023-03-11T12:00:00.000Z","updated":"2024-05-13T09:26:49.703Z","comments":true,"path":"2023/03/11/🔑数据结构_第五章：树与二叉树/","link":"","permalink":"http://kouqiang.space/2023/03/11/%F0%9F%94%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9A%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"","text":"🔑数据结构_第五章：树与二叉树第五章、树与二叉树（一）树的基本概念1、基本概念树是n(n&gt;0)个结点的有限集。 当n&#x3D;0时，称为空树。在任意一棵空树中应满足： 有且仅有一个特定的称为根的结点。 当n&gt;1时，其余结点可分为m(m&gt;0)个互不相交的有限集T1，T2，…，Tm，其中每个集合本身又是一棵树，并且称为根的子树。 显然，根的定义是递归的，即在树的定义中又用到了其自身，树是一种递归的数据结构。 树作为一种逻辑结构，同时又是一种分层结构，具有以下两个特点： 树的根结点没有前驱，其它所有结点有且只有一个前驱。 树中所有结点都可以有0个或多个后继。 树有n个结点，那它就有n-1条边。 2、基本术语 结点之间的关系描述 祖先结点：从“你”出发到根结点的路径上所经过的所有结点都称为“祖先结点”。 子孙结点：“你”后面的所有结点都可称为子孙结点。 双亲结点——即父节点——即直接前驱。 孩子结点——直接后继。 兄弟节点——同一层的结点。 唐兄弟节点——双亲在同一层的结点。 结点、树的属性描述 路径：自上而下的某两个节点之间的所有结点构成的序列，同一双亲的两个孩子之间不存在路径。 路径长度：路径上所经过的边的个数。 结点的层次&#x2F;深度：从上往下数在第几层。 结点的高度：从下往上数。 树的深度&#x2F;高度：总共多少层。注：深度默认从1开始算，但不排除有些题目指明从0开始！ 结点的度：孩子&#x2F;分支&#x2F;直接后继的个数，是个数字。非叶子节点的度&gt;0，叶子节点的度&#x3D;0。 树的度：各结点的度的最大值MAX&#123;结点A的度，结点B的度，结点C的度，...，结点N的度&#125;。 有序树、无序树 有序树：树中结点的各子树从左到右是有次序的，不能互换。 常见有哈夫曼树（俗称最优二叉树）、族谱（不能交换每一层老大老二老三等的位置）等。 无序树：树中结点的各子树从左到右是无次序的，可以互换。 总之，需要用结点的左右位置关系来反映某些逻辑关系的话就是有序树，否则为无序树。 森林 森林是m(m≥0)棵互不相交的树的集合。 3、树的常考性质 常见考点一：结点数 = 总度数 + 1。 常见考点二：度为m的树与m叉树的区别。 常见考点三：度为m的树第i层至多有**mi-1**个结点(i≥1)。 若层数从0开始，则结点数为**mi**个。 常见考点四和五：高度为h的**m叉树**结点个数的上下限问题。 最多： $$ 最多为：\\frac{m^h-1}{m-1} $$ 涉及到的是等比数列求和公式： $$ a+aq+aq^2+...+aq^{n-1} = \\frac{a(1-q^n)}{1-q} $$ 最少： 有h个结点： 常见考点六：具有n个结点的m叉树的最小高度为： $$ 前h-1层最多最多结点数 < n \\le 前h层最多最多结点数\\\\ \\frac{m^{h-1}-1}{m-1} < n \\le \\frac{m^h-1}{m-1}\\\\ m^{h-1}","categories":[{"name":"编程","slug":"编程","permalink":"http://kouqiang.space/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://kouqiang.space/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://kouqiang.space/tags/%E7%AE%97%E6%B3%95/"}],"author":"寇强"},{"title":"🔑数据结构_第四章：串","slug":"🔑数据结构_第四章：串","date":"2023-03-11T12:00:00.000Z","updated":"2024-05-13T09:26:44.643Z","comments":true,"path":"2023/03/11/🔑数据结构_第四章：串/","link":"","permalink":"http://kouqiang.space/2023/03/11/%F0%9F%94%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E4%B8%B2/","excerpt":"","text":"🔑数据结构_第四章：串第四章、串（一）串的定义和实现1、定义串，即字符串String，是由零个或多个字符组成的有限序列。一般记为：$$S&#x3D;\\ ‘a_1a_2…a_n’\\ \\ (n \\ge 0)$$ 其中，S是串名，单引号或双引号括起来的是串的值。 ai可以是字母、数字或其它字符。 串中字符的个数n称为串的长度。 n=0的串称为“空串”，用Φ表示。 相关定义： 子串： 串中任意两个连续的字符组成的子序列。 主串： 包含子串的串。 字符在主串中的位置： 字符在串中的序号，一般都是从1开始。 子串在主串中的位置： 子串中第一个字符在主串中的位置。 注意事项： 串的数据对象限定为字符集（如中文字符、英文字符、数字字符、标点字符等） 串的基本操作——如增删改查——通常以子串为操作对象，而不是单个字符！ 2、串的基本操作（1）赋值StrAssign(&amp;T,chars)：把串T赋值为chars。 （2）复制StrCopy(&amp;T,S)：由串S复制得到串T。 （3）判空StrEmpty(S)：若S为空串，则返回TRUE，否则返回FALSE。 （4）求串长StrLength(S)：返回串S的元素个数。 （5）清空ClearString(&amp;S)：将S清空为空串。 （6）销毁DestroyString(S)：将串S完全销毁——回收存储空间。 （7）联接Concat(&amp;T,S1,S2)：用T返回由S1和S2联接而成的新串。 （8）求子串SubString(&amp;Sub,S,pos,len)：用Sub返回串S的第pos个字符起长度为len的子串。 （9）定位Index(S,T)：若主串S中存在与串T值相同的子串，则返回它在主串S中第一次出现的位置；否则返回0。 （10）比较StrCompare(S,T)：若S&gt;T则返回值&gt;0，若S&lt;T则返回值&lt;0，且返回值为二者差值；若二者相等则返回0。 3、串的存储结构也是有顺序存储和链式存储两种。 （1）顺序存储1234567891011121314151617181920#define MAXLEN 255 //预定义最大串长为255//静态数组实现（定长顺序存储）typedef struct&#123; char ch[MAXLEN]; //每个分量存储一个字符 int length; //串的实际长度&#125;SString;//动态数组实现（堆分配存储）typedef struct&#123; char *ch; //按串长分配存储区，ch指向串的基地址 int length; //串的长度&#125;HString;int main()&#123; //初始化一个串 HString S; S.ch = (char *)malloc(MAXLEN * sizeof(char)); S.length = 0;&#125; 常见的记录串长的方法： （2）链式存储123456789101112//********串的存储结构——链式存储********//方式1typedef struct StringNode&#123; char ch; //每个节点存储1个字符，导致存储密度低！ struct StringNode * next;&#125;StringNode, * String;//方式2typedef struct StrngNode&#123; char ch[4]; //每个节点存储多个字符，解救了存储密度低的问题 struct StrinfNode * next;&#125;StringNode, * String; （二）串的模式匹配 什么是字符串的模式匹配？ 从字符串A里面搜寻B，A叫做主串，B叫做模式串。 字符串模式匹配：在主串中找到与模式串相同的子串，并返回其所在位置。 注：模式串不是子串，二者不是同一概念！ 在408考试中需要掌握两种模式匹配算法： 朴素模式匹配算法和KMP算法。 1、朴素模式匹配算法原理：在主串中枚举所有与模式串相同长度的子串，逐一对比即可。（突出一个朴素暴力） 主串长度为m，模式串长度为n时，主串中有m-n+1个与模式串长度相同的子串，比较&#x2F;匹配次数也是这么多次。 最坏时间复杂度为O(mn)。 2、KMP算法——考研算法难度排名前三注：匹配之前，我们首先需要对模式串进行预处理，弄清楚模式串里有哪些特征哪些字符是重复的，这样匹配失败时就不用挨个字符往后挪了，以便后续进行更高效的匹配： 开始与主串的第一个子串匹配： 在第五个位置匹配错误，那么主串中前四个位置的元素我们已经知道了&#x2F;与模式串对应，下一轮匹配只需将模式串移动到第*4*个位置、匹配第五个位置的元素： 匹配失败，下一轮将模式串移动到第*6*个位置开始匹配： 同理： 同理： 同理： 每次匹配失败后模式串需要往后移动几个位置，这就需要预处理，处理结果保存为数组（next[]）； 时间复杂度： 求next[]数组时间复杂度为O(m)； 模式匹配过程最坏时间复杂度为O(n)； 因此该算法的最坏时间复杂度为O(m+n)。","categories":[{"name":"编程","slug":"编程","permalink":"http://kouqiang.space/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://kouqiang.space/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://kouqiang.space/tags/%E7%AE%97%E6%B3%95/"}],"author":"寇强"},{"title":"🎈C语言基础入门","slug":"🎈C语言基础入门","date":"2023-02-28T13:10:00.000Z","updated":"2023-07-10T03:25:13.125Z","comments":true,"path":"2023/02/28/🎈C语言基础入门/","link":"","permalink":"http://kouqiang.space/2023/02/28/%F0%9F%8E%88C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/","excerpt":"","text":"🎈C语言基础入门一、数据的数据类型、数据的输入输出（一）C语言中的数据类型 C语言中的数据类型 基本类型 整型(int)：大小为4字节 浮点型(实型)： 双精度double 单精度float：占用4个字节 字符型：单引号，占用一个字节 字符串型：双引号，占用字节数为字符数量 + 1，因为每个字符串最后都有个\\0表示结束！ 构造类型 指针类型 空类型 基本数据类型，如果只声明不赋值，那么该变量是否会被赋初始值是不一定的，不同的编译器对该行为的操作不同，有些编译器会赋初始值，有些则不会！ （二）格式化输出函数print(f)的使用 函数声明： 1printf(const char *format, ...); 前面是格式控制符，后面是输出的目标。 控制符用双引号引起来，里面开头用%，接着跟类型符及其他控制符。 类型符： %hd、%d、%ld 以十进制、有符号的形式输出 short、int、long 类型的整数。 %hu、%u、%lu 以十进制、无符号的形式输出 short、int、long 类型的整数。 %lf 以普通方式输出double（float弃用，long doube无用）。 %e 以科学计数法输出double。 %c 输出字符。 %s 输出字符串。 %x无符号十楼进制数，用小写字母。 %X无符号十楼进制数，用大写字母。 %o八进制输出。(这里是字母o而不是数字0!) %p输出一个指针。 %%输出一个百分号。 宽度符： 在%后面类型符前面，加上数字，可用于控制输出内容的宽度，数字为几就表示输出总宽度为几： 1printf(&quot;%10s&quot;, &quot;哈哈&quot;); 对齐标志： 百分号%后加上加号或减号可更改输出内容的默认对齐方式，加号为右对齐(默认)，减号为左对齐： 1printf(&quot;%-10s&quot;, &quot;哈哈&quot;); 精度控制 在对齐标志后面添加小数点加规定数字(如.3)，即可将输出结果四舍五入到规定的位数（是控制小数点后的位数）： 1printf(&quot;%-10.3f&quot;, 3.1415926535); 其他 换行，在最后加上\\n，就有了输出结束后换行的效果： 1printf(&quot;%.3lf\\n%.5lf\\n&quot;, 3.1415926535,3.1415926535); 输出临时&#x2F;匿名常量： 可在类型符部分的双引号里面加入任何字符串空格或其他字符，控制条台会一起输入到屏幕上： 1printf(&quot;%.3lf哈哈哈\\n换了行，前面留六个空格：%13.5lf\\n&quot;, 3.1415926535,3.1415926535); 在实际开发中也常用这种方式输出内容！ 如果在不恰当的位置添加了临时字符，则会使程序输出错误： 1printf(&quot;%.3啊啊lf哈哈哈\\n换了行，前面留六个空格：%13.5lf\\n&quot;, 3.1415926535,3.1415926535); （三）整型进制转换 在声明变量的时候，在字面值前面加上字母o即表示该数值为八进制字面值，加上0x即表示为十六进制； 输出的时候可使用格式化输出将原来的值按照不同进制的结果输出： 12int b = 10000;printf(&quot;%o\\n%x\\n&quot;,b);//输出为八进制数值和十六进制数值 （四）标准输入函数scanf()函数初试不考scanf()，复试必考scanf()； 参考来源：C语言——scanf（）函数的具体详解_%c%c中间的空格_哩lililili的博客-CSDN博客 1、两种用法 读取基本类型变量 123int d1;float f1;scanf(&quot;%d %f&quot;, &amp;d1,&amp;f1); 读取字符数组 12char cs[] = &#123;&#125;;scanf(&quot;%c&quot;,cs[]); 其实很好理解，使用scanf()读取输入需要确定变量值的地址，因此读取基本类型输入的时候需要使用取地址符&amp; + 变量名，而对于字符数组，它的首元素地址就是这个数组的地址，因此并不需要加取地址符号。 2、机制原理 scanf()的处理机制&#x2F;原理： scanf()以删除的方式从缓冲区读入数据(来自标准输入设备的数据存储在缓冲区)，也就是说，scanf()从缓冲区读入一个数据项，该数据项在缓冲区中就被清除掉了。而如果scanf()需要读取一个数据项，发现缓冲区当前是空的，那么程序就会在scanf()代码处阻塞，等待用户输入，scanf()函数接收到相应的数据项之后，在缓冲区中将这一数据项清除，scanf()函数返回，程序继续执行。 3、对于不同类型输入的处理方式 输入整数%d或浮点数%f 对于整型数据的输入，也就是说%d类型的输入，scanf默认的分割符是所有的空白字符(空格，回车和制表符都行)。也就是说如果一个scanf函数中出现scanf(&quot;%d%d&quot;,&amp;a,&amp;b)，那么用任何一个空白字符来分隔两个整数a,b的值，变量a,b都可以接收到正确的输入。同样，浮点数也是如此！ 因此，下列输入是完全没问题的： 123456789101112131415//代码端：int a,b;scanf(&quot;%d&quot;,&amp;a,&amp;b);printf(&quot;%d\\n%d\\n&quot;,a,b);//控制台输入端：7 3//或7 3//或73或7 3 注： 输入队列中的7和3以及中间的空格，制表符或者换行符都会被送入缓冲区，但是scanf只接受非空白字符，因此无论以上三种格式输入都不会改变输入结果，理由是scanf会跳过所有的空白字符，将其丢在缓冲区内。所以，程序在下一次读取输入的时候会首先读取到的是被丢弃在缓冲区中的空白字符，如果接下来的转换说明是%c，或者%s，将会直接读取该空白字符而不是跳过，空白字符会从打印队列中显示出来。如何解决？看下文： 输入字符数据%c scanf在处理对字符数据的输入时，既不会忽略前导空白字符(空格、换行和Tab)，默认也没有任何分隔字符。所有的字符，包括空白字符都会被当成输入字符。 因此如果在读取字符输入的时候一定要注意前文中的空白字符（空格、制表、换行）！ **解决方法1：在%c之前加一个空格，即可起到跳过当前输入内容中的所有空白直到遇到非空白字符的作用！！！这同样对%d以及其他格式化输入适用！ 12345678910111213141516171819//代码端：int a,b;char str01 = &#x27;$&#x27;;char str02 = &#x27;(&#x27;;scanf(&quot;%d%d %c %c&quot;,&amp;a,&amp;b,&amp;str01,&amp;str02);printf(&quot;%d\\n%d\\n%c\\n%c&quot;,a,b,str01,str02);//控制台：D:\\JetBrains\\CLion_wangDao\\KQProjects\\001\\cmake-build-debug\\001.exe1223zx1223zx进程已结束，退出代码为 0 **解决方法2：使用fflush()函数： fflush(stdin);作用：清空标准输入缓冲区！ 在输入字符之前先用此函数清空缓冲区，那就没有任何空白了，nice！ 二、运算符与表达式（一）运算符分类C 语言提供了 13 种类型的运算符，如下所示。 算术运算符（+、-、*、/、%）； 关系运算符（&gt;、&lt;、==、&gt;=、&lt;=、!=）； 逻辑运算符（!、&amp;&amp;、||）； 位运算符（&lt;&lt;、&gt;&gt;、~、|、^、&amp;）； 赋值运算符（=及其扩展赋值运算符）； 条件运算符（?:）； 逗号运算符（,）； 指针运算符（*、&amp;）；（讲指针时详解） 求字节数运算符（sizeof()）； 强制类型转换运算符（(类型名)）； 分量运算符（.、-&gt;）；（讲结构体时详解） 下标运算符（[]）；（讲数组时详解） 其它（如函数调用运算符()）；（讲函数时详解） （二）算术运算符+、-、*、/、% 1、+、-、*没什么好说的 2、/操作数都是整型那么结果是整型，有一个是浮点型那么执行的就是浮点型除法。 3、%对两个整型数值取模，左边的除以右边的，返回余数。 比如： 123454 % 50 = 4;20 % 50 = 20;50 % 50 = 0;51 % 50 = 1;99 % 50 = 49; 4、优先级先*、/、%再+、-。 （三）关系运算符&gt;、&lt;、==、&gt;=、&lt;=、!= 对两个值比较，真返回1假返回0，C语言中是没有布尔类型的！0表示假1表示真。 优先级低于算术运算符。 C语言中的==不能用于结构体的比较！都无法编译通过！ （四）运算符优先级 三、选择、循环if else、for、while、do while、continue、break，与Java大差不大。 for()循环 123for(起始条件; 判断语句; 循环指令)&#123; 代码块&#125; 判断语句为真则执行代码块，直至判断语句为假。 while()和do while 1234567while(判断语句)&#123; 代码块&#125;//-----------------------------------do&#123; 代码块&#125;while(判断语句); 判断语句为真则执行代码块，直至判断语句为假。 do while循环体最少会执行一次，而while最少执行0次。 用到的时候随时补充。 四、一维数组与字符数组（一）一维数组1、声明&#x2F;初始化 在定义数组的时候对数组元素赋初值： 1int ar01[5] = &#123;20,8,11,65,165&#125;; 不能先声明再赋值： 12345int ar01[5];ar01[] = &#123;1,1,1,1,1,&#125;;//或ar01 = &#123;1,1,1,1,1&#125;;//这都是错误写法！！！ 也可以不赋初始值，但是默认会是数值几有点玄学： 1int ar01[10]; 如果给每一个元素都赋具体的初始值，那么可以省略方括号内的元素个数： 1int ar01[] = &#123;3,6,9,12&#125;; 但是初试不建议这么写！还是要加上元素个数！！！ 可以只给一部分元素赋值，未赋值的元素将被赋值为0： 1int ar01[5] = &#123;1,1,1&#125;; 若要给所有元素赋初始值为0，则可以写成int ar01[5] = &#123;0&#125;; 可以给单独的某个元素赋值： 12int ar01[5] = &#123;0&#125;;ar01[0] = 33, ar01[2] = 34; *注：命名规则必须如上，C语言不允许把方括号放到类型名后面！ 2、一维数组的存储方式3、数组的访问越界&#x2F;&#x2F;C和C++的特性！ &#x2F;&#x2F;初始一般考不到，复试有可能问到！ 什么是数组访问越界： 123int ar01[3] = &#123;5,5,5&#125;;int i = 23, j = 24;ar01[3] = 11, ar01[4] = 12; 当访问某数组元素时不小心将索引值i错写为i &gt; arrar.length的值时，再进行的操作就会作用于其他已有变量从而导致bug！！！ 4、数组的传递&#x2F;&#x2F;初试和复试都可能考到！ 当某个数组从函数A作为参数传递给函数B时，B函数接收到的并不是数组本身，而是数组的内存地址——即一个指针而已！ 所以数组的长度是传递不过去的！但是更改其某个元素的数值等操作仍可正常操作。 因此，如果有向其他函数传递数组长度的需要，建议再声明一个参数专门用来存储数组长度。 5、字符数组初始化及传递 初始化方式与之前的相同： 1234567//可以声明的时候直接赋值，也可以声明后挨个元素单独赋值：char ch00[5];//或char ch01[] = &#123;&#x27;伍&#x27;,&#x27;六&#x27;,&#x27;柒&#x27;&#125;;//或char ch02[4];ch02[0] = &#x27;梅&#x27;, ch02[0] = &#x27;花&#x27;, ch02[0] = &#x27;十&#x27;, ch02[0] = &#x27;三&#x27;; 但是工作中不这样敲，字符数组一般用来存储字符串： 1char ch03[] = &quot;19建学（1）班&quot;; C语言规定字符串的结束标志为\\0，而系统会对字符串常量自动添加一个\\0，因此，用字符数组存储字符串时，字符串的字符长度必需比所在数组的数组长度少一字节！否则，系统再输出完数组内容后没检测到\\0，就会接着在内存中把后面的其他数据输出，直到遇到\\0。因此，遇到输出字符串乱码时可检查代码和内存是否遗漏了\\0。 注：汉字字符所占空间为一个字符两个字节！而英文字符为1字节。 123char ch03[13] = &quot;19建学（1）班&quot;;printf(&quot;%s&quot;,ch03);//第一行字符总长度为13字节，但是系统还要追加一个\\n，因此数组长度为14，方括号内填13则会出问题： 数组长度改成14则正常： 12char ch03[14] = &quot;19建学（1）班&quot;;printf(&quot;%s&quot;,ch03); 字符串的传递——模拟printf() 123456789101112131415#include &lt;stdio.h&gt;void print(char c01[])&#123; int i = 0; while(c01[i])&#123; printf(&quot;%c&quot;,c01[i]); i++; &#125; printf(&quot;循环结束\\n&quot;);&#125;void main()&#123; char ch01[] = &quot;splendid&quot;; print(ch01);&#125; scanf()更改字符数组的注意： 使用scanf()对字符数组内容进行字符串的赋值时，用户在键盘输入完成后，系统还会自动追加一个\\n ，且不用对字符数组取地址： 123char str01[15] = &#123;&quot;makabaka&quot;&#125;;scanf(&quot;%s&quot;,str01);printf(&quot;%s&quot;,str01); 但是这种方法不能输入带有空格的文本，此处系统遇到任何空白都会识别为结束！ 怎么解决？看后面。 6、gets函数与puts函数（1）gets()从控制台接受用户输入内容，与scanf()不同的是gets()会存储空格和制表符，用printf()输出时不会有空格或制表符之后的内容被忽略的情况！ 输入的参数只能是某个字符数组名——它的指针。 按回车键结束输入，系统仍会追加\\n。gets 遇到\\n后，不会存储\\n，而是将其翻译为空字符\\0。 参数只能是一个，不能是多个！ 123char cr02[15];gets(cr02);printf(&quot;%s&quot;,cr02); （2）puts() 将字符串打印到屏幕上，然后多打印一个换行符。 相当于printf(&quot;%s\\n&quot;,cr02);或Java的System.out.println(); 同上，输入的参数只能是某个字符数组名——它的指针。 123char cr02[15];gets(cr02);puts(cr02); 7、str系列字符串操作函数&#x2F;&#x2F;初试没那么重要，复试更重要一点！ 使用时头文件要加#include &lt;string.h&gt;！！！ （1）strlen(str01)：统计字符串长度 传入参数为字符串名。 返回一个int类型的数字结果。 忽略字符串结尾系统追加的\\n，但不忽略数组中任何地方的空白。 计算的字符长度为实际存在的有效字符长度，跟你定义字符串数组时的方括号里的数字没关系！ 12345char cr02[20];gets(cr02);puts(cr02);int crLength = strlen(cr02);printf(&quot;字符串长度：%d&quot;,crLength); （2）strcpy(strA,strB)：复制字符串B到字符数组A中，替换掉原本A中的所有内容！ A的所有内容都会被删掉！ 第一个参数必须是字符串名&#x2F;指针，而第二个参数指针或匿名临时字符串都可以！但是参数只能是两个！ 使用时注意不要超过定义的字符串长度，否则造成访问越界！ 1234567891011char cr02[20];char cr03[10];printf(&quot;请输入第一个字符串：&quot;);gets(cr02);printf(&quot;请输入第二个字符串：&quot;);gets(cr03);strcpy(cr02,cr03);int crLength = strlen(cr02);printf(&quot;strcopy()函数处理的结果：&quot;);puts(cr02);printf(&quot;总的字符串长度：%d&quot;,crLength); （3）strcmp(strA,strB)：比较两个字符串的内容 原理：从头到尾比较两个字符串中相同位置的字符的ASCⅡ码值，相同则比较下一位的，不同则返回数字。 返回值为int类型的整数，相同则返回0，A&gt;B(相同位置字符的ACSⅡ码值)返回1，A&lt;B返回-1。 输入的两个参数可以是字符串的指针也可以是匿名的临时字符串，二者都可以，但是参数只能是两个！ 123456789101112char cr02[20];char cr03[10];printf(&quot;请输入第一个字符串：&quot;);gets(cr02);printf(&quot;请输入第二个字符串：&quot;);gets(cr03);strcat(cr02,cr03);int crLength = strlen(cr02);printf(&quot;strcopy()函数处理的结果：&quot;);puts(cr02);int biJiaoJieGuo = strcmp(cr02,cr03);printf(&quot;总的字符串长度：%d\\n两个字符串比较的结果：%d\\n&quot;,crLength,biJiaoJieGuo); （4）strcat(strA,strB)：将字符串B连接到字符串A的后面 第一个参数必须是字符串名&#x2F;指针，而第二个参数指针或匿名临时字符串都可以！但是参数只能是两个！ 使用时注意不要超过定义的字符串长度，否则造成访问越界！ 1234567891011char cr02[20];char cr03[10];printf(&quot;请输入第一个字符串：&quot;);gets(cr02);printf(&quot;请输入第二个字符串：&quot;);gets(cr03);strcat(cr02,cr03);int crLength = strlen(cr02);printf(&quot;strcopy()函数处理的结果：&quot;);puts(cr02);printf(&quot;总的字符串长度：%d&quot;,crLength); 五、指针 说某个变量的地址时，说的都是这个变量的起始地址。 （一）指针的本质和使用1234567int a = 10;//定义指针变量int *aPointer;//给指针变量赋值aPointer = &amp;a;//输出指针变量所指的内容printf(&quot;aPointer所指的内容为：%d&quot;,*aPointer); 1、本质：就是新建一个变量用来存放另一个变量的内存地址。 &amp; 取地址符，也称引用，用它可以获取某个变量的内存地址。 12int a = 10;printf(&quot;%d&quot;,&amp;a); * 取值操作符，也称解引用，用它可以得到一个地址对应的数据。 123int a = 10;int *aPointer = &amp;a;printf(&quot;“*aPointer”输出为：%d；\\n“aPointer”输出的内容为：%d&quot;,*aPointer,aPointer); 注：声明指针变量时，星号*位于原变量名前连着或紧跟在类型声明符后面或和二者中间都有间隔，他都不会报错或编译出现问题，但是我们约定俗成的书写习惯就是让星号和原变量名连在一起，以便在声明多个变量时避免不必要的歧义！ 2、使用要点 指针声明：和普通变量一样，只不过指针变量名之前要加*，后续使用的时候也要加，包括输出的时候，否则不加星号直接操作的话操作的是变量中保存的地址代码！ 因此，int *aPointer的变量名是aPointer而不是*aPointer！ 指针变量的数据类型不是固定的，但是声明时要和所指对象的数据类型保持一致！ 指针存在的意义就是为了间接访问。 *和&amp;的优先级相同，但同时出现时会从右向左依次结合，因此： 12int a = 10;int pointer01 = &amp;a; 对于如上，&amp;*pointer01语句的含义与&amp;a是一样的！ 3、使用场景只有两个使用场景：传递与偏移。 （1）传递因为C语言的函数调用时传递参数，是值传递，实参赋值给形参！ 所以在需要我们通过另一个函数改变其他函数的值的时候，传递参数就用指针，给原函数的某变量声明个指针再把该指针传给其他参数。 12345678910void change01(int *b)&#123; *b = 100;&#125;int main() &#123; int a = 1; change01(&amp;a); printf(&quot;a=%d&quot;,a); return 0;&#125; （2）偏移 对指针进行加减运算称为指针的偏移，加就是向后偏移，减就是向后偏移。 指针所指向的地址实际上是内容中第一个字符所在的地址。 源码中指针每次加或减1，实际在他存储的内容中是加或减了他类型的一个基数大小： 123456789int a = 1;int *b = &amp;a;printf(&quot;原先b存储的地址内容：%d\\n&quot;,b);b += 1;printf(&quot;b += 1后存储的内容：%d\\n&quot;,b);/*此处指针b是int类型，int类型大小是4个字节，所以b加或减1后实际存储的地址数据是加或减了4*/ 有了这特性我们可以利用指针的偏移来进行数组遍历的另一种方式： 顺序输出 123456789//声明数组int bb[5] = &#123;2,3,1,6,3&#125;;//创建数组的指针。因为数组名本身就是指针，所以不用取地址。int *p01 = bb;printf(&quot;int数组长度：5\\n\\n&quot;);//遍历并输出数组for(int i = 0; i &lt; 5; i++)&#123; printf(&quot;00%d\\n&quot;,*(p01+i));&#125; 逆序输出 12345//遍历并输出数组p01 += 4;for(int i = 0; i &lt; 5; i++)&#123; printf(&quot;00%d\\n&quot;,*(p01-i));&#125; （3）指针与一维数组数组名作为实参传递给函数时，是弱化为指针的。 123456789101112void change01(char *a)&#123; *a = &#x27;R&#x27;; a[1] = &#x27;O&#x27;; //与“*(a+1)”等价 *(a+2) = &#x27;M&#x27;;&#125;int main() &#123; char str01[15] = &quot;romantic&quot;; change01(str01); puts(str01); return 0;&#125; （二）指针与动态内存申请——malloc()与free()非常重要！考研初试复试都会考！ 定义数组时要确定数组长度，不方便，这是因为C语言的基本类型变量都存储在栈空间中，编译时就确定了。 如果要动态地使用内存，就要使用堆内存的方式储存内容。 malloc函数的作用是动态分配内存，以解决静态内存定长、不能手动释放等缺陷。 1、malloc()函数的使用123#include &lt;stdlib.h&gt;void* malloc(size_t size); 需引入头文件#include &lt;stdlib.h&gt;。 返回值为一个void类型的指针，指向刚申请的空间的地址。 C&#x2F;C++规定，void*类型可以强制转换为任何其它类型的指针。 因此我们需要对返回值进行强制类型转换，参考如下代码。 形参只能有一个，作用是设定你打算开辟空间的大小（字节），int类型整数。 实例参考： 1234567891011121314151617#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;int main() &#123; //用int类型变量存储我们需要开辟的内存空间大小（字节）的值 int needSize = 15; //定义一个指针用来存储malloc()开辟出空间后返回的地址 char *ptr01; //所需开辟字节数量needSize作为malloc()的参数 //用(char*)对返回值进行强制类型转换，然后赋值给我们定义的指针，以便进行后续操作 ptr01 = (char*)malloc(needSize); strcpy(ptr01,&quot;Hallo Java!&quot;);// ptr01 = &quot;Hallo Java!&quot;; //这里不能用这条语句，不知道为什么 puts(ptr01); return 0;&#125; 如果实际存储的内容的字节大小大于给malloc()传入的参数的大小，那么多出来的内容会写到别的存储单元里！ 2、free()函数的使用 用于释放malloc()开辟出来的某块空间。 当函数结束后，指针变量*pointor就销毁了，但是其指向的字节仍然占用，而且因为指针的销毁，就无法访问这片内存！ 虽然程序运行完之后所有空间都会被释放，但一般来讲我们还是要要手动释放空间，以避免程序或系统崩溃。 使用方式： 1234free(原指针名);//例如：free(ptr01); 注：传给的参数必须是malloc()返回的指针，如果对其进行了偏移运算那么会报错！ 六、函数（一）函数的声明与定义1、声明返回值类型 + 函数名 + [形参列表] + 分号： 1void fName(int a, float b, char c); 2、定义&#x2F;实现在定义了的基础上再写好函数体就可以了。 123void fName()&#123; printf(&quot;hahaha&quot;);&#125; 3、使用说明 C语言中我们习惯——函数先声明再调用！ 即：默认情况下，只有后面定义的函数才可以调用前面定义过的函数！ C语言的函数可以只声明不定义（或者说实现）： 12345678910111213#include &lt;stdio.h&gt;//只声明不实现：void funA();main()&#123; ......&#125;//后边再实现：void funA()&#123; ......&#125; 与Java不同，C的函数没有那些权限修饰符。 函数不用显式声明，隐式声明的函数默认返回值类型是 int！ C语言规定函数不能嵌套定义： 1234void a()&#123; //函数里面不能再声明函数 void b()&#123;&#125;&#125; 函数可以嵌套调用，但不能调用main()函数。 （二）函数的分类与调用1、递归调用&#x2F;&#x2F;初试必考！ 函数自己调用自己的行为称为递归。递归函数一定要有结束条件，不然会陷入死循环！ 例：使用递归求n的阶乘： 1234567891011121314151617int digui(int a)&#123; if(a == 1)&#123; return 1; &#125; return a * digui(a-1);&#125;int main() &#123; //使用递归求n的阶乘 int a; printf(&quot;请输入需要求其阶乘的数，按回车开始：\\n&quot;); scanf(&quot;%d&quot;,&amp;a); printf(&quot;计算已开始......\\n&quot;); printf(&quot;计算结果为：%d&quot;,digui(a));&#125; （三）自定义用户类库1、头文件的引入系统自带的类库，使用#include &lt;&gt;即可，二用户自定义的类库，则把尖括号改为双引号并且将头文件与源码放在同一路径下！ 12#include &lt;stdio.h&gt;#include &quot;myJava01.h&quot; （四）局部变量和全局变量 定义在函数外就是全局变量，函数内就是局部变量。 全局变量如果与局部变量重名，那么就近原则。 局部变量只在自己所在代码块内有效，循环体内的局部变量在循环体外也无法访问！ C语言的全局变量不存储在堆内存或栈内存内，而是在“数据段”中。 C语言中不建议使用全局变量，甚至有些公司禁止使用全局变量。（但是初试怎么方便怎么来，这里没要求） 全局变量实际上只有在被定义后才有效，在被定义之前也是不存在的！ 函数形参中声明的变量也是局部变量，在函数没有被调用的时候它形参中的局部变量也是没有被分配内存单元的。 全局变量在整个程序执行的全程中都占用内存单元。 C语言要求把程序中的函数做成一个封闭体，除“实参→形参”的渠道与外界发生联系外，没有其他渠道。 七、结构体与C++引用详解&#x2F;&#x2F;初试用到结构体的概率很高的 &#x2F;&#x2F;选择题会考结构体对齐 （一）什么是结构体 结构体就是用来存储不同类型数据的集合。 就像做了个模板，模板里面有各种属性，用的时候按照这个模板定义一些”结构体“。 我们把结构体声明在函数外，而在需要使用的函数内实现并使用。 1、结构体的声明一般形式为：struct 结构体名 &#123;成员表列&#125;; 不管是声明还是定义，结尾都必须加分号！ 123456789//定义结构体struct studentsInfo &#123; int num;//学号 char name[10];//姓名 char sex;//性别 int age;//年龄 float score;//分数 char addr[30];//地址&#125;; 2、结构体的定义（实现）123456789101112131415161718//定义结构体struct studentsInfo &#123; int num;//学号 char name[10];//姓名 char sex;//性别 int age;//年龄 float score;//分数 char addr[30];//地址&#125;;int main() &#123; //结构体实现 struct studentsInfo stu01 = &#123; 101107, &quot;Gatsby&quot;, &#x27;1&#x27;, 22, 61.0, &quot;浙江省枝江市***&quot; &#125;; printf(&quot;输出结构体内容：\\n学号：%d； 姓名：%s； 性别：%c； \\n年龄：%d； 成绩：%5.2f； 地址：%s。\\n&quot;, stu01.num, stu01.name, stu01.sex, stu01.age, stu01.score, stu01.addr);&#125; 3、结构体数组 实现结构体的时候，将其定义为数组变量，那么它就成了一个结构体数组： 1struct studentsInfo sAr[3]; 这时候它里面储存的就是三个结构体数组，我们可以对其循环遍历访问和操作： 123456789101112131415161718192021222324252627282930//定义结构体struct studentsInfo &#123; int num;//学号 char name[10];//姓名 char sex;//性别 int age;//年龄 float score;//分数 char addr[30];//地址&#125;;int main() &#123; //定义结构体数组 struct studentsInfo sAr[3]; printf(&quot;整个结构体占用空间大小为：%d字节。\\n&quot;,sizeof(sAr)); //循环遍历——输入内容 for(int i = 0; i &lt; 3; i++)&#123; printf(&quot;请输入第%d组数据：\\n&quot;,i+1); //注意此处：输入的数字类型的数据仍是需要取地址的！！！ int j = scanf(&quot;%d %s %c %d %f %s&quot;,&amp;sAr[i].num,sAr[i].name,&amp;sAr[i].sex,&amp;sAr[i].age,&amp;sAr[i].score,sAr[i].addr); printf(&quot;第%d组中已成功输入%d项数据；\\n&quot;,i+1,j); &#125; //循环遍历——输出内容 for(int i = 0; i &lt; 3; i++)&#123; printf(&quot;这是第%d组数据：\\n&quot;, i+1); printf(&quot;学号：%d 姓名：%s 性别：%c 年龄：%d 分数：%f 地址：%s\\n&quot;, sAr[i].num,sAr[i].name,sAr[i].sex,sAr[i].age,sAr[i].score,sAr[i].addr); &#125; printf(&quot;第一个结构体数组占用空间大小为：%d字节。\\n&quot;,sizeof(sAr[0])); printf(&quot;整个结构体占用空间大小为：%d字节。\\n&quot;,sizeof(sAr));&#125; （二）结构体的对齐1、什么是”结构体对齐“？我们都知道，数据是以字节形式存储的，比如一个int类型的变量就占用4个字节的空间。 而结构体是很多不同类型数据的集合体， 那它里面的这些不同类型的多个数据可不一定是一个个紧挨着存储的，它是按照特定大小的字节倍数存放的，什么倍数： 最大成员的整数倍！ 即：结构体里面所有基本数据类型中，占用空间最大的那个数据类型的字节数就是该倍数。 但是如果两个连在一起的小的数据加起来**&lt;&#x3D;最大成员的整数倍，那么他们会共同占用一个最大成员的整数倍**： 比如sAr[0]中，成员有int、char和float类型的数据，int型数据占四个字节，float四个，char一个。而数组大小是我们定义的： 12345678struct studentsInfo &#123; int num;//学号 char name[10];//姓名 char sex;//性别 int age;//年龄 float score;//分数 char addr[30];//地址&#125;; 变量char name占用10个字节，空出来的两个字节可以容得下char sex，所以他俩共同占用12个字节，那么整个数组大小为4+12+4+4+32&#x3D;56个字节，整个结构体大小为56*3&#x3D;168字节： 2、结构体指针（1）结构体指针与普通指针一样，我们可以定义结构体类型的指针，用来指向原结构体： 1234567891011121314//声明结构体struct std&#123; int num; char name[10]; char sex;&#125;;void main()&#123; //实现结构体 struct std stdInfo = &#123;07,&quot;jiaran&quot;,&#x27;1&#x27;&#125;; struct std stds[2]; //声明结构体指针并赋值 struct std *p = &amp;stdInfo;&#125; 结构体指针只能赋已有结构体的值。 （2）通过指针访问结构体元素两种访问方法： ①传统的结构体名.元素名如下列代码中的第8行 第8行中，使用(*p).num是因为点运算符.比指针运算符*优先级高！ ②使用指针名-&gt;元素名访问如下列代码中的第10行 12345678910//实现结构体struct std stdInfo = &#123;07,&quot;jiaran&quot;,&#x27;1&#x27;&#125;;//声明结构体数组的指针并赋值struct std *p = &amp;stdInfo;//通过结构体指针访问结构体://1.传统方式访问并赋值：printf(&quot;请输入数据：\\n&quot;);scanf(&quot;%d %s %c&quot;,&amp;(*p).num,(*p).name,&amp;(*p).sex);//2.`结构体名-&gt;元素名`方式访问并输出printf(&quot;存入的数据为:\\t%d\\t%s\\t%c\\n&quot;,p-&gt;num,p-&gt;name,p-&gt;sex); 学习和工作中我们都是用第二种方法来访问和使用，不建议使用第一种方法。 （三）typedef的使用typedef是在C和C++编程语言中的一个关键字。作用是为现有的数据类型(int、float、char……)创建一个新的名字，目的是为了使代码方便阅读和理解。 相当于提前定义好某个变量再起个别名，用的时候直接用这个别名去声明新的数据，改的时候改一处即可。 语句： 1234567891011121314//结构体定义typedef struct member &#123; int a, b; char c;&#125;mbr, *mbrp; //给该结构体起的别名为mbr，给该结构体类型的指针起别名为mbrp；//别名使用mbr m1; //定义结构体变量；m1.a = 10; //实现其内容m1.b = 20;m1.c = &#x27;t&#x27;;mbrp mp1; //定义该结构体类型的指针（此时该指针没有指向任何具体对象）；mp1 = &amp;m1; //该指针指向结构体变量； 使用方法： 在头文件下面提前定义。 结尾必须加分号。 12345678910111213141516171819#include &lt;stdio.h&gt;//定义一个int型的数据typedef int NUM01;//定义结构体的别名typedef struct stu &#123; int a; char b; char c[10];&#125; stus, *stdP;void main()&#123; //使用结构体别名定义结构体 stus std01 = &#123;0&#125;;//相当于struct stu std01 = &#123;0&#125;; stdP ptr01 = &amp;std01;//相当于struct stu *ptr01 = &amp;std01; //使用别名定义int型数据 NUM01 a = 10;//相当于int a = 10;&#125; （四）C++引用1、说明 C++是完全兼容C的，也就是说C++文件里写C的代码是完全能跑成功的。 而C++有一些特性是C没有的，所以我们可以在结合二者以应对后续的课程。 2、指针引用的使用（1）子函数内修改主函数的普通变量1234567891011#include &lt;stdio.h&gt;void change(int &amp;i)&#123; //这里的&amp;在C++里叫做“引用”！且引用符必须和变量名紧邻！ i++;&#125;int main() &#123; int a = 12; change(a); printf(&quot;%d&quot;,a);&#125; （2）子函数内修改主函数的一级指针变量（这是重要的！）12345678910111213141516#include &lt;stdio.h&gt;void change(int * &amp;q01, int *q02)&#123; q01 = q02;&#125;int main()&#123; //定义空指针变量*p01 int *p01 = NULL; int a = 10; int *p02 = &amp;a; //调用函数改变指针*p01的内容 change(p01,p02); //输出验证 printf(&quot;改变之后：%d\\n&quot;,*p01);&#125; 如果这里我们用纯C代码实现，那就要用到二级指针，上述代码等价于： 12345678910111213141516#include &lt;stdio.h&gt;void change(int **q01, int *q02)&#123; *q01 = q02;&#125;int main()&#123; //定义空指针变量*p01 int *p01 = NULL; int a = 10; int *p02 = &amp;a; //调用函数改变指针*p01的内容 change(&amp;p01,p02); //输出验证 printf(&quot;改变之后：%d\\n&quot;,*p01);&#125; 而考研初试二级指针是用不到的。 3、布尔类型C语言没有布尔类型，我们把C++的布尔类型引用进来。 true是0，false是1。 声明： 1bool a = true, b = false; 验证： 123456#include &lt;stdio.h&gt;int main()&#123; bool a = true, b = false; printf(&quot;%d%d&quot;,a,b);&#125; 2023.03.11.18:53","categories":[{"name":"考研408笔记","slug":"考研408笔记","permalink":"http://kouqiang.space/categories/%E8%80%83%E7%A0%94408%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://kouqiang.space/tags/%E7%BC%96%E7%A8%8B/"},{"name":"C语言","slug":"C语言","permalink":"http://kouqiang.space/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"考研笔记","slug":"考研笔记","permalink":"http://kouqiang.space/tags/%E8%80%83%E7%A0%94%E7%AC%94%E8%AE%B0/"}],"author":"寇强"},{"title":"SU动态组件学习","slug":"SU动态组件学习","date":"2023-01-20T04:09:00.000Z","updated":"2023-01-28T14:29:37.202Z","comments":true,"path":"2023/01/20/SU动态组件学习/","link":"","permalink":"http://kouqiang.space/2023/01/20/SU%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"SU动态组件一、各种函数认识（一）数学函数 ABS(number) 求整数的绝对值 1alert(abs(-127)) CEILING(number,significance) 将参数number向上(沿绝对值增大方向)取值，取到最接近significance的倍数。比如： 1234CEILING(-2.5,-2);//输出为-4！CEILING(3.14159,100);//输出为100！ 注：两个参数符号必须一致！ DEGREES(number) 将弧度值转换为角度值，如： 12alert(degrees(pi()));//输出180 EVEN(number) 将参数number向上(沿绝对值增大方向)取值，取到最接近的偶数。比如： 12EVEN(5)//输出6 EXP(number) exp(x)表示的是e的x次方，x可以是一个函数。 FLOOR(number,significance) 将参数number向下(沿绝对值减小方向)取值，取到最接近significance的倍数。比如： 1234FLOOR(-2.56,-2) //返回-2FLOOR(99.99,20) //返回80 INT(number) 舍去小数，向下取整。 ISEVEN(NUMBER) 判断参数是否为偶数，是则返回1，否则返回0。 ISODD(number) 判断参数是否为奇数，是则返回1，否则返回0。 LN(number) 计算参数的自然对数，与EXP()互为反函数。 LOG10(number) 计算以10为底、输入参数的对数。 ODD(number) 将一个不是奇数的数值向上舍入为最接近的奇数： 12alert(odd(10)); //输出11 POWER(base,power) 计算base的power次幂的值： 123456power(5,2); //5的2次方，返回25power(6.6,2.5); //6.6的2.5次方，返回111.9.7666power(6.6,1/4); //6.6的1/4次方，返回1.602825 PI() 返回圆周率π的值，精确到小数点后6位：3.141593 RADIANS(number) 将角度转换为弧度。 RAND() 返回范围在[0,1)的随机实数，一般小数点后保留6位。 RANDBETWEEN(bottom,top) 返回自定义范围内的随机数，范围为[bottom,top)。 ROUND(number,decimal_places) 四舍五入函数，操作目标为number参数，decimals_places为保留的位数。 decimals_places参数，应填入整数，值大于0表示保留的小数位数有几个，等于0表示不保留小数，小于0表示将整数部分的后几位四舍五入，如： 123456round(123.14159,2); //保留两位小数，结果为123.14round(123.14159,0); //不保留小数，结果为123round(123.14159,-2); //将整数部分的后两位四舍五入，结果为100 注：在Excell里以上表述完全生效，但是在SU里第二个参数填写负数和0的作用一样，都是取整！ SIGN(number) 返回参数的符号，参数大于0返回1，等于0返回0，小于0返回-1。 SQRT(number) 对参数开二次根号。 （二）SketchUp函数 CHOOSE(index,value1,value2,......valueN) 第一个参数为索引值（从1开始，0会报错），后面的值都是筛选数据，从一组数据中返回第index个数据： 12alert(choose(1,9,8,7,6,5)); //输出为9 CURRENT(&quot;attributeName&quot;) EDGES() FACEAREA(&quot;materialName&quot;) FACES() LARGEST(value1,value2,......valueN). LAT() LNG() NEAREST(originalValue,value1,value2,......valueN) OPTIONINDEX(&quot;attributeName&quot;) OPTIONLABLE(&quot;attributeName&quot;) SMALLEST(value1,value2,......valueN) SUNANGLE() SUNELEVATION() （三）文字函数 CHAR(number) CODE(text) CONCATENATE(text1,text2,......textN) DOLLAR(value,decimals) EXACT(text1,text2) FIND(findText,text,position) LEFT(text,number) LEN(text) LOWER(text) MID(text,start,number) PROPER(text) REPLACE(text,position,length,new) REPT(text,number) RIGHT(text,number) SUBSTITUTE(text,searchText,newText,occurrence) TRIM(text) UPPER(text) VALUE(text) （四）三角函数 ACOS(number) ACOSH(number) ASIN(number) ASINH(number) ATAN(number) ATANH(number) COS(number) COSH(number) SIN(number) SINH(number) TAN(number) TANH(number) （五）逻辑函数 AND(logicalValue1,logicalValue2,...logicalValueN) FALSE() IF(test,thenValue,elseValue) NOT(logicalValue) OR(logicalValue1,logicalValue2,...logicalValueN) TRUE() （六）onClick函数 ALERT(&quot;message&quot;) ANIMATE(&quot;attribute&quot;,state1,state2...stateN) ANIMATEFAST(&quot;attribute&quot;,state1,state2...stateN) ANIMATECUSTOM(&quot;att&quot;,时间,缓慢进入,缓慢移出,状态1,状态2,...状态N) ANIMATESLOW(&quot;attribute&quot;,state1,state2...stateN) GOTOSCENE(&quot;sceneName&quot;,time,easein,easeout) REDRAW() SET(&quot;attribute&quot;,state1,state2...stateN)","categories":[{"name":"建筑学","slug":"建筑学","permalink":"http://kouqiang.space/categories/%E5%BB%BA%E7%AD%91%E5%AD%A6/"}],"tags":[{"name":"建筑学","slug":"建筑学","permalink":"http://kouqiang.space/tags/%E5%BB%BA%E7%AD%91%E5%AD%A6/"},{"name":"SU","slug":"SU","permalink":"http://kouqiang.space/tags/SU/"}],"author":"寇强"},{"title":"JavaScript——常用功能的实现","slug":"JavaScript——常用功能的实现","date":"2023-01-14T04:00:00.000Z","updated":"2024-05-14T10:42:00.373Z","comments":true,"path":"2023/01/14/JavaScript——常用功能的实现/","link":"","permalink":"http://kouqiang.space/2023/01/14/JavaScript%E2%80%94%E2%80%94%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"JavaScript——常用功能的实现各种功能实现的思路及代码 一、昼夜主题切换功能在没有后台服务器，前端只有静态页面时，用js就可以实现昼夜主题切换。不过缺点是默认主题不能随时间变化，且每刷新一次页面都会恢复为默认样式。 如果有后端，则应该根据客户端请求网页的不同时间来动态创建不同主题的前端页面！ 思路一：更改css文件提前写好两个配色主题（css文件），利用点击按钮绑定js函数去更改头部&lt;link&gt;标签的&lt;href&gt;属性——更改引入的css文件的路径——来实现该想法。 代码实现： 1.body中添加点击按钮，获取元素并绑定点击事件，并新建一个标记昼夜白天切换的变量tips！ 12345678910111213141516171819...&lt;script&gt;window.onload = function()&#123; var btn01 = document.getElementById(&quot;btn-01&quot;); //添加变量以标记昼夜白天，此处建议与css文件名一致，以方便将此值直接应用到文件名处！ var tips = &quot;day&quot;; btn01.onclick = function()&#123; &#125;&#125;&lt;/script&gt;...&lt;body&gt; ... &lt;img src=&quot;./img/moon01.png&quot; id=&quot;btn-01&quot; /&gt; ...&lt;/body&gt; 2.点击事件的实现（重点！） （1）获取头部&lt;link&gt;元素 注：经测试，&lt;link&gt;标签无法通过id获取，可使用TagName获取！ 12var linkList = document.getElementsByTagName(&quot;link&quot;);// 此时获取到的是所有link标签的集合，如果有多个link标签应再确认是哪一个，只有一个的话那就是“linkList[0]” （2）修改&lt;link&gt;标签的href属性 1234567if(tips == &quot;day&quot;)&#123; tips = &quot;night&quot;; linkList[0].href = &quot;./css/&quot; + tips + &quot;.css&quot;;&#125;else&#123; tips = &quot;day&quot;; linkList[0].href = &quot;./css/&quot; + tips + &quot;.css&quot;;&#125; 3.总结 1234567...&lt;script src=&quot;./js/dayNightSwitch.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt; &lt;/script&gt;...&lt;div id=&quot;dayNightDiv&quot;&gt; &lt;img src=&quot;https://www.z4a.net/images/2023/01/14/day_and_night.png&quot; id=&quot;dayNightBtn&quot; /&gt;&lt;/div&gt;... 1234567891011121314window.onload = function()&#123; var btn01 = document.getElementById(&quot;dayNightBtn&quot;); var tips = &quot;day&quot;; var linkList = document.getElementsByTagName(&quot;link&quot;); btn01.onclick = function()&#123; if(tips == &quot;day&quot;)&#123; tips = &quot;night&quot;; linkList[0].href = &quot;./css/新拟态&quot; + tips + &quot;.css&quot;; &#125;else&#123; tips = &quot;day&quot;; linkList[0].href = &quot;./css/新拟态&quot; + tips + &quot;.css&quot;; &#125; &#125;&#125; 该方法修改较为方便，操作简单，最重要的是代码耦合度低！ 思路二：即时更改页面配色默认使用配色1，将配色2写在js里，点击按钮运行该脚本，再点击恢复原来配色 总结：这种方法代码少，但是可读性不强，较难修改和维护，代码耦合度高，在页面简单内容较少时更易操作，但是页面内容一旦多起来就显得捉襟见肘，因此不是很推荐！ 二、轮播图的实现","categories":[{"name":"前端","slug":"前端","permalink":"http://kouqiang.space/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"学习总结","slug":"学习总结","permalink":"http://kouqiang.space/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"},{"name":"前端","slug":"前端","permalink":"http://kouqiang.space/tags/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://kouqiang.space/tags/JavaScript/"}],"author":"寇强"},{"title":"博客搭建流程（0基础开始向）","slug":"博客搭建流程","date":"2022-12-27T16:00:00.000Z","updated":"2023-01-09T16:11:50.406Z","comments":true,"path":"2022/12/28/博客搭建流程/","link":"","permalink":"http://kouqiang.space/2022/12/28/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B/","excerpt":"","text":"博客搭建流程（0基础开始向）（使用GitHub+Hexo） 一、注册GitHub1.访问GitHub访问GitHub方法： 1.访问http://www.github.com.ipaddress.com/，查看GitHub的IP地址 2.找到C:\\windows\\System32\\drivers\\etc\\host文件，在最后添加新的一行，内容为GitHub的IP地址和网址，中间用空格分开，如下，保存好 12140.82.112.4 github.com140.82.112.4 www.github.com 3.打开终端，输入如下指令刷新配置 1ipconfig /flushdns 二、安装Git（我安的2.35）原参考知乎安装教程：个人博客第2篇——Git 2.25.0详细安装步骤 - 知乎 (zhihu.com) git官网：Git (git-scm.com) 三、绑定GitHub并提交文件GitHub上可以直接提交文件，远程仓库与本地仓库可以通过SSH协议或者HTTPS协议这两种方式连接，我们这里用SSH来完成GitHub的绑定并提交文件 SSH（安全外壳协议，Secure Shell 的缩写）是建立在应用层基础上的安全协议。SSH 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议，利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。简单来说，SSH就是保障你的账户安全，将你的数据加密压缩，不仅防止其他人截获你的数据，还能加快传输速度。 1.绑定GitHub打开GitBashHere，用【ssh-keygen -trsa】命令在本机生成公钥(id_rsa.pub)和密钥(id_rsa)，将公钥的文本内容复制到GitHub网站里我的SSHKey里面。（默认公钥密钥生成路径为：C:\\Users\\用户名\\.ssh\\id_rsa.pub） 注：git里面的复制粘贴是Ctrl+ Insert 和 Shift+ Insert 如下图所示，打开你的GitHub👉右上角小头像展开👉Settings👉SSH and GPG keys👉new key👉输入Title(可不填)和Key👉Add SSH key 12345678910111213141516171819202122232425262728293031323334353623163@▒ҵĶ▒▒ӽ▒▒▒▒▒ MINGW64 /h/GitWorkSpace$ sshusage: ssh [-46AaCfGgKkMNnqsTtVvXxYy] [-B bind_interface] [-b bind_address] [-c cipher_spec] [-D [bind_address:]port] [-E log_file] [-e escape_char] [-F configfile] [-I pkcs11] [-i identity_file] [-J [user@]host[:port]] [-L address] [-l login_name] [-m mac_spec] [-O ctl_cmd] [-o option] [-p port] [-Q query_option] [-R address] [-S ctl_path] [-W host:port] [-w local_tun[:remote_tun]] destination [command [argument ...]]23163@▒ҵĶ▒▒ӽ▒▒▒▒▒ MINGW64 /h/GitWorkSpace$ ssh-keygen -trsaGenerating public/private rsa key pair.Enter file in which to save the key (/c/Users/23163/.ssh/id_rsa):Created directory &#x27;/c/Users/23163/.ssh&#x27;.Enter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in /c/Users/23163/.ssh/id_rsa //这是生成密钥的位置Your public key has been saved in /c/Users/23163/.ssh/id_rsa.pub //这是生成公钥的位置The key fingerprint is:SHA256:OQnGcnRhMElRNcl1cYYVEpjiwyTZvQpLc8+wr6DvKB0 23163@▒ҵĶ▒▒ӽ▒▒▒▒▒The key&#x27;s randomart image is:+---[RSA 3072]----+| .*=B++o+o+==|| o.* +o= .oo || . = = . . || + = O . || . S B || E . + o || . .. . || . .o . . || .ooo .. |+----[SHA256]-----+23163@▒ҵĶ▒▒ӽ▒▒▒▒▒ MINGW64 /h/GitWorkSpace$ 验证是否成功： 1ssh -T git@github.com 打入yes回车： 12345678910111223163@▒ҵĶ▒▒ӽ▒▒▒▒▒ MINGW64 /h/GitWorkSpace$ ssh -T git@github.comThe authenticity of host &#x27;github.com (20.205.243.166)&#x27; can&#x27;t be established.ED25519 key fingerprint is SHA256:+DiY3wvvV6TuJJhbpZisF/zLDA0zPMSvHdkr4UvCOqU.This key is not known by any other namesAre you sure you want to continue connecting (yes/no/[fingerprint])? yesWarning: Permanently added &#x27;github.com&#x27; (ED25519) to the list of known hosts.Hi KQ2316336903! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.23163@▒ҵĶ▒▒ӽ▒▒▒▒▒ MINGW64 /h/GitWorkSpace$ 2.提交文件（1）本地没有git仓库①直接将远程仓库克隆到本地 在准备储存仓库的目录下GitBashHere，输入指令【git clone 刚刚复制的仓库地址】 1223163@▒ҵĶ▒▒ӽ▒▒▒▒▒ MINGW64 /h/GitWorkSpace/myRepository01/myRepository01 (main)$ git clone https://github.com/KQ2316336903/myRepository01.git 打开仓库存储目录检查是否与远程仓库一致 ②将新建的文件添加并commit到本地仓库12git add &lt;fileName&gt; //将某文件添加到临时缓冲区/暂存区，若有多个文件，则文件名中间用空格分隔开即可！git commit -m &quot;这里自己填写对于本次提交修改的备注内容&quot; //将文件提交到本地仓库 如果是第一次提交会让你输入用户名和邮箱，按如下格式添加即可： 12git config --global user.name &quot;自己的GitHub用户名&quot;git config --global user.email &quot;账号绑定的邮箱地址&quot; //(注意空格！！) 其他指令 12git log //查看仓库提交日志git status //查看仓库状态 ③将本地仓库的内容push到远程仓库最后将本地仓库提交到远程仓库： 1git push origin master //这里的master在后来的git版本中是main，所以需注意跟自己gitbash窗口中保持一致即可 第一次会弹出这个账户认证窗口 点击登录，会跳转到默认浏览器里，输入账户密码登录后，跟着步骤确认就行了，GitBash窗口会在操作完成后自动push的。 （2）本地有git仓库，并且我们已进行了多次commit操作①建立本地仓库建立仓库文件夹，在这个文件夹内GitBashHere，使用git init命令创建&#x2F;初始化这个仓库 12345623163@▒ҵĶ▒▒ӽ▒▒▒▒▒ MINGW64 /h/GitWorkSpace/myRepository01/demo01$ git initInitialized empty Git repository in H:/GitWorkSpace/myRepository01/demo01/.git/23163@▒ҵĶ▒▒ӽ▒▒▒▒▒ MINGW64 /h/GitWorkSpace/myRepository01/demo01 (master)$ ②关联远程仓库1234567$ git remote add origin https://github.com/KQ2316336903/myRepository01.git23163@▒ҵĶ▒▒ӽ▒▒▒▒▒ MINGW64 /h/GitWorkSpace/myRepository01/demo01 (master)//对于新建的仓库，执行以下命令后的报错忽略不计$ git pull origin masterfatal: couldn&#x27;t find remote ref master （3）总结：先绑定本地仓库，将远程仓库文件同步到本地（git clone和git pull），然后后续有了文件变化时将本地变化git push到远程仓库。 一次性git add多个文件（夹）： 12345git add . //提交所有被修改和新建的文件，但不包括被删除的文件git add -a //all，提交所有已被修改和删除的文件，但不包括新建文件git add -u //update，更新/提交所有已改变的文件 3.其他配置①删除本地仓库删除Git本地仓库的根本原理是删除“Git本地仓库”⾥⾯的根⽬录下⾯的隐藏⽂件夹“.git” ②解决中文名文件无法显示和提交的问题 git bash终端输入git config --global core.quotepath false 窗口界面空白处右键选择“Options”，Text&gt;Loacle设置为zh_CN和UTF-8即可 四、购买域名不买也行，没影响 五、安装Node.js和Hexo1.Node.js①安装官网网址： Node.js (nodejs.org) 除了安装位置没什么改动的，一直next安装好就行了 安装好后可以打开终端检查下 12345C:\\Users\\23163&gt;node -vv16.14.2C:\\Users\\23163&gt;npm -v8.5.0 ②配置设置npm在安装全局模块时的路径和环境变量，因为默认会安C盘，而且后续Hexo可能无法正常使用 先在软件安装目录下新建两个文件夹：node_cache和node_global； 打开终端，根据自己安装的目录输入以下指令 123C:\\Users\\23163&gt;npm config set prefix &quot;G:\\Nodejs\\node_global&quot;C:\\Users\\23163&gt;npm config set cache &quot;G:\\Nodejs\\node_cache&quot; 设置环境变量： 新增系统变量： 编辑用户变量PATH，新建如下： 验证： 以管理员身份运行终端，执行npm install webpack -g： 123456789101112131415C:\\WINDOWS\\system32&gt;npm install webpack -gadded 71 packages, and audited 72 packages in 40s8 packages are looking for funding run `npm fund` for detailsfound 0 vulnerabilitiesnpm noticenpm notice New patch version of npm available! 8.5.0 -&gt; 8.5.5npm notice Changelog: https://github.com/npm/cli/releases/tag/v8.5.5npm notice Run npm install -g npm@8.5.5 to update!npm noticeC:\\WINDOWS\\system32&gt; 2.Hexo①先在GitHub上建立一个新仓库名称格式为“你的用户名.GitHub.io” 创建好后点击Setting，看到如下内容表示这一步完成 ②安装Hexo 首先在G盘新建一个文件夹Blog，进入并GitBashHere，输入npm命令安装Hexo： 1npm install -g hexo-cli *此时hexo安装目录下是没有东西的！ 安装完成后，输入hexo init初始化博客 hexo g静态部署 这时网站已经部署完成，输入hexo s可以查看 浏览器地址栏可以输入上图中HEXO提供的网址进行访问： Ctrl + c停止运行服务器 3.将Hexo部署到GitHub①打开Blog文件夹中的【_config.yml】文件，在最后加上如下内容： 1234deploy: type: git repository: https://github.com/KQ2316336903/KQ23136336903.github.io.git branch: main ②在Blog文件夹内GitBashHere，输入如下命令安装Git部署插件： 1npm install hexo-deployer-git --save ③然后分别输入以下三条命令： 123hexo clean //清除缓存文件db.json和已生成的静态文件publichexo g //hexo generate生成网站静态文件到默认设置的public文件夹hexo d //hexo deploy自动生成网站静态文件，并部署到设定的仓库 弄好之后就可以在浏览器访问你的网页了! 4.卸载Hexo首先在安装目录下执行指令： 1npm uninstall hexo-cli -g 再删除Blog文件夹即可 六、Hexo食用指南1.hexo项目结构12345678.├── _config.yml //整个博客网站的配置文件，里面包含了网站的配置、网址配置、目录配置、主题配置等等内容。├── package.json├── scaffolds├── source //存放用户资源/源码的地方| ├── _drafts| └── _posts└── themes ①_config.yml文件：配置文件1234567891011121314...# Sitetitle: Hexo //网站标题subtitle: &#x27;&#x27; //副标题description: &#x27;&#x27; //描述keywords: //关键字author: John Doe //作者language: en //语言，这里记得要改成“zh-CN”，这样安装不同主题时都可以显示中文timezone: &#x27;&#x27; ...url: http://example.com //url是博客上线后的网址...theme: landscape //主题配置... ②scaffolds文件夹：模板文件夹模板文件夹，里面存放了3个模板文件，依次是草稿模板，页面模板和文章模板。 当我们使用hexo命令生成草稿、页面或者文章的时候，就是复制这些模板。 123├── draft.md //草稿├── FASTPANEL //页面├── post.md //文章 post文章模板： 123456---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;tags:---//新建的文件都会按照此模板的内容新建，带有此文件头。修改此模板则新建的文件头也会随之改变。 ③source文件夹：资源&#x2F;源码文件夹项目根目录下除_post文件夹之外，以_(下划线)开头命名的文件和隐藏的文件在后续解析和部署时都会被忽略；markdown和html文件会被解析并放到public文件夹内，而其它文件会被拷贝过去。 ④themes文件夹：hexo主题存放文件夹存放下载的主题文件 2.写作12345678910hexo s //hexo server，运行hexo服务hexo new 无后缀的文件名 //新建markdown文件，如果此处给文件名加了后缀如ABC.md，那么新建文件的会变成【ABC_md.md】，其他格式也是如此！所以hexo只能新建.md文件？ //在命令行输入的文件名，会被写入到文件头内，最后在网页中的文件名上展示出来，因此网页上展示的文章文件格式有可能和源文件格式不一致！hexo new page 文件夹名 //会在source/下创建一个新文件夹，文件夹内默认会有index.md文件，这样你访问该文件夹名的链接时会显示其内的index.md文件hexo new draft 文件名 //这样创建的文件会被放进source/_drafts文件夹内，作为你的草稿而不会在网页显示hexo server --draft //在网页内预览草稿hexo publish draft myDraft01 //将草稿文件mydraft01.md发布到博客上 文章顺序hexo文章默认是按照创建时间为顺序倒序排列的，因此要改变文章展示顺序，应修改文件头内的date字段的时间； Front-matter文件头1234---title: Hello Worlddate: 2013/7/13 20:46:25--- 预定义的参数： 123456789参数 描述 默认值layout 布局 config.default_layouttitle 文章显示的标题 创建文件时起的名字date 创建日期update 更新日期comments 开启文章评论功能 truetags 标签categories 分类permalink 覆盖文章网址 3.主题安装和配置网友主题推荐：Icarus、Butterfly、next、volantis、fluid等等 icarus：GitHub - ppoffice&#x2F;hexo-theme-icarus: A simple, delicate, and modern theme for the static site generator Hexo. butterfly：Hexo-Butterfly主题(🦋 A Hexo Theme: Butterfly-Official website) (butterfly1.cn)](https://www.butterfly1.cn/index.html) next：NexT 使用文档 (iissnan.com)](http://theme-next.iissnan.com/) volantis：https://volantis.js.org/ fluid：https://hexo.fluid-dev.com/docs/ ①主题下载：GitHub上找到主题所在的仓库，要么用git命令克隆到本地，要么下载压缩包后解压到本地： 方法一，git克隆仓库12git clone 仓库所在地址 themes/主题名 //这里的主题名自定义，在themes下会生成一个以此命名的文件夹存放主题内容git clone https://github.com/theme-next/hexo-theme-next.git themes/next 这种方式应用的主题在更新时只需【git pull】即可！ 方法二，下载压缩包解压解压至路径【~&#x2F;themes&#x2F;主题名】下，该路径下要有主题的配置文件【_config.yml】 ②主题应用：将项目根目录下的配置文件【_config.yml】文件中的【theme: xxxxxx】字段改为要应用的主题名，重启服务即可 ③主题配置主题存放目录下会有主题自己的配置文件【_config.yml】，更改里面的配置信息即可更改主题样式 一般具体的配置方法都会在主题官网的帮助文档里说明。 ​","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"http://kouqiang.space/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"http://kouqiang.space/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"author":"寇强"},{"title":"CSS进阶","slug":"CSS进阶","date":"2022-12-22T13:10:00.000Z","updated":"2023-01-09T16:16:39.488Z","comments":true,"path":"2022/12/22/CSS进阶/","link":"","permalink":"http://kouqiang.space/2022/12/22/CSS%E8%BF%9B%E9%98%B6/","excerpt":"","text":"CSS进阶n.css设置背景渐变色1.线性渐变 123456789101112131415161718* &#123; background: linear-gradient(渐变方向,开始颜色 偏移量...,结束颜色 偏移量);&#125;/* 渐变方向：1.关键字指示to top, to bottom, to left top,等，left和top等关键字的前后顺序无所谓！2.deg角度指示：按照钟表指针方向渐变，0deg为十二点（从下往上），90deg为三点（从左往右），225deg为左下往右上。0~360deg，也可以是负数。颜色用rgb()rgba()或&quot;#xxxxxx&quot;都行，可填写多个达到多色渐变的效果；偏移值设置颜色偏移值，不太明白，感觉很少用到；*/ 2.径向渐变&#x2F;放射渐变 12345678910111213141516* &#123; background: radial-gradient(center,shape,size,start-color...,last-color);&#125;/*center：渐变起点的位置，可以为两个百分比数值，默认是图形正中心；shape：渐变形状，ellipse椭圆，circl圆，默认椭圆。如果容器为正方形则二者相同。上面这俩属性我设置了但是没用！可恶！也不知道问题出在哪儿！size：渐变大小，规定渐变到哪里停止，有四个值： closest-side：最近边 farthest-side：最远边 closest-corner：最近角 farthest-corner：最远角*/ 属性过渡transition属性可用来给元素添加某个属性的过渡效果 1transition: all .2s ease-in-out; transition有四个子属性： transition-property 选择对哪个属性应用过渡，可选值有all、none或者自定义属性名，多个属性之间用逗号隔开： 1transition-property: border,background; transition-duration 过渡动画持续时间，单位为’s’(秒)且不可省略，默认值为0，如： 1transition-duration: .8s; transition-timing-function 动画过渡的线性规律（又称时间曲线），自带6个值： ease：默认值，逐渐变慢； linear：匀速，线性； ease-in：加速； ease-out：减速； ease-in-out：先加速后减速。 transition-delay 设置动画延迟，值也是秒，写法与transition-duration相同。 一般我们使用复合写法，如： 1transition: all .2s ease-in-out; 提示：在实际开发中，建议给元素原属性也加上transition属性，这样就能避免元素恢复原样貌时没有过渡动画的bug。 变形transform属性可使元素变形，包括位移、旋转、缩放、倾斜： 阴影使用box-shadow和text-shadow可以给元素和文本添加阴影： 123box-shadow: h-shadow v-shadow blur spread color inset(outset);text-shadow: h-shadow v-shadow blur color; h-shadow：必需，阴影水平方向上位置，正数向右，负数向左，单位px； v-shadow：必需，阴影垂直方向上位置，正数向下，负数向上，单位px； blur：可选，阴影模糊距离，单位px； spread：可选，阴影的尺寸； color：可选，阴影颜色，值可以是rgba(3,204,204,0.2)或rgb(1,1,1)类型或直接用#bbdbc6hex型数值； inset&#x2F;outset：可选，设置投影为外投影或内投影，默认外投影。 添加多个阴影，用逗号分隔开即可： 1box-shadow: 1px 1px 5px 0 blue inset, 2px 2px 10px rgba(240,240,240,0.2) outset; 滤镜filter属性可以给元素添加图像滤镜：","categories":[{"name":"前端","slug":"前端","permalink":"http://kouqiang.space/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://kouqiang.space/tags/CSS/"},{"name":"学习总结","slug":"学习总结","permalink":"http://kouqiang.space/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"},{"name":"前端","slug":"前端","permalink":"http://kouqiang.space/tags/%E5%89%8D%E7%AB%AF/"}],"author":"寇强"},{"title":"CSS学习总结","slug":"CSS学习总结","date":"2022-12-22T06:56:00.000Z","updated":"2023-01-12T03:23:57.296Z","comments":true,"path":"2022/12/22/CSS学习总结/","link":"","permalink":"http://kouqiang.space/2022/12/22/CSS%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/","excerpt":"","text":"CSS学习总结一、CSS引入方式1.外部引入在HTML文件头部信息内（&lt;head&gt;&lt;/head&gt;标签内）通过&lt;link&gt;标签引入外部CSS文件： 1&lt;link rel=&quot;stylesheet&quot; href=&quot;文件的路径&quot; type=&quot;text/css&quot; /&gt; 此处的rel属性必写且值必须为stylesheet！ type属性可省略，若不省略则属性值必须为text/css！ 2.内部写入在HTML文件头部信息内的&lt;style&gt;&lt;/style&gt;标签内写入CSS代码： 1234567...&lt;style&gt; div &#123; ... &#125;&lt;/style&gt;... 3.行内嵌入直接在元素属性区域写入style属性即定义css样式： 123&lt;P style=&quot;color: pink; font-size: 20px;&quot;&gt; 日暮伯劳飞，风吹乌桕树。&lt;/P&gt; 二、语法规范1234selector &#123; 属性01: 属性值01 属性值02; 属性02: rgba(255,255,255,1) solid red;&#125; 三、CSS基础选择器 基础选择器是由单个选择器构成的； 基础选择器包括标签&#x2F;元素选择器、类选择器、id选择器和通配符选择器。 1.标签&#x2F;元素选择器标签选择器 （元素选择器） 是 指用 HTML 标签名称 作为选择器，按标签名称分类，为页面中某一类标签指定 统一的 CSS 样式。 标签选择器直接写不带尖括号的标签名即可： 1234567891011标签名 &#123; 属性1: 属性值1; 属性2: 属性值2; 属性3: 属性值3; ...&#125;p &#123; color: pink; font-size: 10px;&#125; 2.类选择器和id选择器id属性只允许运用于一个元素，选择器用#id名的语法规则进行选择； class属性运用于多个元素，一个标签可以同时定义多个class属性，多个class名之间用空格分开！选择器用.类名的语法规则进行书写！ 1234567891011121314151617181920212223242526272829303132333435363738&lt;html&gt; &lt;head&gt; &lt;style&gt; /*id选择器*/ #div01 &#123; ... &#125; #div02 &#123; ... &#125; /*class选择器*/ .div &#123; ... &#125; .big &#123; ... &#125; .big, .blue &#123; /*多个选择器之间用半角逗号加空格或换行分隔开*/ ... &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;div01&quot; class=&quot;div big blue&quot;&gt; div01 &lt;/div&gt; &lt;div id=&quot;div02&quot; class=&quot;div big&quot;&gt; div02 &lt;/div&gt; &lt;div id=&quot;div03&quot; class=&quot;div blue&quot;&gt; div03 &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 3.通配符选择器*在 CSS 中，通配符选择器使用“ * ”定义，它表示选取页面中所有元素（标签）。 举例： 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;基础选择器之通配符选择器&lt;/title&gt; &lt;style&gt; * &#123; color: red; &#125; /* 这里把 html body div span li 等等的标签都改为了红色 */ &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;我的&lt;/div&gt; &lt;span&gt;我的&lt;/span&gt; &lt;ul&gt; &lt;li&gt;还是我的&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 4.属性选择器根据属性值选择某类标签，语法： 123456789101112标签名[属性=&quot;属性值&quot;] &#123; &#125;例如：div[width=&quot;1000px&quot;] &#123; ...&#125;或：input[type=&quot;text&quot;] &#123; ...&#125; 四、CSS高级&#x2F;复合选择器在 CSS 中，可以根据选择器的类型把选择器分为 基础选择器 和 复合选择器 ，复合选择器是建立在基础选择器之上，对基本选择器进行组合形成的。复合选择器可以更准确、更高效的选择目标元素（标签）复合选择器是由两个或多个基础选择器，通过不同的方式组合而成的。常用的复合选择器包括：后代选择器、子选择器、并集选择器、伪类选择器等等。 1.后代选择器选择父元素下的所有某类子元素，包括子、孙、重孙等： 12345678910111213141516171819202122232425262728父元素 子元素 &#123; 样式声明&#125;&lt;head&gt; &lt;style&gt; /*选择了最外面&lt;div&gt;里的所有&lt;p&gt;元素*/ &lt;div&gt; &lt;p&gt; &#123; ... &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;p&gt; &lt;h1&gt; &lt;/h1&gt; &lt;/p&gt; &lt;div&gt; &lt;h1&gt; &lt;p&gt; &lt;/p&gt; &lt;/h1&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 2.子&#x2F;层级选择器1元素一&gt;元素二 &#123;...&#125; //中间用大于号连接，无空格！ 只选择元素一下一级的所有元素二（只选择儿子这一层，不涉及孙子等），更深一层的元素不会选择到！ 12345678910111213141516171819202122232425262728&lt;head&gt; &lt;style&gt; /*选择所有&lt;div&gt;下一级的所有&lt;p&gt;元素，因此下面代码运行结果是感叹号和问好都是红色！*/ div&gt;p &#123; ... &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;p&gt; &lt;h1&gt; &lt;/h1&gt; !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! &lt;/p&gt; &lt;div&gt; &lt;h1&gt; &lt;p&gt; &lt;/p&gt; &lt;/h1&gt; &lt;p&gt; ????????????????????????? &lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 3.并集选择器选择满足任一选择器的元素 多个选择器之间用半角逗号分开（出于习惯常常在逗号后面带一个空格）： 123div, p, #id01, .allDiv &#123; ...&#125; 4.交集选择器选择同时满足多个选择器的标签。 交集选择器中如果有标签选择器，那么标签选择器必须位于最前面！ 选择器之间是紧挨着的，没有任何东西分隔！ 123divh1h2 &#123; ...&#125; 五、伪类选择器伪类选择器用于向某些选择器添加特殊效果 1.常见链接伪类选择器主要有以下几类： 1234a:link //未访问时的属性a:visited //访问后的属性a:hover //鼠标悬浮在上面时的属性a:active //鼠标点中一瞬间的属性 注：如果是&lt;a&gt;标签使用该选择器，顺序不可变！ 2.常见结构伪类选择器1234:first-child //第一个节点:last-child //最后一个节点:nth-child(n) //顺数第n个节点（2n表示顺数的所有偶数位节点）:nth-last-child(n) //倒数第n个节点（2n表示倒序所有偶数位节点） 更多请查阅参考：伪类选择器简单总结 3.目标伪类选择器1:target 六、CSS样式1.常用文字样式1234567891011div &#123; color: #ffffff; //字体颜色，HEX值； font-size: 50px; //字体大小，单位一般为px（像素）； font-weight: 500; //字体粗细，可选100到1000之间的十个整百数，100最细1000最粗；或选择normal/bold； font-style: italic; //字体斜体 font-family: &#x27;微软雅黑&#x27;; //字体类型，使用自己电脑安装了的字体，用半角引号包起来才能被识别！&#125; 2.文本格式设置1234567891011text-align: //文字水平对齐方式，可选left、center、right；还可对&lt;img&gt;标签生效！text-decoration: //设置文字上下划线和删除线，可选：顶overline、删除线line-through、底underline、无任何划线none，此处none可应用于去除链接文字的下划线；text-transform: //转换英文文本的大小写，对中文无影响，可选none(无转换)、uppercase(变大写)、lowercase(变小写)、capitalize(只将每个单词的首字母变大写)；text-indent: //控制文本首行的缩进值，新手用像素值如：text-indent: 20px;；font-varient: //将英文设置为小型大写字母，对汉字无影响，属性值为normal时不转换，为small-caps应用生效；line-height: //设置行高而不是行间距！新手用像素单位，如：line-height: 30px;； 3.元素边框样式只需记忆如下常用属性即可： 12345border-width: //边框宽度，单位px；border-style: //边框样式，有实线solid和虚线dashed；border-color: //边框颜色； 一键设置： 1border: 1px solid blue; //此处属性前后顺序随意，不影响效果！ 4.元素背景图片123456789background: skyblue; //设置背景颜色，当背景图片和背景颜色同时被设置时图片会覆盖在背景颜色上面！background-image: url(); //定义图片路径，绝对路径和相对路径都行，路径写在url()的括号内；background-repead: no-repeat; //设置图片是否平铺/重复，可选no-repeat不平铺、repeat-x方向平铺、repeat-y方向平铺、默认值repeat两个方向都平铺；background-position: center; //设置图片的放置位置，属性值可为这五个关键词：left right top bottom center，可单个或混合任意两个搭配使用如：center居中对齐，top居中顶对齐，bottom right右下对齐，center bottom居中底对齐；属性值也可为像素值，第一个值为left效果的左边距，第二个值为top效果的上边距如：center 50px效果为垂直居中对齐距离上边框50px；background-attachment: fixed; //设置背景图片是否随屏幕内容滚动，属性值fixed为固定，scroll为滚动； 背景样式的复合写法： 12345/*此处属性前后顺序随意！*/background: 背景颜色 背景图片地址 背景图片平铺 背景图片滚动 背景图片方位;background: rgba(255,255,255,0.5) url(./img/01.png) no-repeat fixed center;background: rgb(240,240,240) left center fixed url(./img/网站.png) no-repeat; 5.图片样式（1）图片尺寸和图片边框12345678910img &#123; width: 100px; height: 100px; border-width: 1px; border-style: solid; border-color: red; border: 1px solid red;&#125;&lt;img src=&quot;./img/01.jpg&quot; /&gt; （2）图片设置水平和垂直对齐水平对齐可用text-align: left/center/right设置，注意是设置图片的父标签，就会应用到&lt;img&gt;标签上，如果设置在图片标签上则不生效！ 1234567#id05 &#123; text-align: center; &#125; &lt;div id=&quot;id05&quot;&gt; &lt;img src=&quot;img/画板.png&quot; /&gt;&lt;/div&gt; 垂直对齐细嗦： 垂直对齐：vertical-align属性 vertical-align属性取值 说明 top 顶部对齐 middle 中部对齐 baseline 基线对齐 bottom 底部对齐 解决图片底部默认空白缝隙问题：bug：图片底侧会有一个空白缝隙，原因是行内块元素（图片）会和文字的基线对齐。主要解决方法有两种：给图片添加 vertical-align:middle | top| bottom 等。 （提倡使用的）把图片转换为块级元素 display: block; 6.列表项前符号样式选择列表中的&lt;li&gt;标签，用list-style-type属性可以自定义项前符号样式： 一般对有序列表应用这些样式： list-style-type属性值 说明 decimal 阿拉伯数字 lower-roman 小写罗马数字 upper-roman 大写罗马数字 lower-alpha 小写英文字母 upper-alpha 大写英文字母 lower-greek 小写希腊字母 一般对无序列表应用这些样式： list-style-type属性值 说明 disc 实心圆 circle 空心圆 square 实心方块 还可以自定义图片为样式：123li &#123; list-style-image: url(./imgs/01.png);&#125; 此处的图片尺寸为100%，原图大小，因此选择图片时要注意尺寸！ 注：以上所有样式都可以应用到无序列表项和有序列表项，但自定义列表不会生效！ 7.表格样式（1）表格边框123table, th, td &#123; border: 1px solid black;&#125; 像这样加了边框之后table和td的边框会显得不美观，这时我们可以给table标签设置border-collapse： collapse属性来合并相邻边框： 1234table td &#123; border-collapse: collapse; border: 1px solid black;&#125; Bug：最顶部的边框变粗了！？ （2）宽度、高度、边框间距1234567table &#123; width: 100px;&#125;tr &#123; height: 100px;&#125; 在CSS中，我们使用border-spacing属性来定义表格边框间距。语法：border-spacing:像素值;说明：该属性指定单元格边界之间的距离，只需要在table元素设置就可以生效。当只指定了1个像素值时，这个值将作用于横向和纵向上的间距；当指定了2个length值时，第1个作用于横向间距，第2个作用于纵向间距。 123table &#123; border-spacing: 5px;&#125; （3）表格标题位置caption-side: bottom;该属性可定义表格标题位置，可选属性值有top和bottom，定义在table或者caption中都能生效： 1234567table &#123; caption-side: bottom;&#125;caption &#123; caption-side: bottom;&#125; 8.CSS盒子模型所有HTML元素可以看作盒子，盒子模型不是指定某一个元素，而是囊括所有的HTML的块级元素。 在CSS中，”box model”这一术语是用来设计和布局时使用。 CSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：边距，边框，填充，和实际内容。 盒模型允许我们在其它元素和周围元素边框之间的空间放置元素。 下面的图片说明了盒子模型(Box Model)： （1）盒子边框border边框由三部分组成，分别是边框线宽border-width、线条样式border-style、线条颜色border-color： 名称 描述 border-width 边框线宽 border-style 边框线条样式，有以下四种：无边框none、实线solid、虚线dashed、点线dotted border-color 边框颜色 以上三个属性可单独设置，也可统一设置： 1234567border-width: 1px;border-color: red;border-style: solid;/*等价于：*/border: solid red 1px; //此处的属性顺序随意 注：边框宽度会影响盒子的实际尺寸！ （2）盒子内外边距padding和marginpadding和margin都有上下左右之分： 123456789padding-toppadding-rightpadding-bottompadding-leftmargin-topmargin-rightmargin-bottommargin-left padding和margin可以单独设置四个边，也可以一次性设置好四个边： 他（们）的值可以有一到四个，分别表示不同的位置： 1234567padding: 5px; //上下左右padding: 5px, 1px; //上下，左右padding: 5px, 1px, 2px; //上，左右，下padding: 5px, 1px, 2px, 4px; //顺时针：上，右，下，左 注：如果盒子已经有了具体尺寸，再设置padding的话，会撑大盒子尺寸！ 有关margin： 可以定义盒子的左右外边距为auto，这样会使得位于同一行的盒子水平居中： 12345margin: 10px auto;或：margin: auto;或：margin: 10px auto 10px; 垂直外边距合并： 上下两个盒子的外边距会合并为两个盒子margin较大的那个值而不是相加！ 上外边距塌陷： 对于两个嵌套关系（父子关系）的块元素，父元素有上外边距同时子元素也有上外边距，此时父元素会塌陷较大的外边距值。 解决方法：绝对定位的盒子不会有上述问题，下面再讲。 （3）清除内外边距网页元素很多都带有默认的内外边距，而且不同浏览器默认的也不一致。因此我们在布局前，首先要清除下网页元素的内外边距。 12padding: 0; /* 清除内边距 */margin: 0; /* 清除外边距 */ 9.浮动布局（1）传统网页布局的三种方式网页布局的本质——用 CSS 来摆放盒子。 把盒子摆放到相应位置。CSS 提供了三种传统布局方式(简单说,就是盒子如何进行排列顺序)： 普通流（标准流） 浮动 定位 标准流（普通流&#x2F;文档流） 所谓的标准流: 就是标签按照默认方式排列。 块级元素会独占一行，从上向下顺序排列。常用元素：div、hr、p、h1~h6、ul、ol、dl、form、table 行内元素会按照顺序，从左到右顺序排列，碰到父元素边缘则自动换行。常用元素：span、a、i、em 等。以上都是标准流布局，我们前面学习的就是标准流， 标准流是最基本的布局方式 。这三种布局方式都是用来摆放盒子的，盒子摆放到合适位置，布局自然就完成了。 （2）浮动布局HTML任何实体元素都可以被设置float浮动属性，设置后元素大小默认根据内容来定，当然也可以自己指定尺寸。 设置了浮动（float）的元素最重要特性： 脱离标准普通流的控制（浮） 移动到指定位置（动）, （俗称脱标） 浮动的盒子不再保留原先的位置 浮动元素会具有行内块元素特性。 任何元素都可以浮动。不管原先是什么模式的元素，添加浮动之后具有 行内块元素 相似的特性。 如果块级盒子没有设置宽度，默认宽度和父级一样宽，但是添加浮动后，它的大小根据内容来决 浮动的盒子中间是没有缝隙的，是紧挨着一起的 行内元素同理 1234567891011.containner, div &#123; float: left;&#125;三个属性：left向左、right向右、默认值none自身无浮动但允许左右有浮动元素清除浮动：div &#123; clear: both;&#125;三个属性：left清除左侧、right清除右侧、both清除左右两侧 10.定位布局让盒子自由的在某个容器内移动位置或者固定屏幕中某个位置，并且可以覆盖住其他盒子。 （1）定位组成定位 &#x3D; 定位模式 + 边偏移 ①定位模式由CSS的position属性定义定位模式： 属性值 描述 static 静态定位 relative 相对定位 absolute 绝对定位 fixed 固定定位 ②边偏移边偏移就是ing位的盒子移动到最终的位置，有如下属性： 属性 示例 描述 top top: 80px; 顶部偏移量，定义元素相对于父元素上边线的距离×，向下移动的距离√ bottom bottom: 90px; 底部偏移量，定义元素相对于父元素下边线的距离×，向上移动的距离√ left left: 100px; 左侧偏移量，定义元素相对于父元素左边线的距离×，向右移动的距离√ right right: 10px; 右侧偏移量，定义元素相对于父元素右边线的距离×，向左移动的距离√ （2）静态定位（没用）静态定位是元素的默认定位方式，即无定位的意思，语法： 123选择器 &#123; position: static;&#125; （3）相对定位relative作用：相对于原来默认布局中的位置来偏移！ 语法： 1234选择器 &#123; position: relative; top/bottom/left/right: 10px;&#125; 相对定位的特点： 移动的时候参照的是自己原来的位置 原来在标准流的位置继续占有，后面的盒子仍然以标准流的方式对待它 （4）绝对定位abdolute绝对定位是元素在移动位置的时候，是相对于它祖先元素来说的。 如果没有祖先元素或者祖先元素没有定位，则以浏览器为准定位（Document 文档）。 语法： 1234选择器 &#123; position: absolute; top/bottom/left/right: 10px;&#125; 子绝父相： 子级是绝对定位的话，父级要用相对定位。 ① 子级绝对定位，不会占有位置，可以放到父盒子里面的任何一个地方，不会影响其他的兄弟盒子。 ② 父盒子需要加定位限制子盒子在父盒子内显示。 ③ 父盒子布局时，需要占有位置，因此父亲只能是相对定位。 这就是子绝父相的由来，所以相对定位经常用来作为绝对定位的父级。 总结： 因为父级需要占有位置，因此是相对定位， 子盒子不需要占有位置，则是绝对定位 当然，子绝父相不是永远不变的，如果父元素不需要占有位置，子绝父绝也会遇到。 （5）固定定位fixed固定定位是元素固定于浏览器可视区的位置。主要使用场景： 可以在浏览器页面滚动时元素的位置不会改变。 语法： 1234选择器 &#123; position: fixed; top/bottom/left/right: 10px;&#125; 固定定位的特点： 以浏览器的可视窗口为参照点移动元素，跟父元素无关，也不随滚动条滚动！ 固定定位不再占有原来的空间和位置！（脱标了） （6）粘贴定位sticky可以被认为是相对定位和固定定位的混合 语法： 1234选择器 &#123; position: sticky; top/bottom/left/right: 10px;&#125; 粘性定位的特点： 以浏览器的可视窗口为参照点移动元素（固定定位特点） 粘性定位占有原先的位置（相对定位特点） 必须添加 top 、left、right、bottom 其中一个才有效 跟页面滚动搭配使用。 兼容性较差，IE 不支持。 （7）总结 一定记住 相对定位、固定定位、绝对定位 两个大的特点： 1. 是否占有位置（脱标否） 2. 以谁为基准点移动位置。 学习定位重点学会子绝父相。 11.弹性布局display: flex12.过渡动画","categories":[{"name":"前端","slug":"前端","permalink":"http://kouqiang.space/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://kouqiang.space/tags/CSS/"},{"name":"学习总结","slug":"学习总结","permalink":"http://kouqiang.space/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"},{"name":"前端","slug":"前端","permalink":"http://kouqiang.space/tags/%E5%89%8D%E7%AB%AF/"}],"author":"寇强"},{"title":"JavaScript——基础篇","slug":"JavaScript——基础篇","date":"2022-10-17T14:56:00.000Z","updated":"2024-05-14T10:48:10.185Z","comments":true,"path":"2022/10/17/JavaScript——基础篇/","link":"","permalink":"http://kouqiang.space/2022/10/17/JavaScript%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%AF%87/","excerpt":"","text":"JavaScript——基础篇一、入门介绍等（一）JavaScript的组成部分： ECMAScript 整个JavaScript的核心，包含基本语法、变量、关键字、保留字、数据类型、语句、函数等，各平台都使用ECMA标准，因此不存在不同系统不兼容问题。 123ECMAScript核心——JavaScript面向对象编程Java 是面向对象，写Java程序，写类和对象。而JavaScript是基于对象，写Js，不用创建类，使用Js内部已经定义好的对象。 DOM 文档对象模型Document Object Model，包含整个HTML页面的内容； BOM 浏览器对象模型Broswer Object Model，包含整个浏览器相关内容。BOM没有规范标准，因此提供的方法可能存在兼容性问题。 （二）基本语法规则1.区分大小写2.变量是弱类型的定义变量只用var运算符，变量无特定类型，可以用var初始化任意值。 因此，可以随时改变变量所存储数据的类型（尽量避免这样做！）。 3.每行代码结尾的分号;可省略，但不建议这样做！4.注释有两种：单行和多行与Java一样，单行注释用//标记开始，多行注释用/* 注释内容 */标记。 5.括号表示代码块从Java中借鉴代码块的概念，即表示一系列应该按顺序执行的语句，用大括号&#123;&#125;括起来。 （三）变量1.变量初始化和作用域变量名只能是字母、下划线、数字（不能在开头）。 js中的变量可以不必初始化，用var初始化的变量是局部变量，没有用var初始化的变量是全局变量（即使写在方法内部！）： 12var test01 = &quot;19083&quot;; //变量test01是局部变量；test02 = test01 + &quot;10107&quot;; //test02是全局变量。 全局变量的作用域是该变量定义后的所有代码，局部变量是定义位置至所在代码片段结束的右花括号&#125;。 全局变量在同名局部变量所在定义域内失效！ 2.关键字和保留字与Java类似，定义变量方法名等都不要乱用即可。 3.原始数据类型ECMAScript有五种原始类型：Undefined、Null、Boolean、Number、String。 当变量声明但未进行赋值时，它此时的类型就是Undefined，而null是空对象的引用。 对某变量或值调用typeof运算符可返回该变量的类型： 变量原始类型 调用typeof的返回值 备注 Undefined undefined 未定义值，表示变量未赋值 Boolean boolean true&#x2F;false Number number 包括整数和浮点数，溢出时输出特殊值(-)Infinity，运算异常输出特殊值NaN Null object 用于定义空的或不存在的引用 String string 单引号双引号皆可 4、自动类型转换 类型 转换为数值型数据的结果 转换为逻辑型数据的结果 转换为字符串型数据的结果 undefine NaN false “undefined” null 0 false “null” 数值型 - 0 = false, NaN = false, 其它 = true NaN、0或者与数值相对应的字符串 逻辑型 true &#x3D; 1, false &#x3D; 0 - false = &quot;false&quot;, true = &quot;true&quot; 字符串型 全为数字则转换为数字，否则为NaN 若长度为0则为false，否则为true - 其他对象 NaN true 若对象存在则结果为toString()的值，否则为undefined （四）运算符一元运算符、位运算符、逻辑运算符、加减乘除号、条件运算符、赋值运算符、三目运算符、关系运算符都与Java一样，不一样的只有： 1、等性运算符=： 单个等号为赋值运算符，与Java相同； 两个等号==： 仅比较变量的值不比较变量类型； 不是同一数据类型的变量会先进行类型转换再比较； 绝对等于===： 比较变量的类型和值，先比较类型，如果数据类型不相等那么直接返回false，类型相同再比较值； 没有任何类型转换； 如果两个值都是null或都是undefined那么返回true，null和undefined比较则返回false； 如果两个值都是布尔类型的true或false，那么返回true，否则返回false； 不绝对等于!==： 同上，相反！ 其它与Java一致 2、字符串运算符 运算符 描述 备注 + 连接两个字符串 两个操作数都是数字才会变成算术运算符！ += 连接两个字符串并将结果赋值给第一个字符串 3、其它 逗号：可将多个表达式排列在一起，整个表达式的值为最后一个表达式的值： 123var a, b, c, d;a = (b = 1, c = 2, d = 3);alert(a); //a = 3 new：与java一样，用来从实例创建新对象： 12对象实例名称 = new 对象类型(参数)Arr01 = new Array(); //创建数组对象 4、运算符优先级 优先级 结合性 运算符 最高 向左 .、[]、() ++、--、-、!、delete、new、typeof、void 向左 *、/、% 向左 +、- 向左 &lt;&lt;、&gt;&gt;、&gt;&gt;&gt; 向左 &lt;、&lt;=、&gt;、&gt;=、in、instanceof 向左 ==、!==、===、!=== 向左 &amp; 向左 ^ 向左 &#96; 向左 &amp;&amp; 向左 &#96; 向右 ?: 向右 = 向右 *=、/=、%=、+=、-&#x3D;、&lt;&lt;=、&gt;&gt;=、&gt;&gt;&gt;=、&amp;=、^=、&#96; 最低 向右 , 左结合：a+b+c = (a+b)+c，右结合：&#39;a=b=1&#39; = &#39;b=1,a=b&#39;。 （五）条件判断与循环控制 if else 12345if(判断语句)&#123; &#125;else&#123; &#125; 判断语句为真则执行语句块，否则执行else语句块。 switch 123456789101112131415switch()&#123; case 常量表达式1: 语句1; break; case 常量表达式2: 语句2; break; ... case 常量表达式n: 语句n; break; default: 匹配失败时默认执行的语句n+1; break;&#125; default部分可省略。 while 123while(循环条件)&#123; ...&#125; 条件为真，执行循环体，直到不满足条件。 do while 123do&#123; ...&#125; while(循环条件); 先执行一遍循环体，再判断条件，条件为真，执行循环体，直到不满足条件。 for() 条件为真，执行循环体，直到不满足条件。 continue：结束本次循环，开始下一次循环，只能用在for、while、do while中。 break：跳出语句所在层的循环（而不是所有循环！）。 二、函数与对象（一）函数1、函数的定义用function关键字定义函数： 1234function 函数名(形参列表)&#123; ... [return ...]&#125; 一个函数最多可以有255个参数。 2、函数的调用（1）简单手动调用过于经典，不再赘述。 （2）在事件响应中调用函数绑定响应事件： 12345678&lt;script type=&quot;text/javascript&quot;&gt; function test01()&#123; alert(&quot;单击了！&quot;); &#125;&lt;/script&gt;&lt;body&gt; &lt;p1 onClick=&quot;test01();&quot;&gt;点我送地狱火！&lt;/p1&gt;&lt;/body&gt; （3）通过链接调用函数12345678&lt;script type=&quot;text/javascript&quot;&gt; function test01()&#123; alert(&quot;单击了！&quot;); &#125;&lt;/script&gt;&lt;body&gt; &lt;a href=&quot;javascript:test01();&quot;&gt;点我送一念神魔！&lt;/a&gt;&lt;/body&gt; （4）函数的参数因为js语言的特性，形参列表可以只写变量名不写var： 123function userInfo(name, sex, age)&#123; ...&#125; 其它过于经典，不再赘述。 （5）函数的嵌套定义与调用js允许嵌套定义和调用函数，但影响可读性和健壮性，一般不建议这么做。 3、js的几个内置函数 parseInt() 返回字符串的前几位数字，若首位不是数字则返回NaN： 1parseInt(stringName, [n]); //参数n用于指出字符串中的数据是几进制的数据，通常省略 parseFloat() 返回字符串的前几位浮点型数据，若首位不是数字则返回NaN，若为整数则返回的也是整数： 1parseFloat(stringName); isNaN() 检验数字型数据值是否为NaN，是则返回true，否则返回false： 1isNaN(numName); //namName为需检验的数字的变量名 isFinite() 检验某数字是否有限，有限或可转换为有限数字则返回true，若为NaN或无穷大则返回false： 1isFinite(numName); //namName为需检验的数字的变量名 eval() 参数可以是某个算术表达式，也可以是一部分js代码，作用就是执行它： 123document.write(eval(&quot;1+2+3&quot;));document.write(&quot;&lt;br /&gt;&quot;);eval(&quot;m=2, n=3; document.write(m*n)&quot;); encodeURI() 对url中的特殊字符进行编码。 decodeURI() 对url进行解码。 4、匿名函数（1）在表达式中定义匿名函数就是将函数看作一个参数或变量： 1var i = function(...)&#123;...&#125;; （2）使用Function()对象来构造函数1234var 变量名 = new Function(&quot;形参1&quot;, &quot;形参2&quot;, ..., &quot;函数体&quot;);var sumNum = new Function(&quot;m&quot;, &quot;n&quot;, &quot;alert(m*n)&quot;);sumNum(5,5); （二）对象1、js的对象 在JavaScript 中可以使用3种对象，即自定义对象、内置对象和浏览器对象。内置对象和浏览器对象又称为预定义对象： 在JavaScript 中将一些常用的功能预先定义成对象，这些对象用户可以直接使用，这种对象就是内置对象。这些内置对象可以帮助用户在编写程序时实现一些最常用、最基本的功能，例如Math、Date、String、Array、Number、Boolean、Global、Object和RegExp对象等。 浏览器对象是浏览器根据系统当前的配置和所装载的页面为JavaScript提供的一些对象。例如document、window对象等。 自定义对象就是指用户根据需要自己定义的新对象。 2、js对象的创建（1）直接创建12345var 对象名 = &#123; 属性名1: 属性值1, 属性名2: 属性值2, ...&#125; （2）通过自定义构造函数创建对象12345678function Student(name, sex, age)&#123; this.name = name; this.sex = sex; this.age = age; alert(&quot;构造对象实例的：\\n姓名：&quot; + this.name + &quot;，性别：&quot; + this.sex + &quot;，年龄：&quot; + this.age + &quot;。\\n&quot;);&#125;var WangLang = new Student(&quot;王朗&quot;, &#x27;男&#x27;, 76); 运行结果： 使用new运算符创建对象实例后，js会接着自动调用使用的构造函数，执行构造函数中的程序。 （3）通过Object对象创建Object对象是js的内部对象，它提供了对象的最基本功能，这些功能构成了所有其他对象的基础，使用该对象可创建一个没有任何内容的空对象： 1[var] objName = Object([]); JavaScript中的Object是所有对象的基类型，它具有一些内部属性和方法，但并非所有这些都是直接访问的，因为一些属性和方法是用于JavaScript引擎内部使用的。以下是一些常见的内部属性和方法： constructor：对创建对象的函数的引用。 prototype：提供一个原型对象，用于为一个特定类的所有实例定义属性和方法。 __proto__：指向当前对象的原型对象的链。 （4）修改对象①对象添加属性或方法通过prototype()函数来给对象（而不是实例！）添加属性或方法： 123456789101112131415161718192021222324对象名.prototype.新属性名 = this.新属性名;对象名.prototype.新方法名 = function()&#123;...&#125;function Student(name, sex, age)&#123; this.name = name; this.sex = sex; this.age = age; alert(&quot;构造对象实例的：\\n姓名：&quot; + this.name + &quot;，性别：&quot; + this.sex + &quot;，年龄：&quot; + this.age + &quot;。\\n&quot;);&#125;Student.prototype.camp = this.camp;Student.prototype.motto = this.motto;Student.prototype.alertCamp = function()&#123; alert(&quot;阵营：&quot; + this.camp + &quot;。\\n&quot;);&#125;Student.prototype.alertMotto = function()&#123; alert(this.motto + &quot;。\\n&quot;);&#125;var WangLang = new Student(&quot;王朗&quot;, &#x27;男&#x27;, 76);WangLang.camp = &quot;曹操&quot;;WangLang.motto = &quot;神文圣武，继承大统！&quot;;WangLang.alertCamp();WangLang.alertMotto(); ②给实例添加属性或方法直接给不存在的属性赋值就会自动添加该属性： 12345WangLang.foe = &quot;诸葛村夫&quot;;WangLang.alertFoe = function()&#123; alert(&quot;一生之敌：&quot; + this.foe);&#125;WangLang.alertFoe(); （5）对象访问语句①for in语句用于遍历对象的所有属性和方法，新建一个变量用来存储所有属性和方法，且不需提前知道其属性或方法的个数： 12345678for(新建变量名 in 目标对象名)&#123; 属性名[新建变量名];&#125;for(uuXy in WangLang)&#123; alert(uuXy + &#x27;\\n&#x27;); //输出的是属性/方法名 alert(WangLang[uuXy] + &#x27;\\n&#x27;); ////输出的是属性/方法的值！&#125; ②with语句用于在访问某对象的属性或方法时，不需重复调用对象名而直接使用其属性或方法，简化代码： 123with(WangLang)&#123; alert(name + sex + age + camp + motto + foe);&#125; 三、Javascript常用内部对象（一）Math对象提供了大量的数学常量和数学函数，不可创建，直接调用。 1、Math对象常用属性： 属性 描述 E 欧拉常量（2.718281828459045） LN2 2的自然对数（0.6931471805599453） N10 10的自然对数（2.3025850994046） LOG2E 以2为底e的对数（1.4426950408889633） PI 圆周率（3.141592653589793） SQRT2 2的平方根（1.4142135623730951） 2、Math对象常用方法： 方法 描述 ceil(x) 向上取整 floor(x) 向下取整 sin(x), cos(x), tan(x) 正弦，余弦，正切 random() 返回0-1之间的随机数 max(x1, x2, ..., xn) 求参数列表中的最大值 min(x1, x2, ..., xn) 求参数列表中的最小值 log(x) 求x的自然对数 pow(x, y) 求x的y次方 round(x) 对x四舍五入 sqrt(x) 求x的平方根 abs(x) 求x的绝对值 （二）Date对象可用于操作时间和日期，需创建。 1、创建Date对象的几种方法（1）无参数：以当前时刻创建Date对象12var myDate01 = new Date();alert(myDate01); （2）以指定日期和时刻创建Date对象： 参数为数字： 1234var myDate02 = new Date(年份,月份-1,日期[,时[,分[,秒[,毫秒]]]]);var myDate02 = new Date(2024,4,20,00,00,00); //2024年5月20日00:00:00alert(myDate02); 参数为字符串： 月份不用-1！ 12345var myDate03 = new Date(&quot;月 日, 年 小时:分钟:秒&quot;); //月份用英文表示其余用数字表示var myDate03 = new Date(&quot;年/月/日 时:分:秒&quot;)var myDate03 = new Date(&quot;may 21, 2024 13:14:00&quot;); var myDate03 = new Date(&quot;2024/5/21 13:14:00&quot;); 2、Date对象属性和方法好像没什么特殊属性？。。。 常用内部方法： 方法 描述 getDate()和setDate() 获取和设置日期（几号），返回&#x2F;输入值为数字1-31 getDay() 获取星期，返回数字0-6 getMonth()和setMonth() 获取和设置月份，返回&#x2F;输入值为数字0-11 getFullYear()和setFullYear() 获取和设置年份，返回&#x2F;输入值为完整的四位数字 getHours()和setHours() 获取和设置小时，返回&#x2F;输入值为数字0-23 getMinuts()和setMinuts() 获取和设置分钟，返回&#x2F;输入值为数字0-59 getSeconds()和setSeconds() 获取和设置秒数，返回&#x2F;输入值为数字0-59 getSeconds()和setSeconds() 获取和设置毫秒，返回&#x2F;输入值为数字0-999 getTime() 获取Date对象的时刻距离1970年1月1日的毫秒数 setTime() 将Date对象的时刻设置为以1970年1月1日为起点，加上实参的毫秒数所对应的日期 toString() 将时刻转换为字符串 toDateString() 将日期部分转换为字符串 toTimeString() 将时间部分转换为字符串 toUTCString() 根据世界时将时刻转换为字符串 toLocaleString() 根据本地时间格式，将时刻转换为字符串 toLocealeDateString() 根据本地时间格式，将日期部分转换为字符串 toLocaleTimeString() 根据本地时间格式，将时间部分转换为字符串 （三）数组对象1、数组的定义 用值创建： 1arr00 = [100, &quot;hallo world!&quot;, true]; //用方括号括起来 先创建再赋值： 12345//先创建再赋值：arr01 = new Array(); //长度为0的空数组arr01[0] = 10;arr01[1] = 20;arr01[2] = 30; //此时长度为3 指定长度： 12arr02 = new Array(5);alert(arr02[3]); //undefined 创建的同时赋值： 1arr03 = new Array(100, &quot;java nb&quot;, false); 2、数组的内部属性和方法（1）内部属性 .length：数组长度。 也可使用prototype向数组对象添加自定义的属性或方法。 （2）内部方法 .concat(arrayX, arrayX, ...) 将其他数组连接到当前数组的末尾，返回一个全新的数组，原来的数组不发生任何变化。 参数至少有一个，可以是数组对象也可以是具体的值。 .push(element1, element2,...) 向原数组的末尾添加一个或多个元素（可以是数组元素也可以是数组对象），并返回添加后的数组长度。 .shift() 删除数组的第一个元素，返回删去的值。 .unshift(newElement1, newElement2,...) 向数组的开头位置依次添加一个或多个元素，可以是数组元素也可以是数组对象。 .pop() 删去最后一个元素，并返回删去的元素。 .splice(start, length, element1, element2,...) 作用：从数组的start位置（数组下标）开始，删去length个元素，并在start位置插入新的多个元素。 参数start为必选项，其他为可选项。 若length缺省，则删去start位置与后面的所有元素！ 1234var arr01 = [1, 2, 3];var arr02 = [&#x27;四&#x27;, &#x27;五&#x27;];arr01.splice(1, 0, &quot;乃琳&quot;, arr02);alert(arr01); .reverse() 逆置数组。 .sort() 按照编码顺序排序，若要按照其他方式排序则需要提供排序函数名作为sort()的参数。 .slice(start, end) 获取数组的部分片段，从start开始到end结束。 start：开始位置，必选项，若为负数则表示从数组末尾往前算，如-1是最后一个元素，-2是倒数第二个元素。 end：结束位置的后一个位置，可选项，若缺省则选中start后的所有元素。 返回值是一个新数组。 .toString() 将数组转换为一个新的字符串并返回。 .join(separator) 将数组转换为一个新的字符串，并用separator参数将每个数组元素分隔开。 separator可省略，缺省则以半角逗号分隔。 12var arr01 = [1, 2, 3, &#x27;四&#x27;, &#x27;五&#x27;];alert(arr01.join(&quot;逗号&quot;)); （四）String对象 属性和方法 1、属性同数组一样有length属性。 也有constructor和prototype属性。 2、内部方法 .charAt(index) 返回index处的字符。 .indexOf(substring, startindex) 返回某个子串首次出现的位置，查找失败返回-1。 substring：必选项，要查找的子串。 startindex：开始查找的位置，可选项，缺省则从头开始。 .lastIndexOf(substring, startindex) 返回某个子串最后出现的位置，查找失败返回-1。 参数同上。 .slice(startindex, endindex) 使用方法同数组的.slice()方法。 .substr(startindex, length) 从指定位置提取指定长度的子串。 startindex：必选项，开始位置，因兼容问题该参数不建议使用负数。 length：可选项，缺省则选到结尾。 substring(startindex, endindex) 提取指定两个索引号之间的子串，参数都必须是正整数，结尾处不包括endindex处的字符。 .toLowerCase() 转换为小写。 .toUpperCase() 转换为大写。 .concat() 用法同数组的该方法。 .split(separator, limit) 将一个字符串用原本存在的separator字符分割成多个字符串数组，再返回结果中的前limit个数组。 separator：必选参数，指定的分隔符，js会将原字符串中的所有能与该参数匹配的子串替换为半角逗号，再返回。若内容为空字符串&quot;&quot;则表示将每个字符都用半角逗号分隔开。 limit：可选参数，正整数，表示返回分割结果中的前limit个数据。 12var str01 = new String(&quot;An apple a day keeps the doctor away.&quot;);alert(str01.split(&quot;a&quot;));","categories":[{"name":"前端","slug":"前端","permalink":"http://kouqiang.space/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://kouqiang.space/tags/%E7%BC%96%E7%A8%8B/"},{"name":"前端","slug":"前端","permalink":"http://kouqiang.space/tags/%E5%89%8D%E7%AB%AF/"},{"name":"js","slug":"js","permalink":"http://kouqiang.space/tags/js/"}],"author":"寇强"},{"title":"HTML学习总结","slug":"Html学习总结","date":"2022-07-19T15:55:00.000Z","updated":"2024-05-13T09:38:59.990Z","comments":true,"path":"2022/07/19/Html学习总结/","link":"","permalink":"http://kouqiang.space/2022/07/19/Html%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/","excerpt":"","text":"HTML学习总结123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;页面标题&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; ... &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 一、关于HTML（一）.htm和.html文件的区别1、.htm与.html没有本质上的区别，表示的是同一种文件，只是适用于不同的环境之下。2、DOS仅能识别8+3的文件名，所以*.htm的命名方法可以被DOS识别，而*.html的文件命名方式不能被之识别。3、在UNIX系统中，网页必须使用.html扩展名，如果是.htm，在浏览器中打开时则出现源代码；Windows中支持两种扩展名。也可以说，htm和html是Windows和UNIX对抗的产物。4、如果在网页中同时存在index.html与index.htm，浏览器将优先解释index.html。 （二）侧重点HTML 是主要应用于网页的结构，所以要在学习的时候要记住：关注标签的语义而不是样式。样式这些展现出来的是CSS的作用 ，所以需要去关注的是标签的意义。如 &lt; strong &gt;和&lt; b &gt; 前者是用来强调内容的重要性，而后者只是为了加粗字体，但是二者表现出的效果是一样的。其次还有例如标题的大小h1~h6 这些的意义是用来体现该部分的重要性，而不是为了去设置他的大小，设置大小完全可以利用css去完成。还有当你编写的代码出现有些问题时 ，浏览器会主动纠正 ，&lt; p &gt;元素里不能放任何块元素。 （三）其它1.目前HTML标签是不区分大小写的，但还是建议规范代码格式以提高可读性！2.元素可以拥有属性，属性值用双引号引起来，如&lt;a href=&quot;romanticism.space&quot;&gt;； 二、基本标签（body部分）1.标题标签h1~h6依次变小123456&lt;h1 align=&quot;center&quot;&gt;标题&lt;/h1&gt;&lt;h2 align=&quot;left&quot;&gt;标题&lt;/h2&gt;&lt;h3 align=&quot;right&quot;&gt;标题&lt;/h3&gt;&lt;h4&gt;标题&lt;/h4&gt;&lt;h5&gt;标题&lt;/h5&gt;&lt;h6&gt;标题&lt;/h6&gt; 2.段落标签123&lt;p&gt; 用于划分段落&lt;/p&gt; 3.换行标签HTML5中，单标签的/可省略： 123&lt;br /&gt;&lt;br &gt;&lt;br&gt; 4.分隔线标签123&lt;hr width=&quot;20%&quot; /&gt;&lt;hr &gt;&lt;hr&gt; 5.注释标签&lt;!--注释--&gt;1234&lt;!--注释任意内容单多行无所谓--&gt; 6.常用文本格式标签123456789101112131415&lt;b&gt;加粗&lt;/b&gt;&lt;i&gt;倾斜&lt;/i&gt;&lt;u&gt;下划线&lt;/u&gt;&lt;cite&gt;也是倾斜&lt;/cite&gt;&lt;del&gt;删除线表删除&lt;/del&gt;&lt;ins&gt;下划线表插入&lt;/ins&gt;&lt;sub&gt;文本变为下标&lt;/sub&gt;&lt;sup&gt;文本变为上标&lt;/sup&gt;&lt;pre&gt;保留空格和换行&lt;/pre&gt;&lt;blockquote&gt; 缩进以表示引用&lt;/blockquote&gt; &lt;!--单独占一行--&gt;&lt;code&gt;字符内容等宽显示以适配代码片段&lt;/code&gt; &lt;!--不单独占一行--&gt; 7.超链接标签&lt;a&gt;&lt;/a&gt;在html4 123456&lt;a href=&quot;&quot; target=&quot;_blank&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;!--href属性定义超链接的目标target=&quot;_blank&quot;属性定义该连接在新标签页中打开title=&quot;&quot;属性定义鼠标悬停在连接上时现实的文字提示--&gt; target有以下属性： 属性 作用 _blank 新建窗口打开 _parent 在上一级窗口打开，常在分帧的框架页面中使用 _self 在同一窗口打开，默认值 _top 在浏览器的整个窗口打开，将会忽略所有框架结构 &lt;a&gt;标签中name锚点的用法 1234567&lt;a name=&quot;name01&quot;&gt;文章标题&lt;/a&gt;......&lt;a href=&quot;name01&quot;&gt;点此回到顶部&lt;/a&gt;&lt;!--name属性创建“锚点”，将任一&lt;a&gt;标签的href值设置为此锚点名，点击链接则会跳转到该锚点处。创建的这种带有锚点的标签称为“片段标识符”--&gt; 8.字符实体——html文件中特殊字符的正确显示当要求在页面显示如”&lt;”、”&gt;”或者空格等这种特殊字符时，需要用到字符实体代替输入以避免语法冲突。 注：字符实体是由&amp;号、实体或#实体编号、半角分号三部分组成的，实际应用中使用实体名或实体编号都可以！ 以下是常用字符实体： 显示结果 说明 Entity Name实体名字 Entity Number实体编号 显示一个空格 &amp;nbsp; &amp;#160; &lt; 小于 &amp;lt; &amp;#60; &gt; 大于 &amp;gt; &amp;#62; &amp; &amp;符号 &amp;amp; &amp;#38; “ 半角双引号 &amp;quot; &amp;#34; © 版权 &amp;copy; &amp;#169; &amp;reg; 注册商标 &amp;reg; &amp;#174; &amp;times; 乘号 &amp;times; &amp;#215; &amp;divide; 除号 &amp;divide; &amp;#247; 更多实体编码：常用HTML语言特殊字符对照表(ISO Latin-1字符集) 9.表格和列表（1）表格 表格：是&lt;table&gt;&lt;/table&gt;，表格内包含的行是&lt;tr&gt;&lt;/tr&gt;，行内包含单元格&lt;td&gt;&lt;/td&gt;或&lt;th&gt;&lt;th/&gt; 123456789101112131415161718&lt;table align=&quot;center&quot; border=&quot;1&quot; width=&quot;60%&quot; height=&quot;200&quot;&gt; &lt;caption&gt;表格名称&lt;/caption&gt; &lt;tr&gt;&lt;!--表头--&gt; &lt;th&gt;加粗显示的表头&lt;/th&gt; &lt;th&gt;加粗显示的表头&lt;/th&gt; &lt;th&gt;加粗显示的表头&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt;&lt;!--第一行--&gt; &lt;td&gt;单元格内容&lt;/td&gt; &lt;td&gt;单元格内容&lt;/td&gt; &lt;td&gt;单元格内容&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt;&lt;!--第二行--&gt; &lt;td&gt;单元格内容&lt;/td&gt; &lt;td&gt;单元格内容&lt;/td&gt; &lt;td&gt;单元格内容&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 注：列标签 与 的区别： 里的文本内容会以粗体表示，且默认居中，而 里的文本内容是不加粗、默认居左的；所以 一般用来做表头， 一般用来填数据。 表格的属性： 1234567891011&lt;!--align 规定对齐方式，位于&lt;table&gt;标签内时定义整张表格与其他元素的对齐方式， 位于&lt;tr&gt;&lt;td&gt;内时定义单元格内文字的对齐方式border 定义表格所有内外边框宽度，位于&lt;table&gt;标签内时定义整张表格所有边框宽度，位于&lt;tr&gt;&lt;td&gt;等标签内无效width 可用于整张表或某列定义其宽度height 可用于整张表或某行定义其高度cellpadding 单元格内边距，默认有数值，但无需变动cellspacing 单元格外边距，默认有数值，要去掉需设置为0！--&gt; 合并单元格 需要注意的是，这里并不是真正的将两个单元格合并为一个了，而是将源单元格按照合并的数值和方向放大，随即我们应该手动删除多出来的单元格以达到看上去合并了的效果！ 1234&lt;!--行合并：rowspan=&quot;&quot; 默认向下合并，值填【总共】合并了单元格的数量，填1或0都无效果！列合并：colspan=&quot;&quot; 默认向右合并，值同上--&gt; 其它补充 单元格内可以嵌套表格，以实现较为复杂的布局 … （2）列表 ①有序列表 123456&lt;ol&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; ...&lt;/ol&gt; ②无序列表 123456&lt;ul type=&quot;disc&quot;&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; ...&lt;/ul&gt; 属性type定义项前符号的样式，可选样式有disc黑圆点，circle空心圆，square黑色方块，默认为disc。 ③自定义列表 自定义列表不是一列项目，而是项目及其注释的组合。 列表以&lt;dl&gt;标签开始，每个自定义列表项以&lt;dt&gt;开始，每个自定义列表项的描述以&lt;dd&gt;开始。 12345678&lt;dl&gt; &lt;dt&gt;苹果&lt;/dt&gt; &lt;dd&gt;又大又红&lt;/dd&gt; &lt;dd&gt;apple&lt;/dd&gt; &lt;dt&gt;香蕉&lt;/dt&gt; &lt;dd&gt;又香又甜&lt;/dd&gt; &lt;dd&gt;banana&lt;/dd&gt;&lt;/dl&gt; 10.&lt;iframe&gt;框架标签 使用框架(iframe)，可以实现在一个浏览器窗口同时显示多个网页。 1&lt;iframe src=&quot;romanticism.space&quot; height=&quot;500px&quot; width=&quot;1080px&quot; frameborder=&quot;1px&quot; scrolling=&quot;auto&quot; align=&quot;top&quot;&gt;这里的文字不会显示，除非遇到不支持该标签的浏览器&lt;/iframe&gt; 框架属性 属性height和width定义框架的尺寸 frameborder定义是否显示边框，值1为显示，0为不显示，缺省值为1！ scrolling定义是否显示滚动条，可取值为yes、no、auto（是、否、自动） align设置整个框架相对于其他元素的对齐方式，可选值有left、right、top、middle、bottom五个。（用处不大好像？） 注：HTML5不支持&lt;frame&gt;和&lt;frameset&gt;，HTML4.1不支持&lt;iframe&gt;，可以把需要的文本放在&lt;iframe&gt;和&lt;/iframe&gt;内，以应对无法理解&lt;iframe&gt;的浏览器！ 11.表单所有的HTML标签中，表单标签是最重要的。在实际开发中，最经典的实例就是用户注册，覆盖了表单标签的所有元素。 （1）表单相关标签：①表单标签&lt;form&gt;&lt;form&gt;表单标签，在HTML页面创建一个表单，表单标签在浏览器上没有任何显示。如果数据需要提交到服务器，负责收集数据的标签必须存放在表单标签内。 action属性：请求路径，确定表单提交到服务器的地址（路径）； method属性：请求方式。常用取值：get和post： get（默认值）： 提交的数据追加在请求路径上。例如：/index.html?username=jack&amp;password=1230456，数据格式k&#x2F;v，追加是使用?连接，之后的每一个数据使用&amp;连接； 因为请求路径长度有限，所以get请求提交的数据也有限。 post： 提交的数据不在请求路径上追加（即不显示在地址栏上）。 onsubmit属性：为表单的提交绑定一个事件句柄函数，当用户点击提交按钮时，这个事件句柄函数就会被调用，如果函数返回false则表单不会被提交,如果返回其他的或什么都没有返回，则表单会提交。 ②输入域标签&lt;input&gt; &lt;input&gt;标签用于获得用户输入的信息，type属性值不同，搜集的方式&#x2F;内容不同，是表单里最常用的标签。 type属性： text：文本框，单行输入字段，供用户输入文本，默认宽度为20个字符； password：密码框，输入的内容加密显示； radio：单选框，表示一组互斥选项按钮的其中一个。同时设置相同的name属性才会正确生效，当一个按钮被选中，则其他的按钮变为非选中状态； submit：在页面自动生成提交按钮，点此会把表单数据提交到服务器。一般不写name属性，否则将把“提交”两个字提交到服务器；提交按钮默认是“提交”两字，若要更改其他提示文字，需定义value属性，其值就会变成按钮上的字！ checkbox：复选框； file：文件上传； hidden：隐藏字段，数据会发送到服务器，但浏览器不进行显示； reset：重置按钮，将表单重置为默认值； image：带图形&#x2F;图案&#x2F;图片的提交按钮，通过src给按钮设置图片，作用与submit一样； button：普通按钮，通常与JavaScript结合使用。 name属性： 元素名，如果需要将表单数据提交到服务器，必须提供name属性值，浏览器通过属性值获得提交的数据。 value属性： 设置input标签的默认值。应用到submit和reset里为设置按钮显示的文字。 size属性： 设置大小。 checked属性： 单选框或复选框设置默认被选中。 readonly： 是否只读。 disabled： 是否可用。 maxlength： 允许输入的最大长度。 ③下拉列表标签&lt;select&gt;可进行多选或单选，由子标签&lt;option&gt;指定选择项。 name属性： 发送给服务器的名称。 multiple属性： 不写默认单选，该属性取值为自身时表示多选。 size属性： 多选时，可见选项的数目。 &lt;option&gt;子标签： selected属性：默认该项已选。 value：发送给服务器的选项值。 ⑤文本域标签&lt;textarea&gt; &lt;textarea&gt;文本域，多行的文本输入控件。 cols属性：文本域的列数。 rows属性：文本域的行数。 ⑥按钮标签&lt;button&gt; &lt;button type=&quot;button|reset|submit&quot;&gt; 按钮标签一般很少使用，提供“普通&#x2F;重置&#x2F;提交”功能，不同的浏览器默认值不同。 （2）总结02 123456789101112131415&lt;form action=&quot;https://www.bilibili.com&quot; method=&quot;get&quot; onsubmit=&quot;return onCheckHanShu()&quot;&gt; 用户名&lt;input type=&quot;text&quot; id=&quot;uName&quot; /&gt; 密码&lt;input type=&quot;password&quot; id=&quot;uPaswd&quot; /&gt; 确认密码&lt;input type=&quot;password&quot; id=&quot;uPaswd2&quot; /&gt; 简介&lt;textarea&gt;&lt;/textarea&gt; 性别：男&lt;input type=&quot;radio&quot; name=&quot;sex&quot; /&gt;女&lt;input type=&quot;radio&quot; name=&quot;sex&quot; /&gt; 爱好：音乐&lt;input type=&quot;checkbox&quot; value=&quot;music&quot; /&gt;运动&lt;input type=&quot;checkbox&quot; value=&quot;sport&quot; /&gt; 你喜欢的水果： &lt;select name=&quot;fruit&quot; size=&quot;0&quot; multiple&gt; &lt;option value=&quot;apple&quot;&gt;林檎&lt;/option&gt; &lt;option value=&quot;banana&quot;&gt;香蕉&lt;/option&gt; &lt;option value=&quot;orange&quot;&gt;橙子&lt;/option&gt; &lt;/select&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; onsubmit=&quot;&quot; /&gt;&lt;/form&gt; HTML 表单(Form)是 HTML 的一个重要部分，主要用于采集和提交用户输入的信息。 1.表单的组成部分： 学习 HTML 表单(Form)最关键要掌握的有三个要点： 表单控件(Form Controls) 通过 HTML 表单的各种控件，用户可以输入文字信息，或者从选项中选择，以及做提交的操作。比如&lt;input type= &quot;text&quot;&gt;就是一个表单控件，表示一个单行输入框。 Action 表单里的 action 就指明了处理表单信息的文件。提交表单的地址 Method 至于 method，表示了发送表单信息的方式。method 有两个值：get 和post。get 的方式是将表单控件的 name&#x2F;value 信息经过编码之后，通过URL 发送(你可以在地址栏里看到)。而 post 则将表单的内容通过 http 发送，你在地址栏看不到表单的提交信息。 2.表单常用控件： 表单控件 说明 &lt;input type=&quot;text&quot; /&gt; 单行文本输入框 &lt;input type=&quot;password&quot; /&gt; 密码输入框，输入的内容显示为星号* &lt;input type=&quot;radio&quot; /&gt; 单选框 &lt;input type=&quot;checkbox&quot; /&gt; 复选框 &lt;textarea&gt;&lt;/textarea&gt; 多行文本输入框 &lt;input type=&quot;submit&quot;&gt; 将表单信息提交给action指向的文件 &lt;select&gt;&lt;option&gt;&lt;option&gt;&lt;/select&gt; 见下文详解 &lt;input type=&quot;file&quot;&gt; 上传文件 &lt;input type=&quot;reset&quot;&gt; 全部重做&#x2F;清空按钮 ①单行文本输入框 默认占一行 1&lt;input type=&quot;text&quot; /&gt; ②密码输入框 默认占一行 1&lt;input type=&quot;password&quot; /&gt; ③单选框 对于如性别等只允许单选的一组选项可设置单选框，对同一主题的一组单选框必须设置属性name的值相同才能正确生效！ 默认不换行！ 123&lt;input type=&quot;redio&quot; name=&quot;sex&quot; /&gt;男&lt;input type=&quot;redio&quot; name=&quot;sex&quot; /&gt;女&lt;input type=&quot;redio&quot; name=&quot;sex&quot; checked=&quot;checked&quot; /&gt;保密 checked属性定义该选择框默认为已选状态 ④复选框 同上，复选框允许用户在一组选项里选择多个选项，前提是设置属性name的值为相同内容！ 默认不换行！ 123&lt;input type=&quot;checkbox&quot; value=&quot;music&quot; name=&quot;habbit&quot; /&gt;&lt;input type=&quot;checkbox&quot; value=&quot;sport&quot; name=&quot;habbit&quot; /&gt;&lt;input type=&quot;checkbox&quot; value=&quot;打电动&quot; name=&quot;habbit&quot; checked=&quot;checked&quot; /&gt; 属性value的值为提交上去的的实际后台的记录。 ⑤多行文本 1&lt;textarea cols=&quot;20&quot; rows=&quot;20&quot;&gt;&lt;/textarea&gt; cols定义宽度，rows定义高度，但大小默认是可拖拽的。 ⑥提交submit 1&lt;input type=&quot;submit&quot; /&gt; ⑦下拉列表 下拉列表可做单选也可做多选： 12345&lt;select name=&quot;fruit&quot; size=&quot;3&quot; multiple&gt; &lt;option value=&quot;apple&quot;&gt;林檎&lt;/option&gt; &lt;option value=&quot;banana&quot;&gt;香蕉&lt;/option&gt; &lt;option value=&quot;strawberry&quot;&gt;草莓&lt;/option&gt;&lt;/select&gt; select的属性size定义下拉列表默认显示的行数，其值是数字几就显示为几行文字的高度，不受单位px的影响！ multiple定义是否支持多选，多选状态时客户端可按住Ctrl操作多选！ 总结： 1234567891011121314151617181920212223242526272829303132333435363738394041一、form表单 &lt;form&gt; &lt;!--输入内容--&gt; &lt;input type=&quot;&quot;/&gt; type属性： =&quot;text&quot; 输入文本 =&quot;password&quot; 输入密码 =&quot;hidden&quot; 隐藏的内容 =&quot;radio&quot; 单选框 =&quot;checkbox&quot; 多选框 =&quot;file&quot; 输入/上传文件 =&quot;button&quot; 普通按钮 =&quot;reset&quot; 全部重做/清空按钮 =&quot;submit&quot; 提交按钮 placeholder=&quot;请输入密码&quot; 未输入内容时提示信息 size=&quot;10px&quot; 约束输入框的长度 maxlength=&quot;16&quot; 限制输入内容的最大长度 required=&quot;required&quot; 限制必须输入内容后才可以提交 checked=&quot;checked&quot; 在某项内使用——默认该项已选 name=&quot;&quot; value=&quot;&quot; &lt;!--文本输入域--&gt; &lt;textarea name=&quot;zwjs&quot;&gt; balabalabalabala...... &lt;/textarea&gt; &lt;!--下拉列表--&gt; &lt;select name=&quot;自定义&quot;&gt; &lt;option selected=&quot;selected&quot;&gt;balabala&lt;/option&gt; &lt;option selected=&quot;selected&quot;&gt;balabala&lt;/option&gt; &lt;!--对某一项使用selected时——网页默认选择该项--&gt; &lt;/select&gt; &lt;/form&gt; --总结： 1.用户输入和选择的内容，标签里必须用name命名，选择的内容还必须有默认值value=&quot;xxx&quot; 2.get与post提交方式的区别： get：所有提交的内容会显示在地址栏，不够安全，长度有限制； post：不会在地址栏显示提交的内容，比较安全，长度没有限制。 12.图片标签1&lt;img src=&quot;img/猪大叔素材 (100).jpg&quot; title=&quot;图像提示文字&quot; alt=&quot;你图没了&quot; align=&quot;center&quot; width=&quot;&quot; /&gt; 注：如果给图片只设置width、height的其中一个，那么图片会按原比例缩放，如果二者都设置了值，那么图片的长宽只会按照既定的尺寸拉伸！ 图片标签的align有以下属性： 属性 作用 top 把图像的顶部和同行最高的文本或图像的顶部对齐 midle 把图像的中部与同行文字基线或图像的中部对齐 bottom 把图像的底部与同行文字基线或图像的底部对齐 texttop 把图像的顶部和同行的文本的顶部对齐 absmiddle 把图像的中部和同行中最大项的中部对齐 baseline 把图像的底部与同行文字基线对齐 left、center、right 文字环绕图像左中右对齐 二、头部信息（head部分）12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;网站显示的标题&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./新拟态.css&quot; type=&quot;text/css&quot; /&gt; &lt;script src=&quot;./js/dayNightSwitch.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt; &lt;/script&gt; &lt;style&gt; //这里可以直接写css代码 &lt;/style&gt; &lt;/head&gt; ...&lt;/html&gt; 1.&lt;script&gt;&lt;/script&gt;标签用来引入外部脚本文件，或在其内容中写入脚本代码。 1&lt;script src=&quot;./js/dayNightSwitch.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt; &lt;/script&gt; 1234567891011121314151617&lt;script&gt; window.onload = function()&#123; var btn01 = document.getElementById(&quot;dayNightBtn&quot;); var tips = &quot;day&quot;; var linkList = document.getElementsByTagName(&quot;link&quot;); var imgs = document.getElementById(&quot;dayNightBtn&quot;).src; btn01.onclick = function()&#123; if(tips == &quot;day&quot;)&#123; tips = &quot;night&quot;; linkList[0].href = &quot;./css/新拟态&quot; + tips + &quot;.css&quot;; &#125;else&#123; tips = &quot;day&quot;; linkList[0].href = &quot;./css/新拟态&quot; + tips + &quot;.css&quot;; &#125; &#125; &#125;&lt;/script&gt; 不是单标签，必须成对使用！ src属性：脚本文件的地址； type属性：脚本的类型； charset：脚本的编码方式，可省略。 2.引入外部css文件1&lt;link rel=&quot;stylesheet&quot; href=&quot;./新拟态.css&quot; type=&quot;text/css&quot; /&gt; link标签为单标签； rel属性为链接文件的类型，css文件必须填stylesheet且不可省略！ href为链接文件的地址； type属性为类型，要么省略要么写text/css。 三、补充 &lt;font&gt;&lt;/font&gt;标签已不再支持，请用CSS代替！ 其他更多慢慢补充…… &lt;body&gt;&lt;/body&gt;标签有以下属性： 属性 描述 text 设定页面文字颜色 bgcolor 设定页面背景颜色 background 设置图片背景 bgproperties 设定不随页面滚动的背景图像 link 设定默认的链接颜色 alink 设定鼠标正在单击的链接颜色 vlink 设定已访问过的链接颜色 topmargin 页面上边距 leftmargin 页面左边距","categories":[{"name":"前端","slug":"前端","permalink":"http://kouqiang.space/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"学习总结","slug":"学习总结","permalink":"http://kouqiang.space/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"},{"name":"前端","slug":"前端","permalink":"http://kouqiang.space/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Html","slug":"Html","permalink":"http://kouqiang.space/tags/Html/"}],"author":"寇强"},{"title":"DDBot食用指南","slug":"DDBot食用指南","date":"2022-06-16T06:38:00.000Z","updated":"2023-01-09T16:10:26.775Z","comments":true,"path":"2022/06/16/DDBot食用指南/","link":"","permalink":"http://kouqiang.space/2022/06/16/DDBot%E9%A3%9F%E7%94%A8%E6%8C%87%E5%8D%97/","excerpt":"","text":"DDBot食用指南B站专栏介绍：https://www.bilibili.com/read/cv10602230 项目及源代码地址：https://github.com/Sora233/DDBOT 详细配置参考技术文档：https://gitee.com/sora233/DDBOT/blob/master/EXAMPLE.md#watch 官方唯一指定交流群：755612788 获取bot：官方如今不再提供公开BOT，你可以加入官方唯一QQ交流群（755612788）申请使用某些群友爱心人士搭建的BOT（进群礼貌提问大家有没有公开的bot），也可以选择在自己的服务器上搭建。 如果你获取到了群友爱心人士提供的公开bot，那么可以加bot为QQ好友，先将bot拉进自己要部署的群里，然后在群聊或私聊聊天框内直接输入并发送下文中的指令即可完成部署。 ps：私聊bot的话输入的指令必须指定要配置的QQ群号，即-g QQ群号，而在群内直接发送指令则不需要！ 部署步骤&#x2F;指令总结（以私聊bot为例）： 订阅某主播直播和动态提醒： 12/watch -g 群号 主播UID //订阅开播提醒/watch -g 群号 -t news 主播UID //订阅发动态提醒 取消订阅某主播直播和动态提醒： 12/unwatch -g 群号 主播UID //取消订阅开播提醒/unwatch -g 群号 -t news 主播UID //取消订阅发动态提醒 订阅下播提醒： 12/config -g 群号 offline_notify 主播UID on //订阅下播提醒/config -g 群号 offline_notify 主播UID off //取消订阅下播提醒 设置主播转发别人动态时不提醒： 1/config -g 群号 filter not_type 主播UID 转发 取消该设置： 1/config -g 群号 filter clear 主播UID 配置为特定主播@一个或多个特定成员 1/config -g 群号 at -s bilibili 主播UID add QQ号 QQ号 删除配置中的特定成员：（即把add改为remove） 1/config -g 群号 at -s bilibili 主播UID remove QQ号 QQ号 查看配置的成员列表： 1/config -g 群号 at -s bilibili 主播UID show 清空配置的成员列表： 1/config -g 群号 at -s bilibili 主播UID clear 官方QQ群公告：群公告： 本群为DDBOT用户交流群，你在群里提出的建议和吐槽都会得到反馈，平时发现了有趣的v可以发到群里一起D。群内@Q群管家可获取部分问题回复提问之前确保你已经阅读了以下网页内容：DDBOT：https://gitee.com/sora233/DDBOT部署指南：https://gitee.com/sora233/DDBOT/blob/master/INSTALL.md指令示例：https://gitee.com/sora233/DDBOT/blob/master/EXAMPLE.mdFAQ：https://gitee.com/sora233/DDBOT/blob/master/FAQ.mdDDBOT-您的QQ群单推小助手：https://b23.tv/kabe7Ot群主手把手教程：https://b23.tv/k9mmZU1以下是一些通用群规：一、基本上不限制群聊方向，只是不聊政治历史话题。二、禁止发不适合在公共场合打开的图片。 介绍开源项目DDBOT的用法，用机器人来对付主播的阴间突击。本项目禁止商业用途。 唯一指定交流群：755612788项目及源代码地址：https://github.com/Sora233/DDBOTB站专栏介绍：https://www.bilibili.com/read/cv10602230发现BUG或错误可以在本视频或专栏下留言反馈 本文由B站用户乃琳今晚mua哪个编辑","categories":[{"name":"其他工具","slug":"其他工具","permalink":"http://kouqiang.space/categories/%E5%85%B6%E4%BB%96%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"DDBot","slug":"DDBot","permalink":"http://kouqiang.space/tags/DDBot/"}],"author":"寇强"},{"title":"Kali工具集","slug":"Kali工具集","date":"2022-06-06T19:08:00.000Z","updated":"2023-01-09T16:10:58.594Z","comments":true,"path":"2022/06/07/Kali工具集/","link":"","permalink":"http://kouqiang.space/2022/06/07/Kali%E5%B7%A5%E5%85%B7%E9%9B%86/","excerpt":"","text":"Kali工具集一、存活主机识别（一）arping1.介绍ARP协议是“Address Resolution Protocol”（地址解析协议）的缩写。 在同一以太网中，通过地址解析协议，源主机可以通过目的主机的IP地址获得目的主机的MAC地址。arping程序就是完成上述过程的程序。 arping，用来向局域网内的其它主机发送ARP请求的指令，它可以用来测试局域网内的某个IP是否已被使用。 2.参数释义123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101--help 打印帮助信息 -0 使用此选项可对源IP地址0.0.0.0执行ping操作。 尚未配置接口时，请使用此选项。请注意，这可能无法应答MAC-ping。这是-S 0.0.0.0的别名。 -a 打印ping结果 -A 只计算与请求的地址匹配的地址(这将中断你做的大多数事情。仅当你一次添加多个主机时才有用。) -b 与-0类似，但源广播的源地址（255.255.255.255）。请注意，这可能会使arping没有得到响应，因为这不是主机的正常行为。 -B 如果要寻址255.255.255.255，请使用代替主机。 -c count 只发送计数请求。 -C count 无论-c和-w如何，都只等待计数答复。（个人理解为-c和-w操作失效） -d 查找重复的答复。 如果该答复来自两个不同MAC地址，则以1退出。 -D 收到答复显示为感叹号，信息包丢失显示为点。类似思科设备的泛ping结果显示。 -e 类似-a操作，但是在没有回复时发出哔声 -F 不要在接口名称上大费周章。虽然没有给出这个开关，但是-i会取代该操作。 -g group setgid()设置为此组取代nobody组。 -h 打印帮助信息 -i interface 指定的网卡接口 -m type 用于传入数据包的时间戳类型。ping时使用-vv列出可用数据包。 -p 打开接口的混合模式，当你正在使用的MAC地址不是你自己的，请使用此模式。 -P 发送ARP答复而不是请求。 与-U一起使用。 -q 只显示报错信息 -Q priority 要设置的802.1p优先级。应与802.1Q标记（-V）一起使用。默认值为0。 -r 原始输出:每个回复只显示MAC/IP地址。 -R 原始输出：与-r类似，但显示ip地址，可以与-r组合。 -s MAC 设置源MAC地址 您可能需要与-p一起使用。 -S IP 与-b和-0类似，但源地址已设置。请注意，如果目标没有到IP的路由，则可能无法应答Arping。如果您不拥有所使用的IP，则可能需要打开Promiscious 接口上的-p模式（使用-p）。使用此开关，您可以查找主机拥有的IP地址，而无需自己获取IP地址。 -t MAC 设置要在ping IP地址时使用的目标MAC地址。 -T IP 使用-T作为目标地址，当ping mac不会响应广播ping，但可能对定向广播。 例： 要检查MAC-A的地址，请使用MAC-B和IP-B的知识。 $ arping -S &lt;IP-B&gt;-s &lt;MAC-B&gt; -p &lt;MAC-A&gt; -u ping MAC时，显示index = received / sent，而不只是index = received -U 发送未经请求的ARP。 这会将ARP帧中的目标MAC地址设置为广播地址。 未经请求的ARP用于更新邻居的ARP缓存。 例： $ arping -i &lt;interface&gt;-U &lt;interface IP&gt; -v 详细输出。 使用两次获取更多消息。 -V vlan 设置VLAN标记。默认为无VLAN标记 -w sec 无论是否发送或接收了多少个数据包，都要在ping退出之前指定一个超时时间。 -W sec ping之间的等待时间。 2.实例（1）查看某个IP的MAC地址，检验该主机是否存活1arping 192.168.1.1 -c 1 -c 1表示发送了一个数据包，该部分写在IP地址前后都可。 得到0% unanswered说明存活，100% unanswered说明未存活。 （2）（二）fping（三）hping3（四）masscan（五）thcping6","categories":[{"name":"其他工具","slug":"其他工具","permalink":"http://kouqiang.space/categories/%E5%85%B6%E4%BB%96%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://kouqiang.space/tags/markdown/"}],"author":"寇强"},{"title":"Linux基础终端指令","slug":"Linux基础终端指令","date":"2022-06-01T01:59:00.000Z","updated":"2023-01-09T16:11:07.233Z","comments":true,"path":"2022/06/01/Linux基础终端指令/","link":"","permalink":"http://kouqiang.space/2022/06/01/Linux%E5%9F%BA%E7%A1%80%E7%BB%88%E7%AB%AF%E6%8C%87%E4%BB%A4/","excerpt":"","text":"Linux基础终端指令一、文本文件操作基础命令1.查看当前路径1pwd 2.切换路径1cd /var/MyProject01 3.创建文件夹1mkdir MyProject01 4.复制文件12cp /root/123.txt /var/MyProject01//将root目录下的123.txt文件复制到/var/MyProject01目录下 5.移动文件1mv /root/123.txt /var/MyProject01 6.删除文件1rm 123.txt 7.删除整个文件夹1rm -rf MyProject01 8.查看文件内容1cat 123.txt 注：该命令不能用于查看文件夹 9.查看文件大小1du -h 123.txt 10.查看某路径下的所有文件和文件夹1ls 路径名 11.查看当前路径下所有文件夹和文件1ls 12.复制粘贴文本内容ctrl+insert和shift+insert，或ctrl+shift+c和ctrl+shift+v 清屏1clear 桌面路径1cd /home/kali/Desktop","categories":[{"name":"Linux","slug":"Linux","permalink":"http://kouqiang.space/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://kouqiang.space/tags/Linux/"}],"author":"寇强"},{"title":"kali安装和前期准备","slug":"kali安装及其准备","date":"2022-06-01T01:55:00.000Z","updated":"2023-01-09T16:10:49.440Z","comments":true,"path":"2022/06/01/kali安装及其准备/","link":"","permalink":"http://kouqiang.space/2022/06/01/kali%E5%AE%89%E8%A3%85%E5%8F%8A%E5%85%B6%E5%87%86%E5%A4%87/","excerpt":"","text":"kali安装和前期准备一、安装虚拟机（VMware）教程CSDN上一搜一大堆！ 二、安装Kali（2021）教程CSDN上一搜一大堆！ 默认用户名和密码： 旧版本是root和toor，新版本默认用户名和密码都是kali 三、配置kali1.改用户密码和用户名参考链接：新kali版本，root默认密码_繁华king的博客-CSDN博客_kali root密码 Kali Linux 2021.2修改Root用户密码，开启ssh，修改中文语言_菜头同学的博客-CSDN博客_kali linux root 密码 步骤： 123456789sodu su输入原密码passwd root两次输入新密码重启系统 2.改语言为中文①sudo dpkg-reconfigure locales ②要求输入用户密码 ③在弹出的窗口中的列表里上下左右键和空格键选择，取消en_US.UTF-8 UTF-8，选择zh_CN.UTF-8 UTF-8，使用TAB键选择“ok”按钮回车。 注：旧版Kali-Linux修改语言后需安装中文字体，否则中文显示乱码 3.修改更新源并更新步骤：终端用sudo vim /etc/apt/sources.list指令打开该文件，将原来的kali官方源注释掉，添加新的国内的源（中科大源或阿里的源），重启完成更改，然后更新。 注：此时用的是默(万)认(恶)的vim编辑器！ 参考链接：Kali2021修改更新源_zxl2605的博客-CSDN博客_kali更新源 kali下载完成后你要做的那些事（换源，更新，中文输入法）_玄予的博客-CSDN博客_kali官方源 ①sudo vim /etc/apt/sources.list ②按i进入编辑模式，在原来的代码前敲上#，在下方添加如下代码123456#中科大源deb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contribdeb-src http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib#阿里云源deb http://mirrors.aliyun.com/kali kali-rolling main non-free contribdeb-src http://mirrors.aliyun.com/kali kali-rolling main non-free contrib 按Esc退出编辑模式，输入: wq，回车，重启kali，更换完成。 ③更新系统在终端输入： 1234apt update回车apt -y full-upgrade回车 等待…总共七百多M，我200k&#x2F;s的网速得等两个多小时。 完成。 3.安装中文输入法（我安的搜狗）①下载搜狗输入法Linux版安装包（官网https://pinyin.sogou.com/linux） 可以在kali里的Firefox里面下载，也可主机下载好后通过共享文件夹共享到kali里面。 ②在文件存放路径下打开终端或在终端内将路径改到文件存放目录（我的是&#x2F;home&#x2F;kali&#x2F;Downloads），进入root，ls指令显示当前文件夹下所有文件和文件夹。 ③终端dpkg -i 软件包名安装软件（我这里是dpkg -i sogoupinyin_4.0.1.2123_amd64.deb） 出现问题 不慌，现在按照它所需要的软件包一个一个安装，或者也可以直接使用apt -f install命令来解决依赖包问题 完成： 再次dpkg -i sogoupinyin_4.0.1.2123_amd64.deb reboot重启完成安装 在任何需要输入的地方都使用ctrl+空格键来开启搜狗输入法，shift键切换中英文。 4.配置共享文件夹（需提前安装vmtools）①VMware中设置 ②kali内挂载共享文件夹 kali里创建共享文件夹目录： 在路径文件系统/mnt/下新建hgfs文件夹，再在此文件夹内以你vmware中的共享文件夹为名的新文件夹&#96;&#96; 可以在窗口中直接操作，也可以在终端操作（都需要root权限） 挂载共享文件夹 12/usr/bin/vmhgfs-fuse .host:/share_kali /mnt/hgfs/share_kali -o subtype=vmhgfs-fuse,allow_other//注意：我这里的目标路径是/share_kali 检查下： 设置每次开机自动挂载共享文件夹，重启。 在/etc/fstab文件中添加以下内容： 1.host:/share_kali /mnt/hgfs/share_kali fuse.vmhgfs-fuse allow_other 0 0 保存，重启即可 参考帖子：设置VMware中Kali共享文件夹_jun2016425的博客-CSDN博客_kali共享文件夹位置 四、安装靶机","categories":[{"name":"kali","slug":"kali","permalink":"http://kouqiang.space/categories/kali/"}],"tags":[{"name":"kali","slug":"kali","permalink":"http://kouqiang.space/tags/kali/"},{"name":"软件安装","slug":"软件安装","permalink":"http://kouqiang.space/tags/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"}],"author":"寇强"},{"title":"Typora快捷键大全","slug":"Typora快捷键大全","date":"2022-05-23T09:44:00.000Z","updated":"2023-01-09T16:11:38.852Z","comments":true,"path":"2022/05/23/Typora快捷键大全/","link":"","permalink":"http://kouqiang.space/2022/05/23/Typora%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%A4%A7%E5%85%A8/","excerpt":"","text":"目录一、菜单栏二、文件三、编辑四、段落五、格式六、视图 一、菜单栏文件：alt+F 编辑：alt+E 段落：alt+P 格式：alt+O 视图：alt+V 主题：alt+T 帮助：alt+H 二、文件新建：Ctrl+N 新建窗口：Ctrl+Shift+N 打开：Ctrl+O 快速打开：Ctrl+P 保存：Ctrl+S 另存为：Ctrl+Shift+S 偏好：Ctrl+, 关闭：Ctrl+W 三、编辑撤销：Ctrl+Z 重做：Ctrl+Y 剪切：Ctrl+X 复制：Ctrl+C 粘贴：Ctrl+V 复制为MarkDown：Ctrl+Shift+C 粘贴为纯文本：Ctrl+Shift+V 全选：Ctrl+A 选中当前行&#x2F;句：Ctrl+L 选中当前格式文本：Ctrl+E 选中当前词：Ctrl+D 跳转到文首：Ctrl+Home 跳转到所选内容：Ctrl+J 跳转到文末：Ctrl+End 查找：Ctrl+F 查找下一个：F3 查找上一个：Shift+F3 替换：Ctrl+H 四、段落标题：Ctrl+1&#x2F;2&#x2F;3&#x2F;4&#x2F;5 段落：Ctrl+0 增大标题级别：Ctrl+&#x3D; 减少标题级别：Ctrl± 表格：Ctrl+T 代码块：Ctrl+Shift+K 公式块：Ctrl+Shift+M 引用：Ctrl+Shift+Q 有序列表：Ctrl+Shift+[ 无序列表：Ctrl+Shift+] 增加缩进：Ctrl+] 减少缩进：Ctrl+[ 五、格式加粗：Ctrl+B 斜体：Ctrl+I 下划线：Ctrl+U 代码：Ctrl+Shift+&#96; 删除线：Alt+Shift+5 超链接：Ctrl+K 图像：Ctrl+Shift+I 清除样式：Ctrl+ 六、视图显示隐藏侧边栏：Ctrl+Shift+L 大纲视图：Ctrl+Shift+1 文档列表视图：Ctrl+Shift+2 文件树视图：Ctrl+Shift+3 源代码模式：Ctrl+&#x2F; 专注模式：F8 打字机模式：F9 切换全屏：F11 实际大小：Ctrl+Shift+0 放大：Ctrl+Shift+&#x3D; 缩小：Ctrl+Shift+ - 应用内窗口切换：Ctrl+Tab 打开DevTools：Shift+F12","categories":[{"name":"Typora","slug":"Typora","permalink":"http://kouqiang.space/categories/Typora/"}],"tags":[{"name":"Typora","slug":"Typora","permalink":"http://kouqiang.space/tags/Typora/"},{"name":"快捷键","slug":"快捷键","permalink":"http://kouqiang.space/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"}],"author":"寇强"},{"title":"","slug":"md文档进阶操作","date":"2021-12-06T02:59:00.000Z","updated":"2023-04-21T13:48:57.673Z","comments":true,"path":"2021/12/06/md文档进阶操作/","link":"","permalink":"http://kouqiang.space/2021/12/06/md%E6%96%87%E6%A1%A3%E8%BF%9B%E9%98%B6%E6%93%8D%E4%BD%9C/","excerpt":"","text":"md文档进阶用法一、mermaid语法1、mermaid语法介绍 什么是mermaid语法 Mermaid是一种基于Javascript的绘图工具，使用类似于Markdown的语法，使用户可以方便快捷地通过代码创建图表。 项目源码：https://github.com/mermaid-js/mermaid。 如何使用该语法 使用集成了Mermaid渲染功能的Markdown编辑器，如Typora。 使用特定的Mermaid渲染器。 Mermaid能绘制那些图 饼状图pie 流程图graph 序列图sequenceDiagram 甘特图gantt 类图classDiagram 状态图stateDiagram 用户旅程图journey 注释语法为：%%注释内容 2、详解主要介绍饼状图和流程图，其他图几乎不用，有些还处于测试阶段暂不了解。 （1）饼状图：pie 会自动重新配比各个数值比例。 不能自定义颜色位置等。 123456pie title 为什么学计算机 &quot;嫌头发太多&quot;:20 &quot;嫌寿命太长&quot;:50 &quot;嫌晚上睡太早&quot;:50 &quot;嫌皮肤太好&quot;:10 显示结果： pie title 为什么学计算机 \"嫌头发太多\":20 \"嫌寿命太长\":50 \"嫌晚上睡太早\":50 \"嫌皮肤太好\":10 （2）流程图：graph①定义方向： 位于开头，用来定义流程图连线方向（而不是布局方向）。 默认graph或graph TB或graph TD：从上到下。 graph BT：从下到上。（graph DT无效！） graph LR：从左到右。 graph RL：从右往左。 ②定义结点：12345678graph 默认方形 节点名1[方框形状] 节点名2(圆角矩形) 节点名3([腰圆键形]) 节点名4[[子程序形]] id5[(圆柱形)] id6((圆形)) 1234567graph id7&#123;菱形&#125; id8&#123;&#123;六边形&#125;&#125; id9[/平行四边形/] id10[\\反向平行四边形\\] id11[/梯形\\] id12[\\反向梯形/] 显示结果分别为： graph %%共有12种样式 默认方形 节点名1[方框形状] 节点名2(圆角矩形) 节点名3([腰圆键形]) 节点名4[[子程序形]] id5[(圆柱形)] id6((圆形)) graph %%共有12种样式 id7{菱形} id8 id9[/平行四边形/] id10[\\反向平行四边形\\] id11[/梯形\\] id12[\\反向梯形/] 注： 节点名不能有空格。 显示内容文本里的多个连续的空格只显示一个。 ③定义连线： 线条样式： 普通直线---，加粗直线===，虚线-.-。 增加一个相应字符即可延长线段（虚线是加.）。 12graph LR a----b===c-...-d graph LR a----b===c-...-d 箭头样式 更改线条两端的字符即可添加箭头。 12graph LR a--&gt;b==&gt;c-..-&gt;d graph LR a-->b==>c-..->d 默认仅支持右箭头，将关键字graph改为floechart即可使用其他样式箭头。 12flowchart LR a &lt;--&gt; b o==o c x-.-x d flowchart LR a b o==o c x-.-x d 添加文本 直接加在箭头中间，或者用|文本内容|加在箭头后面。 12graph LR a--文本1--&gt;b==&gt;|文本2|c-.文本3.-&gt;d graph LR a--文本1-->b==>|文本2|c-.文本3.->d flowchart格式图的文本显示在底层： 12flowchart LR a &lt;--文本--&gt; b o==文本==o c x-.文本.-x d flowchart LR a b o==文本==o c x-.文本.-x d ④多对多连接：用&amp;字符连接结点即可： 12graph a &amp; b --&gt; c &amp; d graph a & b --> c & d 实例：朱元璋家谱简图，圆圈代表皇帝。 12345678910graph LRemperor((朱八八))-.子.-&gt;朱五四-.子.-&gt;朱四九-.子.-&gt;朱百六朱雄英--长子--&gt;朱标--长子--&gt;emperoremperor2((朱允炆))--次子--&gt;朱标朱樉--次子--&gt;emperor朱棡--三子--&gt;emperoremperor3((朱棣))--四子--&gt;emperoremperor4((朱高炽))--长子--&gt;emperor3 graph LR emperor((朱八八))-.子.->朱五四-.子.->朱四九-.子.->朱百六 朱雄英--长子-->朱标--长子-->emperor emperor2((朱允炆))--次子-->朱标 朱樉--次子-->emperor 朱棡--三子-->emperor emperor3((朱棣))--四子-->emperor emperor4((朱高炽))--长子-->emperor3 3、不知道叫什么名字 flowchart语法： flowchart语法只有两块内容——定义元素和连接元素。 123456789sta=&gt;start: 开始框:&gt;https://bilibli.comop=&gt;operation: 处理框cond=&gt;condition: 条件语句/判断框(是或否?)sub1=&gt;subroutine: 子流程io=&gt;inputoutput: 输入输出框e=&gt;end: 结束框sta-&gt;op-&gt;condcond(yes)-&gt;io-&gt;econd(no)-&gt;sub1(right)-&gt;op 4、序列图1234567891011Title: 标题：复杂使用对象A-&gt;对象B: 对象B你好吗?（请求）Note right of 对象B: 对象B的描述Note left of 对象A: 对象A的描述(提示)对象B--&gt;对象A: 我很好(响应)对象B-&gt;小三: 你好吗小三--&gt;&gt;对象A: 对象B找我了对象A-&gt;对象B: 你真的好吗？Note over 小三,对象B: 我们是朋友participant CNote right of C: 没人陪我玩 二、其它补充 按钮样式&lt;kbd&gt;显示文字&lt;/kbd&gt;和强制换行&lt;br&gt;： 1&lt;kbd&gt;Win&lt;/kbd&gt; + &lt;kbd&gt;Shift&lt;/kbd&gt; + &lt;kbd&gt;s&lt;/kbd&gt; ：截&lt;br&gt;强制换行 显示效果： Win + Shift + s ：截图和强制换行 输入公式： 12345678910$$\\begin&#123;equation&#125;Fib(n)=\\left \\&#123; \\begin&#123;aligned&#125;Fib(n-1)+Fib(n-2), n&gt;1 \\\\1, n=1 \\\\0, n=0\\end&#123;aligned&#125; \\right.\\end&#123;equation&#125;$$ 显示效果：$$\\begin{equation}Fib(n)&#x3D;\\left { \\begin{aligned}Fib(n-1)+Fib(n-2), n&gt;1 \\1, n&#x3D;1 \\0, n&#x3D;0\\end{aligned} \\right.\\end{equation}$$","categories":[{"name":"其他工具","slug":"其他工具","permalink":"http://kouqiang.space/categories/%E5%85%B6%E4%BB%96%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://kouqiang.space/tags/markdown/"}],"author":"寇强"},{"title":"其他工具使用","slug":"番外_相关工具使用及内容补充","date":"2021-12-06T02:59:00.000Z","updated":"2023-09-21T15:21:28.507Z","comments":true,"path":"2021/12/06/番外_相关工具使用及内容补充/","link":"","permalink":"http://kouqiang.space/2021/12/06/%E7%95%AA%E5%A4%96_%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%86%85%E5%AE%B9%E8%A1%A5%E5%85%85/","excerpt":"","text":"✨番外：工具使用及内容补充Vim编辑器狗都不用！ 一、Vim编辑器食用教程vim编辑器有如下三种模式： 基本模式： 移动光标： 键盘上下左右 hjkl键左下上右 space空格向左，backspace向右，enter移动到下一行首，短横【-】键移动到上一行首 删除字符： x（删除光标右侧一个字符，相当于delete），nx（delete掉n个字符），dd（删除当前行），ndd（向下删除包括当前行的n行内容） 写入模式：基本模式按i进入该模式，就可以写入代码了，写完按Esc回到基本模式 低行模式&#x2F;命令行模式：基本模式下输入冒号（我的是按Shift + ;键）进入该模式，该模式下每输一次指令都会自动回到基本模式 w + 回车：保存以编辑内容 q + 回车：退出编辑器 更多教程参考：Linux上vi(vim)编辑器使用教程 - VPS侦探 (vpser.net) win10vim编辑器怎么编辑_百度知道 (baidu.com) 二、为git配置其他文本编辑器在GitBash窗口中输入（以我的EditPlus为例）： 1git config --global core.editor &quot;\\&quot;D:\\KQAPP\\editPlus\\EditPlus.exe\\&quot;&quot; 注意引号和反斜杠\\的数量和位置！！！ 三、git指令123456789101112131415161718192021222324252627ssh //检查是否安装了SSHssh keygen -trsa //在本机生成公钥和私钥ssh -T git@github.com //查看git是否绑定GitHub账号git status //查看当前仓库状态git log //查看仓库提交日志git clone //将远程仓库克隆到本地git config --global user.name &quot;自己的GitHub用户名&quot; //第一次提交之前都需要设置和GitHub一致的用户名和邮箱地址git config --global user.email &quot;账号绑定的邮箱地址&quot; //注意空格和引号的位置及数量！git add 文件名 //将文件添加到缓存区git add -u //只处理已经修改或已删除的文件，不会处理新建的文件git commit -m &quot;这里的备注内容随便填&quot; //将缓存区的文件添加到本地仓库gir commit -a &quot;&quot; //git push //将本地仓库的新文件上传到远程主机git pull //将远程主机与本地仓库的分支合并git branch //查看本地仓库分支git branch -r //查看远程仓库分支git rm -rf 文件名或文件夹名 //删除某文件（夹）rm 文件名 //删除某文件git restore 文件名 //把某文件从缓存区撤销，回到未被追踪的状态pwd //显示当前工作路径","categories":[{"name":"其他工具","slug":"其他工具","permalink":"http://kouqiang.space/categories/%E5%85%B6%E4%BB%96%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Vim编辑器","slug":"Vim编辑器","permalink":"http://kouqiang.space/tags/Vim%E7%BC%96%E8%BE%91%E5%99%A8/"},{"name":"git","slug":"git","permalink":"http://kouqiang.space/tags/git/"}],"author":"寇强"}],"categories":[{"name":"前端","slug":"前端","permalink":"http://kouqiang.space/categories/%E5%89%8D%E7%AB%AF/"},{"name":"编程","slug":"编程","permalink":"http://kouqiang.space/categories/%E7%BC%96%E7%A8%8B/"},{"name":"其他工具","slug":"其他工具","permalink":"http://kouqiang.space/categories/%E5%85%B6%E4%BB%96%E5%B7%A5%E5%85%B7/"},{"name":"摄影","slug":"摄影","permalink":"http://kouqiang.space/categories/%E6%91%84%E5%BD%B1/"},{"name":"建筑学","slug":"建筑学","permalink":"http://kouqiang.space/categories/%E5%BB%BA%E7%AD%91%E5%AD%A6/"},{"name":"考研408笔记","slug":"考研408笔记","permalink":"http://kouqiang.space/categories/%E8%80%83%E7%A0%94408%E7%AC%94%E8%AE%B0/"},{"name":"博客搭建","slug":"博客搭建","permalink":"http://kouqiang.space/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"Linux","slug":"Linux","permalink":"http://kouqiang.space/categories/Linux/"},{"name":"kali","slug":"kali","permalink":"http://kouqiang.space/categories/kali/"},{"name":"Typora","slug":"Typora","permalink":"http://kouqiang.space/categories/Typora/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://kouqiang.space/tags/%E7%BC%96%E7%A8%8B/"},{"name":"前端","slug":"前端","permalink":"http://kouqiang.space/tags/%E5%89%8D%E7%AB%AF/"},{"name":"js","slug":"js","permalink":"http://kouqiang.space/tags/js/"},{"name":"游戏","slug":"游戏","permalink":"http://kouqiang.space/tags/%E6%B8%B8%E6%88%8F/"},{"name":"C/C++","slug":"C-C","permalink":"http://kouqiang.space/tags/C-C/"},{"name":"UI","slug":"UI","permalink":"http://kouqiang.space/tags/UI/"},{"name":"C语言","slug":"C语言","permalink":"http://kouqiang.space/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"Lua","slug":"Lua","permalink":"http://kouqiang.space/tags/Lua/"},{"name":"Html","slug":"Html","permalink":"http://kouqiang.space/tags/Html/"},{"name":"C++","slug":"C","permalink":"http://kouqiang.space/tags/C/"},{"name":"数据结构","slug":"数据结构","permalink":"http://kouqiang.space/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://kouqiang.space/tags/%E7%AE%97%E6%B3%95/"},{"name":"学习总结","slug":"学习总结","permalink":"http://kouqiang.space/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"},{"name":"LATEX","slug":"LATEX","permalink":"http://kouqiang.space/tags/LATEX/"},{"name":"工具","slug":"工具","permalink":"http://kouqiang.space/tags/%E5%B7%A5%E5%85%B7/"},{"name":"Typora","slug":"Typora","permalink":"http://kouqiang.space/tags/Typora/"},{"name":"快捷键","slug":"快捷键","permalink":"http://kouqiang.space/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"name":"SVG","slug":"SVG","permalink":"http://kouqiang.space/tags/SVG/"},{"name":"摄影","slug":"摄影","permalink":"http://kouqiang.space/tags/%E6%91%84%E5%BD%B1/"},{"name":"笔记","slug":"笔记","permalink":"http://kouqiang.space/tags/%E7%AC%94%E8%AE%B0/"},{"name":"建筑学","slug":"建筑学","permalink":"http://kouqiang.space/tags/%E5%BB%BA%E7%AD%91%E5%AD%A6/"},{"name":"bilibili","slug":"bilibili","permalink":"http://kouqiang.space/tags/bilibili/"},{"name":"python","slug":"python","permalink":"http://kouqiang.space/tags/python/"},{"name":"考研笔记","slug":"考研笔记","permalink":"http://kouqiang.space/tags/%E8%80%83%E7%A0%94%E7%AC%94%E8%AE%B0/"},{"name":"SU","slug":"SU","permalink":"http://kouqiang.space/tags/SU/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://kouqiang.space/tags/JavaScript/"},{"name":"博客搭建","slug":"博客搭建","permalink":"http://kouqiang.space/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"CSS","slug":"CSS","permalink":"http://kouqiang.space/tags/CSS/"},{"name":"DDBot","slug":"DDBot","permalink":"http://kouqiang.space/tags/DDBot/"},{"name":"markdown","slug":"markdown","permalink":"http://kouqiang.space/tags/markdown/"},{"name":"Linux","slug":"Linux","permalink":"http://kouqiang.space/tags/Linux/"},{"name":"kali","slug":"kali","permalink":"http://kouqiang.space/tags/kali/"},{"name":"软件安装","slug":"软件安装","permalink":"http://kouqiang.space/tags/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"},{"name":"Vim编辑器","slug":"Vim编辑器","permalink":"http://kouqiang.space/tags/Vim%E7%BC%96%E8%BE%91%E5%99%A8/"},{"name":"git","slug":"git","permalink":"http://kouqiang.space/tags/git/"}]}